<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三栏布局</title>
    <url>/blog/2017/10/20/css-3%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="三栏布局-高度确定"><a href="#三栏布局-高度确定" class="headerlink" title="三栏布局-高度确定"></a>三栏布局-高度确定</h3><p>题：若高度已知，请写出三栏布局，其中左、右两栏宽度300px，中间自适应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span>section&#123; height: 100px; &#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"left"</span> <span class="attr">style</span>=<span class="string">"background: red;"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>左<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"center"</span> <span class="attr">style</span>=<span class="string">"background: yellow;"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>中<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"background: blue;"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>右<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>1.浮动布局</p>
<blockquote>
<p>注意：要改变 html dom 的顺序</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span>section&#123; height: 100px; &#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"left"</span> <span class="attr">style</span>=<span class="string">"background: red;"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"background: blue;"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"center"</span> <span class="attr">style</span>=<span class="string">"background: yellow;"</span>&gt;</span>中<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 300px;</span><br><span class="line">  &#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  width: 300px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用浮动布局后，会导致脱离文档流，需要清除浮动；兼容性比较好。</p>
<p>2.绝对定位</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span>&#123; <span class="attribute">height</span>: <span class="number">100px</span>; &#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝对定位布局，稳定性比较好，尤其在配合 js 使用时，但是会导致脱离文档流，并且其下面的元素也会脱离文档流；</p>
<p>3.flex 布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123; <span class="attribute">height</span>: <span class="number">100px</span>; &#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex布局为css3新增，比较完美的布局方案；</p>
<p>4.table布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123; <span class="attribute">height</span>: <span class="number">100px</span>; &#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  &amp;&gt;<span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>table布局兼容性比较好，一个单元格增高时，会导致同一行中其他单元格的高度变高，还有其他缺点，如它是对TABLE标签的不正规使用，一直以来被大家所诟病。</p>
<p>5.grid布局</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123; <span class="attribute">height</span>: <span class="number">100px</span>; &#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="comment">// grid-template-rows: 100px;</span></span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">300px</span> auto <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三栏布局-高度不定"><a href="#三栏布局-高度不定" class="headerlink" title="三栏布局-高度不定"></a>三栏布局-高度不定</h3><p>当上例中间高度不定时，上述方案还适用吗？</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// section &#123; height: 100px; &#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561879118499.png" alt="1561879118499"></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561879036706.png" alt="1561879036706"></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561878964772.png" alt="1561878964772"></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561878817801.png" alt="1561878817801"></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561879370714.png" alt="1561879370714"></p>
<p>上例中的flex布局、table布局、grid布局仍然适用；</p>
<p>float布局中，中间内容偏移到了左侧浮动元素的下方，可以考虑在中间元素上创建一个 BFC（块级格式上下文），来避免中间元素中的内容受到浮动元素的影响，如设置 <code>overflow: auto</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561885109206.png" alt="1561885109206"></p>
<hr>
<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>伪类和伪元素</title>
    <url>/blog/2017/09/24/css-%E4%BC%AA%E7%B1%BB%E3%80%81%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>一个 CSS  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">伪类（pseudo-class）</a> 是一个以冒号(<code>:</code>)作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。</p>
<a id="more"></a>
<p>常见的伪类有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:active</span><br><span class="line">:any</span><br><span class="line">:checked</span><br><span class="line">:default</span><br><span class="line">:dir()</span><br><span class="line">:disabled</span><br><span class="line">:empty</span><br><span class="line">:enabled</span><br><span class="line">:first</span><br><span class="line">:first-child</span><br><span class="line">:first-of-type</span><br><span class="line">:fullscreen</span><br><span class="line">:focus</span><br><span class="line">:hover</span><br><span class="line">:indeterminate</span><br><span class="line">:in-range</span><br><span class="line">:invalid</span><br><span class="line">:lang()</span><br><span class="line">:last-child</span><br><span class="line">:last-of-type</span><br><span class="line">:left</span><br><span class="line">:link</span><br><span class="line">:not()</span><br><span class="line">:nth-child()</span><br><span class="line">:nth-last-child()</span><br><span class="line">:nth-last-of-type()</span><br><span class="line">:nth-of-type()</span><br><span class="line">:only-child</span><br><span class="line">:only-of-type</span><br><span class="line">:optional</span><br><span class="line">:out-of-range</span><br><span class="line">:read-only</span><br><span class="line">:read-write</span><br><span class="line">:required</span><br><span class="line">:right</span><br><span class="line">:root</span><br><span class="line">:scope</span><br><span class="line">:target</span><br><span class="line">:valid</span><br><span class="line">:visited</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FF0000</span>; </span><br><span class="line">  <span class="attribute">text-decoration</span>: underline; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#00FF00</span>; </span><br><span class="line">  <span class="attribute">text-decoration</span>: none; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000000</span>; </span><br><span class="line">  <span class="attribute">text-decoration</span>: none; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FFFFFF</span>; </span><br><span class="line">  <span class="attribute">text-decoration</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a 标签样式设置顺序，为<code>link–visited–hover-active</code>，也就是我们常说到的 <code>LoVe HAte</code> 原则（大写字母就是它们的首字母）。</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">伪元素（Pseudo-element）</a>跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (<code>::</code>) ， 同样是添加到选择器后面去选择某个元素的某个部分。</p>
<p>常见的伪元素有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::after</span><br><span class="line">::before</span><br><span class="line">::first-letter</span><br><span class="line">::first-line</span><br><span class="line">::selection</span><br><span class="line">::backdrop</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 所有含有"href"属性并且值以"http"开始的元素，</span></span><br><span class="line"><span class="comment">将会在其内容后增加一个箭头（去表明它是外部链接）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[href^=http]</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'⤴'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>垂直居中</title>
    <url>/blog/2017/09/27/css-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>1.父元素高度未知，且目标元素高度未知</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">     <span class="attribute">position</span>:relative;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">childElement</span>&#123;</span><br><span class="line">     <span class="attribute">position</span>:absolute;</span><br><span class="line">     <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2.目标元素高度确定：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">childElement</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.父容器下只有一个元素，且父元素设置了高度</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:xxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">childElement</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.flex布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.父元素高度确定的单行文本，设置height = line-height</p>
<p>6.使用 <code>position: fixed</code> 或 <code>position: absolute</code>  ，加上 <code>margin: auto</code>  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span>&#123;</span><br><span class="line"> 	<span class="attribute">position</span>: fixed / absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>css基础</title>
    <url>/blog/2017/09/25/css-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>IE盒子模型：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561880579648.png" alt></p>
<p>标准盒子模型：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561880530175.png" alt></p>
<a id="more"></a>
<p>设置盒子模型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>;</span><br></pre></td></tr></table></figure>
<p>浏览器默认为 <code>border-box;</code></p>
<h3 id="获取盒模型对应的宽高："><a href="#获取盒模型对应的宽高：" class="headerlink" title="获取盒模型对应的宽高："></a>获取盒模型对应的宽高：</h3><p>仅能获取到行内样式设置的宽高：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dom.style.width/height</span><br></pre></td></tr></table></figure>
<p>获取浏览器渲染后，元素的宽高（无视样式的来源），但是仅 IE 支持此方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dom.currentStyle.width/height</span><br></pre></td></tr></table></figure>
<p>获取浏览器渲染后，元素的宽高（无视样式的来源），所有浏览器支持的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(dom).width/height</span><br></pre></td></tr></table></figure>
<p>获取到距离视窗（view-port）左上角的位置，通常获取元素的绝对位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dom.getBoundingClientRect().width/height</span><br></pre></td></tr></table></figure>
<h3 id="边距重叠"><a href="#边距重叠" class="headerlink" title="边距重叠"></a>边距重叠</h3><p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.child</span>&#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    background: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过打开浏览器调试工具发现，<code>.parent</code> 元素高度为 <code>100px</code>；当设置 <code>overflow: hidden;</code> 后，<code>.parent</code> 元素高度为 <code>110px</code>；</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当设置 <code>overflow: hidden;</code> 时，创建了一个 BFC （块级格式上下文）；</p>
</blockquote>
<h3 id="BFC-渲染原理"><a href="#BFC-渲染原理" class="headerlink" title="BFC 渲染原理"></a>BFC 渲染原理</h3><p>BFC （块级格式上下文），BFC 元素渲染原理：</p>
<ul>
<li>BFC 元素的垂直方向上边距会发生重叠；（取大的值）</li>
<li>BFC 区域<strong>不会</strong>与浮动元素的 box 进行重叠；</li>
<li>BFC 在页面上是一个独立的容器，外面的元素不会影响容器内的元素，反之亦然；</li>
<li>计算 BFC 高度的时候，浮动元素也会参与计算；</li>
</ul>
<h4 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h4><p>如何创建 BFC：</p>
<ul>
<li><code>overflow</code> 的值不为 <code>visible</code> 时；</li>
<li><code>flow</code> 的值不为 <code>none</code> 时；</li>
<li><code>position</code> 的值不为 <code>static</code> 或 <code>relative</code> 时；</li>
<li><code>display</code> 的值为 <code>inline-block</code> 或 <code>table</code> 相关时；</li>
</ul>
<p>消除BFC内子元素之间边距重叠问题，可以给子元素创建一个父元素，用新的父元素创建一个 BFC。</p>
<h4 id="清除浮动的原理"><a href="#清除浮动的原理" class="headerlink" title="清除浮动的原理"></a>清除浮动的原理</h4><p>当父级元素中的子元素，为浮动元素时，子元素的高度不会参与父元素高度的计算，通常表现是，子元素有高度值，而父元素高度为0。可以通过将父元素设置为 BFC ，让子元素高度参与父元素的高度计算。</p>
<blockquote>
<p>BFC 子元素即使是浮动元素，也会参与父元素的高度计算。</p>
</blockquote>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts 轨迹图分片加载</title>
    <url>/blog/2018/08/05/echarts-%E5%9C%B0%E5%9B%BE%E8%BD%A8%E8%BF%B9%E5%88%86%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>以前公司做数据可视化开发，使用的是 Highcharts ，当时觉得挺好用的，配置简单功能齐全，UI色调清新淡雅，唯一的缺点是收费。</p>
<p>那会儿，也听说过 Echarts ，仅了解到是百度开发的并且免费，进入它的官网时，不大喜欢它的UI色调，自认为免费的肯定不会好用，就放弃了上手体验。</p>
<p>直到来到现在这家公司，需要使用 Echarts，才发现原来 Echarts 也很强大，功能模块十分丰富。</p>
<a id="more"></a>
<h2 id="Echarts-渲染地图轨迹"><a href="#Echarts-渲染地图轨迹" class="headerlink" title="Echarts 渲染地图轨迹"></a>Echarts 渲染地图轨迹</h2><p>开发中利用 Echarts 做炫酷的地图轨迹动画时，有遇到这样一个场景，需要将约2000个点的轨迹动画显示在地图上。 </p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018080501.png" alt></p>
<p>一个点的轨迹动画实质是这样的：一个经纬度坐标可以确定点在地图上的位置，当经纬度坐标发生变化时，点在地图上的位置也就发生变化，所以一组变化的坐标就构成了一个点的轨迹动画。</p>
<p>在这个场景中，一条短一些的轨迹有 5~7 个坐标，一条长一些的轨迹有 12~14 个坐标，所以 2000 条轨迹，其数据量就非常庞大了。经过实践发现，服务端返回 2000 条轨迹的数据时会很慢，并且将 2000 条轨迹一下渲染到地图上，十分耗 cpu，浏览器甚至会卡死。</p>
<p>所以这里采用分片加载，将 2000 个轨迹，分 10 次添加到地图上，每 5 秒钟向服务端拿 200 条轨迹数据，渲染到地图上。</p>
<h2 id="echartsInstance-appendData"><a href="#echartsInstance-appendData" class="headerlink" title="echartsInstance.appendData"></a>echartsInstance.appendData</h2><p>echartsInstance.appendData 官方解释为：</p>
<blockquote>
<p>此接口用于，在大数据量（百万以上）的渲染场景，分片加载数据和增量渲染 。</p>
</blockquote>
<p>echarts 的 option.series 配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">option.series = [</span><br><span class="line">    &#123;<span class="attr">type</span>: <span class="string">'map'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">type</span>: <span class="string">'lines'</span>, <span class="attr">coordinateSystem</span>: <span class="string">'geo'</span>, <span class="attr">polyline</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">type</span>: <span class="string">'lines'</span>, <span class="attr">coordinateSystem</span>: <span class="string">'geo'</span>, <span class="attr">polyline</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    ... <span class="comment">// 一个地图，10个轨迹，共11个&#123;&#125;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>加载数据，并渲染到地图上时，调用 echartsInstance.appendData 方法即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index = 1, 3, 4, 5, ... 9; seriesData 为轨迹数据</span></span><br><span class="line"><span class="keyword">this</span>.chartInstance.appendData(&#123;<span class="attr">seriesIndex</span>: index, <span class="attr">data</span>: seriesData&#125;)</span><br></pre></td></tr></table></figure>
<p>经实践发现，当每次 appendData 时，地图上已有的轨迹都会重绘，视觉上的感受就是整个地图轨迹画面会闪烁一下。</p>
<p>为了每次 appendData 时，不影响地图上已有的轨迹，就需要将每次 appendData 的轨迹单独作为一层来绘制，即设置不同的 zlevel。最终 option.series 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option.series = [</span><br><span class="line">    &#123;type: &apos;map&apos;&#125;,</span><br><span class="line">    &#123;type: &apos;lines&apos;, coordinateSystem: &apos;geo&apos;, polyline: true, zlevel: 2&#125;,</span><br><span class="line">    &#123;type: &apos;lines&apos;, coordinateSystem: &apos;geo&apos;, polyline: true, zlevel: 3&#125;,</span><br><span class="line">    ... // 一个地图，10个轨迹，共11个&#123;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Echarts</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>echarts 地图区域高亮显示</title>
    <url>/blog/2018/10/09/echarts%E5%9C%B0%E5%9B%BE%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<h2 id="echarts地图区域高亮显示"><a href="#echarts地图区域高亮显示" class="headerlink" title="echarts地图区域高亮显示"></a>echarts地图区域高亮显示</h2><p><img src="https://github.com/riversword/images/raw/master/blog/20181009213435.png" alt></p>
<p>现需要实现如图所示的地图填充效果，有何方法呢。</p>
<h4 id="引入-echarts-及中国地图"><a href="#引入-echarts-及中国地图" class="headerlink" title="引入 echarts 及中国地图"></a>引入 echarts 及中国地图</h4><p>首先需要在页面引入 echarts 和 China Map。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/map/js/china'</span></span><br></pre></td></tr></table></figure>
<h4 id="方法1-在-echarts-的-option-中进行配置"><a href="#方法1-在-echarts-的-option-中进行配置" class="headerlink" title="方法1 在 echarts 的 option 中进行配置"></a>方法1 在 echarts 的 option 中进行配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">option: &#123;</span><br><span class="line">    geo: &#123;<span class="attr">map</span>: <span class="string">'china'</span>&#125;，</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'中国'</span>,</span><br><span class="line">            type: <span class="string">'map'</span>,</span><br><span class="line">            mapType: <span class="string">'china'</span>,</span><br><span class="line">            data: [</span><br><span class="line">              &#123;<span class="attr">name</span>: <span class="string">'重庆'</span>, <span class="attr">selected</span>: <span class="literal">true</span>&#125; <span class="comment">// 填充地图上重庆区域</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要动态地高亮显示地图上的区域时，给 option 动态赋值，并调用 echartInstance.setOption(option) 方法即可。此方法会让整个 echarts 实例重绘。</p>
<h4 id="方法2-调用-echarts-实例的内置方法"><a href="#方法2-调用-echarts-实例的内置方法" class="headerlink" title="方法2 调用 echarts 实例的内置方法"></a>方法2 调用 echarts 实例的内置方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.chartInstance.dispatchAction(&#123;</span><br><span class="line">  type: <span class="string">'downplay'</span>, <span class="comment">// 取消高亮指定的数据图形</span></span><br><span class="line">  seriesIndex: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">this</span>.chartInstance.dispatchAction(&#123;</span><br><span class="line">  type: <span class="string">'highlight'</span>, <span class="comment">// 高亮指定的数据图形。通过seriesName或者seriesIndex指定系列。如果要再指定某个数据可以再指定dataIndex或者name。</span></span><br><span class="line">  seriesIndex: <span class="number">0</span>,</span><br><span class="line">  name: <span class="string">'澳门特别行政区'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>本例是让地图中的 “澳门特别行政区” 区域高亮显示。此方法不会影响 echarts 实例上的其他图层。</p>
]]></content>
      <tags>
        <tag>Echarts</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>element.scrollLeft</title>
    <url>/blog/2018/08/07/element.scrollLeft/</url>
    <content><![CDATA[<p>今儿遇到一个需求，需要使用到 scrollLeft，以往很少用到元素的 scrollLeft 属性，对其不甚熟悉，特来记录一下。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018080701.gif" alt></p>
<a id="more"></a>
<p>首先，是要求将一个列表横向展示在容器中，容器的宽度是固定的，而列表数量是不定的，当列表内容宽度超出容器宽度时，让其滚动显示。</p>
<p>这个效果不难实现，html 内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span>华东大区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>杭州公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>宁波公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>南京公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苏州公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无锡公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>徐州公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苏中公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>温州公司<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置 <code>white-space: nowrap;</code> 来阻止元素换行，给容器设置 <code>overflow-x: auto;</code>，让容器中的内容溢出时，滚动显示，css 样式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">210</span>, <span class="number">225</span>, <span class="number">251</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">px2rem</span>(<span class="number">28</span>);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#D2E1FB</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">px2rem</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom-width</span>: <span class="built_in">px2rem</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="attribute">border-bottom-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">linear-gradient</span>( #<span class="number">4</span>BACD0 , #<span class="number">42</span>B2DB) <span class="number">30</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，该项目中使用了 vue，要求当用户点击某个公司时，就将该公司高亮显示，并将点击的公司名称记录到 state 中，下次用户再进入到此页面时，就高亮显示 state 中的公司。例如，用户在此页面点选了 <code>宁波公司</code> ，用户下一次再进入该页面时，就直接高亮显示 <code>宁波公司</code> 。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018080702.gif" alt></p>
<p>但是，当用户滑动至列表的后段，点选了 <code>徐州公司</code>，用户下一次再进入该页面时，<code>徐州公司</code> 虽会高亮显示，但由于列表内容比较长 <code>徐州公司</code> 排在后面，在容器的可视部分，用户并不能看见高亮显示的 <code>徐州公司</code>，需要手动滚动列表至后段，才能看到高亮显示的 <code>徐州公司</code>。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018080703.gif" alt></p>
<p>综合应用场景，还需要让高亮显示的 <code>li</code> 元素滚动至容器的可视区域。这里细分下来，有两个操作：</p>
<ol>
<li>让元素滚动</li>
<li>滚动到指定的位置（容器的可视区域）</li>
</ol>
<p>通过给容器的 scrollLeft 属性赋值，可以让容器中的内容滚动 ；而通过元素的 offsetLeft 属性值，可以知道该元素离父元素左侧的距离。于是得到了我们的解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTabPosition (index) &#123;</span><br><span class="line">  <span class="comment">// index表示高亮li的索引</span></span><br><span class="line">  <span class="keyword">let</span> eleParent = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'content'</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> ele = eleParent.getElementsByTagName(<span class="string">'li'</span>)[index]</span><br><span class="line"></span><br><span class="line">  eleParent.scrollLeft = ele.offsetLeft</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-class</title>
    <url>/blog/2019/04/07/es6-class/</url>
    <content><![CDATA[<h3 id="js-构造函数"><a href="#js-构造函数" class="headerlink" title="js 构造函数"></a>js 构造函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MathHandle</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MathHandle.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MathHandle(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.add()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> MathHandle <span class="comment">// 'function'</span></span><br><span class="line"></span><br><span class="line">MathHandle.prototype.constructor === MathHandle <span class="comment">// true，函数都有一个显式原型（prototype）,构造函数的原型，其构造器指向构造函数本身。</span></span><br><span class="line"></span><br><span class="line">m.__proto__ === MathHandle.prototype <span class="comment">// true， 实例都有一个隐式原型（__proto__），实例的隐式原型等于其构造函数的显式原型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数都有一个显式原型（<code>prototype</code>），构造函数的显示原型，其构造器指向构造函数本身。</p>
<p>实例对象都有一个隐式原型（<code>__proto__</code>），实例的隐式原型等于其构造函数的显式原型。</p>
</blockquote>
<a id="more"></a>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>函数声明会<a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" target="_blank" rel="noopener">提升</a>，类声明不会。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  add () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MathHandle(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.add()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> MathHandle) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(MathHandle.prototype.constructor === MathHandle) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__ === MathHandle.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的原理是通过原型链来实现，当获取对象的某一个属性时，若该对象本身没有这个属性，就会去其原型对象上查找，若原型对象上也没有，就去上一层原型对象上查找，一直查找到原型链的顶端 <code>Object.__prtootype__</code> 。另外，由原型链的规则可知实例对象的原型 <code>obj.__proto__</code> ，是等于其构造函数的原型 <code>Func.prototype</code> 。因此，在构造函数的原型 <code>prototype</code> 中添加一个属性，实例的原型 <code>__proto__</code> 就也有了该属性，从而实现了继承。</p>
<p>将低级函数的原型赋值成高级函数的实例，就实现了低级函数继承高级函数的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Animal eat'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狗</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Dog bark'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定原型实现继承</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> erha = <span class="keyword">new</span> Dog();</span><br><span class="line">erha.bark(); <span class="comment">// 'Dog bark'</span></span><br><span class="line">erha.eat(); <span class="comment">// 'Animal eat'</span></span><br></pre></td></tr></table></figure>
<p>原理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例.__proto__ === 构造函数.prototype</span><br></pre></td></tr></table></figure>
<p>class继承：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 每个class内都必须有一个constructor的函数</span></span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'eat'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="comment">// 若使用了extends继承，在constructor中必须写上super</span></span><br><span class="line">    <span class="keyword">super</span>(name); <span class="comment">// 相当于将name传到Animal的constructor中，super相当于被继承class的constructor</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    say () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'say'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line">dog.say();</span><br><span class="line">dog.eat();</span><br></pre></td></tr></table></figure>
<hr>
<p>【参考】：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/blog/2018/12/23/Git/</url>
    <content><![CDATA[<h2 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h2><p><img src="https://github.com/riversword/images/raw/master/blog/2018122201.png" alt></p>
<p>git版本管理中，有几个基本概念，工作区、暂存区、本地仓库、远程仓库。当从远程仓库clone一个项目到本地后，本地的项目目录中，就包含了工作区、暂存区和本地仓库。项目的实际代码文件，属于工作区，<code>.git</code> 文件夹内是暂存区和本地仓库。</p>
<p>我们用编辑器修改的代码文件，就是工作区的文件；通过 add 可以将工作区的文件，添加到暂存区中；通过 commit 又可以将暂存区中的文件，提交到本地仓库中；最后通过 push 将本地仓库中的文件，推送到远程仓库中。</p>
<a id="more"></a>
<p>一个文件修改、提交到远程仓库的流程是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"这是一段提交描述"</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>修改文件后，如果没有先对其进行 add 操作，那么 commit、push 对它是无效的。为避免提交冲突，通常会在提交前会先 <code>git pull</code> 拉取远程仓的最新状态。</p>
<h2 id="add操作"><a href="#add操作" class="headerlink" title="add操作"></a>add操作</h2><p>将所有改动提交到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>将指定的多个文件或文件夹提交到暂存区，文件（夹）之间用空格隔开。例如，将文件夹 folder1 及文件 test.txt 添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add folder1 test.txt</span><br></pre></td></tr></table></figure>
<p>新建的文件，若未进行 add，编辑器会提示”未跟踪”。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-12-22_204617.png" alt="1545571508639"></p>
<p><code>git rm --cached &lt;file&gt;</code>，停止跟踪文件但不删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-12-23_145810.png" alt="1545571508639"></p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><code>cat &lt;FileName&gt;</code>，查看文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;FileName&gt;</span><br></pre></td></tr></table></figure>
<p>在 add 之前，可以通过 <code>git diff &lt;FileName&gt;</code> 查看工作区文件的改动内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff &lt;FileName&gt;</span><br></pre></td></tr></table></figure>
<p><code>git status</code>，查看各文件的状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   test1.txt</span><br><span class="line">        new file:   test2.txt</span><br></pre></td></tr></table></figure>
<p><code>git log</code>  查看提交（commit）记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 54642892b043166e4838ee576e804244dae9fde1 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: riversword &lt;xxxx@qq.com&gt;</span><br><span class="line">Date:   Sat Dec 22 20:33:35 2018 +0800</span><br><span class="line"></span><br><span class="line">    提交指定文件及文件夹</span><br><span class="line"></span><br><span class="line">commit bab55c2387333a027dd466e3cc11b668e3e8fa10</span><br><span class="line">Author: riversword &lt;xxxx@qq.com&gt;</span><br><span class="line">Date:   Sat Dec 22 20:24:26 2018 +0800</span><br><span class="line"></span><br><span class="line">    测试2</span><br><span class="line"></span><br><span class="line">commit cf69750d3d23aaf69f3b68d8a71b86e6eda993d3</span><br><span class="line">Author: riversword &lt;xxxx@qq.com&gt;</span><br><span class="line">Date:   Sat Dec 22 20:12:19 2018 +0800</span><br><span class="line"></span><br><span class="line">    测试1</span><br></pre></td></tr></table></figure>
<h2 id="撤消回退"><a href="#撤消回退" class="headerlink" title="撤消回退"></a>撤消回退</h2><p><code>git reset HEAD &lt;file&gt;</code>，取消文件的 add。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD test1.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       test1.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   test2.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test1.txt</span><br></pre></td></tr></table></figure>
<p><code>git checkout -- &lt;file&gt;</code>  ，将工作区文件的修改还原，还原到上一次 add 的状态。类似于在编辑器中，返回上一步，直至最近一次的 add。若修改文件后执行了add，再执行 <code>git checkout -- &lt;file&gt;</code> 是没有用的。注意：此命令中有两天横杠，若不加横杠，则是切换分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p><code>git checkout HEAD &lt;file&gt;</code>，若文件修改并且add了，<code>git checkout HEAD &lt;file&gt;</code> 会撤消本次的 add 及文件修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout HEAD test1.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is behind &apos;origin/master&apos; by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p><code>git reset --hard HEAD^</code>  ，将项目回退到上一个版本，即恢复到上一次（倒数第2次） commit 时的状态；回退到上上个版本，用<code>git reset --hard HEAD^^</code> ；回退到上100个版本 <code>git reset --hard HEAD~100</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at bab55c2 测试2</span><br></pre></td></tr></table></figure>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><code>git branch develop master</code> ，新建一个 develop 分支，基于 master 分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch develop master</span><br></pre></td></tr></table></figure>
<p><code>git checkout develop</code>  ，切换到 develop 分支。切换分支的时候，本地项目目录文件也会相应地改变，变为当前分支的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">M       test.txt</span><br><span class="line">D       test1.txt</span><br></pre></td></tr></table></figure>
<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><p><img src="https://github.com/riversword/images/raw/master/blog/2018122301.jpg" alt></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>img vs backgroundImage</title>
    <url>/blog/2018/06/23/FrontEnd-img-vs-backgroundImage/</url>
    <content><![CDATA[<p>html 中的 <code>&lt;img /&gt;</code> 标签和 css 中的 <code>background-image</code> ，都可以在页面上显示出图片。这两种方式显示图片，有何差别呢，该如何选择呢？</p>
<p>说到二者的区别，就要从网页的渲染的流程讲起了，浏览器渲染网页的过程是这样的：<br>1.解析 html，构建出 dom 树；<br>2.解析 css，构建出 cssom 规则树；<br>3.合并 dom 树和 cssom 规则树，生成渲染（render）树；<br>4.遍历渲染树，计算每个节点几何信息；<br>5.屏幕上绘制节点；</p>
<p>用 <code>&lt;img /&gt;</code> 标签设置图片，浏览器会在解析 html 时，加载图片，并且在图片加载完毕之前，<code>&lt;img /&gt;</code> 标签以下的内容不会被解析。</p>
<p>而通过 css 中的 <code>background-image</code> 来设置图片，浏览器先解析 html ，再解析 css，加载图片时不会影响用户浏览器页面内容。</p>
<p><strong>单从页面加载方面来说，用 <code>background-image</code> 来设置图片对用户体验更好，尤其是一些比较大的图片。</strong></p>
<p>而，从 html 语义化来说，<code>&lt;img /&gt;</code> 标签有其明显的优点，<code>&lt;img /&gt;</code> 标签的 <code>alt</code> 属性可以写入提示文字，有利于搜索引擎的爬取，同时可以帮助有视觉障碍的用户阅读网页。</p>
]]></content>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>剩余参数和解构赋值</title>
    <url>/blog/2019/04/13/es6-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E5%92%8C%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h2 id="函数的-Rest-参数（剩余参数）"><a href="#函数的-Rest-参数（剩余参数）" class="headerlink" title="函数的 Rest 参数（剩余参数）"></a>函数的 Rest 参数（剩余参数）</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的剩余参数，<strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) total += x;</span><br><span class="line">    <span class="keyword">if</span> (y) total += y;</span><br><span class="line">    <span class="keyword">if</span> (z) total += z;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"total"</span>, total);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="string">""</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">esSum</span>(<span class="params">...m</span>) </span>&#123; <span class="comment">// 此处的...m表示rest参数，动态参数 不确定参数的个数</span></span><br><span class="line">    <span class="keyword">let</span> es_total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> m)&#123;</span><br><span class="line">        es_total += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"es_total"</span>, es_total);</span><br><span class="line">&#125;</span><br><span class="line">esSum(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> esSum3 = <span class="function">(<span class="params">...m</span>) =&gt;</span> &#123; <span class="comment">// 箭头函数</span></span><br><span class="line">    <span class="keyword">let</span> es_total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> m)&#123;</span><br><span class="line">        es_total += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"es_total"</span>, es_total);</span><br><span class="line">&#125;</span><br><span class="line">esSum3(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象不是真正的数组，不能直接使用数组上的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest是真正的数组</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>剩余参数和 <code>arguments</code>对象之间的区别主要有三个：</p>
<ul>
<li>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</li>
<li><code>arguments</code>对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code>实例，也就是说你能够在它上面直接使用所有的数组方法，比如 <code>sort</code>，<code>map</code>，<code>forEach</code>或<code>pop</code>。</li>
<li><code>arguments</code>对象还有一些附加的属性 （如<code>callee</code>属性）。</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y] = [<span class="number">4</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">4</span>, <span class="number">8</span>]); <span class="comment">// 4 8 数组扩展，...与数组在一起时，会进行运算将数组拆解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2)); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log([...arr1, ...arr2]); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a1, a2, a3] = <span class="string">"es6123"</span>;</span><br><span class="line"><span class="comment">// a1="e"  a2="s"  a3="6"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b1 = [...<span class="string">"es6"</span>];</span><br><span class="line"><span class="comment">// b1=["e", "s", "6"]</span></span><br></pre></td></tr></table></figure>
<hr>
<p>【参考】：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>label 标签</title>
    <url>/blog/2018/10/24/html-label%20%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>label 标签为 input 元素定义标注(标记)，它不会向用户呈现任何特殊样式效果，和 span 标签类似。但 它为鼠标用户改进了可用性，可以关联特定的表单控件。</p>
<p>label 标签和特定表单控件关联之后，如果用户点击 label 元素，就会触发关联的表单控件。也就是说，当用户选择该 label 标签时，浏览器就会自动将焦点转到和 label 标签相关的表单控件上。  </p>
<a id="more"></a>
<p>label 标签与表单元素的关联方式有两种：</p>
<p><strong>显示关联</strong></p>
<blockquote>
<p>显式关联：通过 label 标签的 <strong>for </strong>属性，显式地与同一文档中的一个表单控件关联。for 属性的值即的关联表单元素的 <strong>id</strong>。如：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> <span class="attr">name</span>=<span class="string">'basket'</span> <span class="attr">id</span>=<span class="string">'basketball'</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"basketball"</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> <span class="attr">name</span>=<span class="string">'football'</span> <span class="attr">id</span>=<span class="string">'football'</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"football"</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户点击 label 元素时，相当于点击了关联的 input 元素。</p>
<p><strong>隐式关联</strong></p>
<blockquote>
<p>隐式关联：将表单控件放到 label 标签内，即可与该表单控件关联。这种情况下，label 标签只能包含一个表单元素，包含多个时只对第一个有效。如： </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>点击俺可以使文本框获得焦点</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span>=<span class="string">'theinput'</span> <span class="attr">id</span>=<span class="string">'theinput'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户选择 label 标签时，浏览器会将焦点转到 label 标签内的 input 元素上。 </p>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>var,let,const</title>
    <url>/blog/2019/04/12/es6-var,let,const/</url>
    <content><![CDATA[<h3 id="let-块级作用域"><a href="#let-块级作用域" class="headerlink" title="let 块级作用域"></a>let 块级作用域</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener"><code>let</code></a> 语句声明一个块级作用域的变量。关于块级作用域，可以简单地理解为表达式中 <code>{}</code> 内的部分。</p>
<p><code>let</code> 声明的变量，仅在当前块级作用域内可访问到（其声明的块和子块中），变量只能在声明之后使用。</p>
<p>例 1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a1='</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a2='</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">a1= 1</span></span><br><span class="line"><span class="comment">Uncaught ReferenceError: a is not defined at &lt;anonymous&gt;:5:20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a1='</span>, a);</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">Uncaught ReferenceError: a is not defined at &lt;anonymous&gt;:1:20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>.<a id="more"></a></p>
<h3 id="let-与-var-的差异"><a href="#let-与-var-的差异" class="headerlink" title="let 与 var 的差异"></a>let 与 var 的差异</h3><p><code>var</code> 声明的变量只能是全局或者整个函数块的，并且变量声明总是在代码执行之前处理的，所以在代码中的任意位置声明变量，总是等效于在当前执行上下文的开头声明。这意味着变量可以在声明之前使用，这个行为叫做 “hoisting”（变量提升）。（<code>function</code> 声明函数时，也会提升。）</p>
<p>例 2.1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'b1='</span>, b);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b2='</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b3='</span>, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">b1= undefined</span></span><br><span class="line"><span class="comment">b2= 1</span></span><br><span class="line"><span class="comment">b3= 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上例等效于如下代码：</p>
<p>例 2.2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b1='</span>, b);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b2='</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b3='</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">b1= undefined</span></span><br><span class="line"><span class="comment">b2= 1</span></span><br><span class="line"><span class="comment">b3= 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>.</p>
<p>同一作用域下，<code>var</code> 可以重复声明一个变量，后声明的变量，会覆盖先声明的；而 <code>let</code> 不允许变量重复声明（会报错）；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a='</span>, a);</span><br><span class="line"><span class="comment">// a= 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b='</span>, b);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>.</p>
<p><code>let</code> 并不会像 <code>var</code> 一样在全局对象上创造一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'this.a='</span>, <span class="keyword">this</span>.a); <span class="comment">// this.a= 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'this.b='</span>, <span class="keyword">this</span>.b); <span class="comment">// this.b= undefined</span></span><br></pre></td></tr></table></figure>
<p>.</p>
<h3 id="for-循环中的-var-和-let"><a href="#for-循环中的-var-和-let" class="headerlink" title="for 循环中的 var 和 let"></a>for 循环中的 var 和 let</h3><p><code>for</code> 循环中，<code>var</code> 与 <code>let</code> 的差异：</p>
<p>例 3.1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i='</span>, i);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout i='</span>, i)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">i= 0</span></span><br><span class="line"><span class="comment">i= 1</span></span><br><span class="line"><span class="comment">i= 2</span></span><br><span class="line"><span class="comment">setTimeout i= 3</span></span><br><span class="line"><span class="comment">setTimeout i= 3</span></span><br><span class="line"><span class="comment">setTimeout i= 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上例 3.1 中 <code>var</code> 声明的变量是全局的，等效于如下写法：</p>
<p>例 3.2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i='</span>, i);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout i='</span>, i)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 javascript 异步、单线程的知识可知，首先会在主进程中执行完 <code>for</code> 循环，此时 <code>i=3</code>，再将异步队列中的三个 <code>setTimeout</code> 内部函数体，放到主进程中执行，由于这三个 <code>setTimeout</code> 函数访问的 <code>i</code> 就是全局上的 <code>i</code> ，故都是打印 <code>3</code> 。</p>
<p>.</p>
<blockquote>
<p>而 <code>let</code> 声明的变量 <code>i</code>，<a href="http://es6.ruanyifeng.com/#docs/let#" target="_blank" rel="noopener">当前的 <code>i</code> 只在本轮循环有效，所以每一次循环的 <code>i</code> 其实都是一个新的变量</a></p>
</blockquote>
<p>例 3.3：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i='</span>, i);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout i='</span>, i)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">i= 0</span></span><br><span class="line"><span class="comment">i= 1</span></span><br><span class="line"><span class="comment">i= 2</span></span><br><span class="line"><span class="comment">setTimeout i= 0</span></span><br><span class="line"><span class="comment">setTimeout i= 1</span></span><br><span class="line"><span class="comment">setTimeout i= 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上例写成如下代码，可能更容易理解：</p>
<p>例 3.4：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'j='</span>, j);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout j='</span>, j)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* //以下为打印结果：</span></span><br><span class="line"><span class="comment">j= 0</span></span><br><span class="line"><span class="comment">j= 1</span></span><br><span class="line"><span class="comment">j= 2</span></span><br><span class="line"><span class="comment">setTimeout j= 0</span></span><br><span class="line"><span class="comment">setTimeout j= 1</span></span><br><span class="line"><span class="comment">setTimeout j= 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在每次循环中，都用 <code>let</code> 声明了一个变量 <code>j</code> ，但运行时并没有报错，可见变量 <code>j</code> 并没有重复声明，即，这三次循环都相当于是一个独立的块作用域。</p>
<p>.</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener"><code>const</code></a> 定义一个常量，并且该常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p>.</p>
<p>当 <code>const</code> 定义的是一个引用类型，如对象，它的属性是可以被修改的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jean'</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.name = <span class="string">'Jack'</span>;</span><br><span class="line">obj.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj='</span>, obj); <span class="comment">// &#123;name: "Jack", age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr='</span>, arr); <span class="comment">// arr = [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>var</code> 声明的变量，只能是全局的或者函数块的；<code>var</code> 声明的变量会存在变量提升（hoisting），允许重复声明，后声明的变量会覆盖先声明的变量；</p>
<p><code>let</code> 声明的变量，仅在当前块级作用域中能被访问，只能先声明再使用，不允许重复声明；在全局上声明变量时，<code>let</code> 不会像 <code>var</code> 一样在全局对象上创造一个属性：</p>
<p>注意 <code>for</code> 循环中， <code>var</code> 与 <code>let</code> 初始化变量的差异，<code>let</code> 初始化的变量 <code>i</code>，可理解为，每次循环中 <code>i</code> 都是一个新的变量。</p>
<p><code>const</code> 声明一个常量，其作用域与 <code>let</code> 声明的变量一样，是块级作用域，<code>const</code> 声明的常量，不允许被重新赋值，若声明的是引用类型，可以修改其属性或子项。</p>
<hr>
<p>【参考】：</p>
<p><a href="https://segmentfault.com/q/1010000007541743" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007541743</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/let#" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let#</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>arguments对象与arguments.callee</title>
    <url>/blog/2018/10/16/js-arguments%20%E4%B8%8E%20arguments.callee/</url>
    <content><![CDATA[<h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments  对象"></a>arguments  对象</h3><p>arguments 保存着函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        sum = sum + <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h3><p>arguments 对象上有一个名为 callee 的属性，其属性值为正在被执行的函数。先看一个例子，就知道 arguments.callee 的应用场景了。</p>
<p>现需用递归求1到n的和：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归求和</span></span><br><span class="line"><span class="comment">// 求1~100的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n + sum(n<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>增加难度，用匿名函数递归求1到n的和：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数 递归求和</span></span><br><span class="line"><span class="comment">// 求1~100的和</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) (<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX请求（一）</title>
    <url>/blog/2017/10/02/js-AJAX%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>AJAX = Asynchronous JavaScript and XML（异步的JavaScript和XML）。</p>
</blockquote>
<p>发送 ajax 的步骤：</p>
<ul>
<li>创建请求对象；</li>
<li>指定状态改变时的处理函数；（响应处理函数）</li>
<li>发送请求；</li>
</ul>
<a id="more"></a>
<h4 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// IE7+,Firefox,Chrome，Opera，Safari浏览器执行代码</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//IE6,IE5浏览器执行代码</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送XMLHttpRequest请求"><a href="#发送XMLHttpRequest请求" class="headerlink" title="发送XMLHttpRequest请求"></a>发送XMLHttpRequest请求</h4><p>如需将请求发送到服务器，使用XMLHttpRequest对象的open()和send()方法；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajax_info.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">open(method,url,async)</td>
<td style="text-align:left">规定请求的类型、URL以及是否异步处理请求。<br>- method：请求的类型，GET或POST<br>-url：文件在服务器上的位置<br>-async：true（异步）或false（同步）</td>
</tr>
<tr>
<td style="text-align:left">send(string)</td>
<td style="text-align:left">将请求发送到服务器<br>-string：仅用于POST请求</td>
</tr>
</tbody>
</table>
<h5 id="GET还是POST？"><a href="#GET还是POST？" class="headerlink" title="GET还是POST？"></a>GET还是POST？</h5><p>与POST相比，GET更简单也更快，并且在大部分情况下都能使用。</p>
<p>然而，在以下情况中，请使用POST请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST比GET更稳定也更可靠</li>
</ul>
<h6 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h6><p>一个简单的GET请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/demo_get.php"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你可能得到的是缓存的结果。</p>
<p>为了避免这种情况，请向URL添加一个唯一的ID：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/demo_get.php?t="</span> + <span class="built_in">Math</span>.random(),<span class="string">"true"</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>如果你希望通过GET方法发送信息，请向URL添加信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<h6 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h6><p>一个简单的POST请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"/try/ajax/demo_post.php"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>如果需要像HTML表单那样POST数据，请使用<code>setRequestHeader()</code>来添加HTTP头。然后在<code>send()</code>方法中规定你希望发送的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">""</span>,<span class="literal">true</span>);</span><br><span class="line">serRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xmlhttp.send(<span class="string">"fname=Henry&amp;name=Ford"</span>);</span><br></pre></td></tr></table></figure>
<h5 id="异步-true或false"><a href="#异步-true或false" class="headerlink" title="异步-true或false"></a>异步-true或false</h5><p>AJAX指的是异步JavaScript和XML（Asynchronous JavaScript and XML）。</p>
<p>XMLHttpRequest对象如果要用于AJAX的话，其open()方法async参数必须设置为true。</p>
<p>很多在服务器执行的任务都相当费时。AJAX出现之前，这可能会引起应用程序挂起或停止。</p>
<p>通过AJAX，JavaScript无需等待服务器的响应，而是：在等待服务器响应时执行其他脚本，当响应就绪后对响应进行处理。</p>
<h6 id="async-true"><a href="#async-true" class="headerlink" title="async = true"></a>async = true</h6><p>当使用<code>async = true</code>时，请规定在响应处于<code>onreadystatechange</code>事件中的就绪状态时执行的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState == <span class="number">4</span> &amp;&amp; xmlhttp.status == <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/ajax_info.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttpsend();</span><br></pre></td></tr></table></figure>
<h6 id="async-false"><a href="#async-false" class="headerlink" title="async = false"></a>async = false</h6><p>如需使用<code>async = false</code>，请将<code>open()</code>方法中的第三个参数改为<code>false</code>：</p>
<p>不推荐使用 <code>async = fasle</code> ，但是对于一些小型的请求，也是可以的。</p>
<p>JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p>
<p>注意：使用<code>async = false</code> 时，请不要编写<code>onreadystatechange</code> 函数，把处理响应的代码放到 <code>send()</code> 语句后面即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/ajax_info.txt"</span>,<span class="literal">false</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = xmlhttp.responseText;</span><br></pre></td></tr></table></figure>
<h4 id="AJAX响应"><a href="#AJAX响应" class="headerlink" title="AJAX响应"></a>AJAX响应</h4><p>如需获得来自服务器的响应，使用<code>XMLHttpRequest</code>对象的<code>responseText</code> 或  <code>responseXML</code> 属性。</p>
<p><code>responseText</code>  获得字符串形式的响应数据。<code>responseXML</code> 获得XML形式的响应数据，还需要作为XML对象进行解析。</p>
<h4 id="onreadystatechange事件"><a href="#onreadystatechange事件" class="headerlink" title="onreadystatechange事件"></a>onreadystatechange事件</h4><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p>
<p>每当 <code>readyState</code> 改变时，就会触发 <code>onreadystatechange</code> 事件。<code>readyState</code> 属性存有XMLHttpRequest的状态信息。</p>
<p>以下时XMLHttpRequest对象的三个重要属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onreadystatechange</td>
<td>存储函数（或函数名），每当<code>readyState</code>属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td>readyState</td>
<td>存有XMLHttpRequest的状态。从0到4发生变化。<br>- 0：请求未初始化<br>- 1：服务器连接已建立<br>- 2：请求已接收<br>- 3：请求处理中<br>- 4：请求已完成，且响应已就绪</td>
</tr>
<tr>
<td>status</td>
<td>200：”OK”<br>404：未找到页面</td>
</tr>
</tbody>
</table>
<h4 id="AJAX实例"><a href="#AJAX实例" class="headerlink" title="AJAX实例"></a>AJAX实例</h4><p>创建请求对象，指定状态改变时的处理函数，发送请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">window</span>.XMLHttpRequest )</span><br><span class="line">&#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlhttp.readyState == <span class="number">4</span> &amp;&amp; xmlhttp.status == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,url,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的词法分析与执行</title>
    <url>/blog/2018/10/14/js-JavaScript%20%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>变量的作用域：函数中的某个变量，执行函数时首先在该函数内查找该变量，如果该函数内没有该变量，则向外层父函数查找，一直向外层查找到window全局环境上，此即<strong>作用域链</strong>。</p>
<h3 id="JavaScript-的词法分析与执行"><a href="#JavaScript-的词法分析与执行" class="headerlink" title="JavaScript 的词法分析与执行"></a>JavaScript 的词法分析与执行</h3><p>JavaScript 代码的运行过程，实质上分为两个阶段——<strong>词法分析和执行</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name='</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'Jean'</span>);</span><br></pre></td></tr></table></figure>
<p>词法分析的步骤：</p>
<blockquote>
<p>1.分析形参</p>
<p>2.分析变量的声明</p>
<p>3.分析函数的声明</p>
</blockquote>
<p>词法分析的具体过程：</p>
<ol start="0">
<li><p>函数运行瞬间，该函数首先会生成一个活动对象（Active Objective），这里简称 AO 对象，其值为一个空对象 ｛｝。（一个函数作用域内能找到的变量，都在 AO上。）</p>
<blockquote>
<p>分析结果：test.AO = {};</p>
</blockquote>
</li>
</ol>
<ol>
<li><p>接收参数，以参数名为属性名，以参数值为属性值</p>
<blockquote>
<p>分析结果：test.AO = {name: ‘jean’};</p>
</blockquote>
</li>
<li><p>分析 var 声明，在AO上形成一个属性，以var声明的变量名为属性名，以 undefined 为属性值（注意：在执行阶段时，才为该属性名再进行赋值，赋值为变量的值），如果AO对象上已有同名属性，则不做任何影响（在执行阶段时，为该属性名进行赋值，赋值为变量的值）；若没有 var 声明，没有则略过。</p>
</li>
<li><p>分析函数声明，如果 AO 上有与函数名同名的属性，则该属性会被此函数覆盖；没有函数声明则略过。</p>
</li>
</ol>
<a id="more"></a>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Jean'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">test1(<span class="string">'River'</span>);</span><br></pre></td></tr></table></figure>
<p>运行过程：</p>
<ul>
<li><p>词法分析阶段</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>test1.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数：</p>
<blockquote>
<p>test1.AO = {name: ‘River’}</p>
</blockquote>
</li>
<li><p>分析 var 声明：</p>
<blockquote>
<p>AO 上已有name属性，则不做任何影响。</p>
<p>test1.AO = {name: ‘River’}</p>
</blockquote>
</li>
<li><p>分析函数声明：</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
</ol>
</li>
<li><p>执行阶段</p>
<p><code>var name = &#39;Jean&#39;;</code>  赋值 test1.AO.name = ‘Jean’；</p>
<p><code>console.log(name);</code> 打印出 ‘Jean’。</p>
</li>
</ul>
<p>例2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test2(<span class="string">'River'</span>);</span><br></pre></td></tr></table></figure>
<p>运行过程：</p>
<ul>
<li><p>词法分析阶段</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>test2.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数：</p>
<blockquote>
<p>test2.AO = </p>
</blockquote>
</li>
<li><p>分析 var 声明：</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
<li><p>分析函数声明：</p>
<blockquote>
<p>test2.AO = {name: function () { alert(‘hello’); }} </p>
</blockquote>
</li>
</ol>
</li>
<li><p>执行阶段</p>
<p><code>console.log(name);</code> 打印出 function () { alert(‘hello’); }</p>
</li>
</ul>
<p>例3</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name1='</span> + name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name2='</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">test3(<span class="string">'River'</span>);</span><br></pre></td></tr></table></figure>
<p>运行过程：</p>
<ul>
<li><p>词法分析阶段：</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>test3.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数：</p>
<blockquote>
<p>test3.AO = {name: ‘River’}</p>
</blockquote>
</li>
<li><p>分析 var 声明：</p>
<blockquote>
<p>AO对象上已有name属性，不做任何影响</p>
</blockquote>
</li>
<li><p>分析函数声明：</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
</ol>
</li>
<li><p>执行阶段：</p>
<p><code>console.log(&#39;name1=&#39; + name);</code> 打印出 ‘name1=River’。</p>
<p>赋值 test3.AO.name = function () { alert(‘hello’); }。</p>
<p><code>console.log(&#39;name2=&#39; + name);</code> 打印出 ‘name2=function () { alert(‘hello’); }’。</p>
</li>
</ul>
<p>例4：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name1='</span> + name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name2='</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">test4(<span class="string">'River'</span>);</span><br></pre></td></tr></table></figure>
<p>运行过程：</p>
<ul>
<li><p>词法分析阶段：</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>test4.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数：</p>
<blockquote>
<p>test4.AO = {name: ‘River’}</p>
</blockquote>
</li>
<li><p>分析 var 声明：</p>
<blockquote>
<p>AO对象上已有name属性，不做任何影响</p>
</blockquote>
</li>
<li><p>分析函数声明：</p>
<blockquote>
<p>test4.AO.name =  {name: function () { alert(‘world’); }}</p>
</blockquote>
</li>
</ol>
</li>
<li><p>执行阶段：</p>
<p><code>console.log(&#39;name1=&#39; + name);</code> 打印出 ‘name1=River’。</p>
<p><code>var name = function () { alert(&#39;hello&#39;); }</code>  赋值 test4.AO.name = function () { alert(‘hello’); } ；</p>
<p><code>console.log(&#39;name2=&#39; + name);</code> 打印出 ‘name2=function () { alert(‘hello’); } ‘。</p>
</li>
</ul>
<p>例5：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test5</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    name();</span><br><span class="line">&#125;</span><br><span class="line">test5(<span class="string">'River'</span>);</span><br></pre></td></tr></table></figure>
<p>运行过程：</p>
<ul>
<li><p>test5 词法分析阶段：</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>test5.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数：</p>
<blockquote>
<p>test5.AO = {name: ‘River’}</p>
</blockquote>
</li>
<li><p>分析 var 声明：</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
<li><p>分析函数声明：</p>
<blockquote>
<p>test5.AO= {name: function () { alert(name); }} </p>
</blockquote>
</li>
</ol>
</li>
<li><p>test5 执行阶段：</p>
<p><code>console.log(name);</code>   打印 function () { alert(name); }</p>
<p><code>name();</code></p>
<ul>
<li><p>name() 词法分析阶段</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>name.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数：</p>
<blockquote>
<p>没有参数，略过</p>
</blockquote>
</li>
<li><p>分析 var 声明：</p>
<blockquote>
<p>没有，略过</p>
</blockquote>
</li>
<li><p>分析函数声明：</p>
<blockquote>
<p>没有略过</p>
</blockquote>
</li>
</ol>
</li>
<li><p>name() 执行阶段</p>
<p><code>alert(name);</code>  name函数内没有name变量（函数name.AO = {}），去外层test5.AO上找，由于 test5.AO= {name: function () { alert(name); }} ，故弹窗显示 ‘function () { alert(name); }’</p>
</li>
</ul>
</li>
</ul>
<p>综上执行结果为：</p>
<blockquote>
<p>打印 ‘function () { alert(name); }’</p>
<p>故弹窗显示 ‘function () { alert(name); }’</p>
</blockquote>
<p>例6：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test6</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="keyword">var</span> name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    name();</span><br><span class="line">&#125;</span><br><span class="line">test6(<span class="string">'River'</span>);</span><br></pre></td></tr></table></figure>
<p>运行过程：</p>
<ul>
<li><p>test6 词法分析阶段：</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>test6.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数</p>
<blockquote>
<p>test6.AO = {name: ‘River’}</p>
</blockquote>
</li>
<li><p>分析var声明</p>
<blockquote>
<p>AO对象上已有name属性，不做任何影响</p>
</blockquote>
</li>
<li><p>分析函数声明</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
</ol>
</li>
<li><p>test6 执行阶段：</p>
<p><code>console.log(name);</code> 打印出 ‘River’</p>
<p><code>var name = function () { alert(name); }</code> 赋值test6.AO = { name: function () { alert(name); } }</p>
<p><code>name();</code></p>
<ul>
<li><p>name() 词法分析阶段：</p>
<ol start="0">
<li><p>生成 AO 对象：</p>
<blockquote>
<p>name.AO = {}</p>
</blockquote>
</li>
<li><p>分析参数</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
<li><p>分析var声明</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
<li><p>分析函数声明</p>
<blockquote>
<p>略过</p>
</blockquote>
</li>
</ol>
</li>
<li><p>name() 执行阶段：</p>
<p><code>alert(name);</code>  函数name.AO = {}，去外层test6.AO上找name属性，由于test6.AO = { name: function () { alert(name); } }，故弹框显示 ‘ function () { alert(name); }’</p>
</li>
</ul>
</li>
</ul>
<p>综上执行结果为：</p>
<blockquote>
<p>打印出 ‘River’</p>
<p>故弹窗显示 ‘function () { alert(name); }’</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript的类</title>
    <url>/blog/2019/01/03/js-javascript%E7%9A%84%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="类的由来"><a href="#类的由来" class="headerlink" title="类的由来"></a>类的由来</h3><p>在以往 javascript 中，生成一个实例对象，通常是用构造函数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span> (<span class="params">height, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.calArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Rectangle(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>ES6 中引入了 Class（类）这个概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类（声明类）。用 ES6 的 <code>class</code> 改写上面的例子：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  calArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码定义了一个名为Rectangle的“类”，里面的constructor方法，就是构造方法，<code>this</code>关键字代表实例对象。也就是说，ES6中Rectangle类的构造方法<code>constructor</code>，对应于ES5中的构造函数<code>Rectangle</code>，</p>
<p><code>Rectangle</code>类除了构造方法，还定义了一个<code>calArea</code>方法。注意，定义“类”的方法的时候，前面不需要加<code>function</code>关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 </p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>类实际上是个“特殊的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions" target="_blank" rel="noopener">函数</a>”，就像你能够定义的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">函数表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function" target="_blank" rel="noopener">函数声明</a>一样，类语法有两个组成部分：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/class" target="_blank" rel="noopener">类表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="noopener">类声明</a>。 </p>
<p>定义一个类的一种方法是使用一个<strong>类声明</strong>。要声明一个类，你可以使用<code>class</code>关键字，后面跟一个类名（这里是“Rectangle”）。 与函数声明不同的是，类声明不会提升。需要先声明类，再访问它，否则会报出语法错误。类声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类表达式</strong>是定义类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匿名类 */</span> </span><br><span class="line"><span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命名的类 */</span> </span><br><span class="line"><span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个类的类体是一对花括号/大括号 <code>{}</code> 中的部分。这是你定义类成员的位置，如方法或构造函数。 类声明和类表达式的主体都执行在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>下。 </p>
<p>一个类只能拥有一个名为 “constructor”的方法。如果类包含多个<code>constructor</code>的方法，则将抛出 一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 。 </p>
<h3 id="使用extends创建子类"><a href="#使用extends创建子类" class="headerlink" title="使用extends创建子类"></a>使用extends创建子类</h3><p><code>extends</code> 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。 如创建一个名为Dog的类，作为类Animal的一个子类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' barks.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">'Mitzie'</span>);</span><br><span class="line"><span class="comment">// 'Mitzie barks.'</span></span><br><span class="line">d.speak();</span><br></pre></td></tr></table></figure>
<p>如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 这里的<code>super</code>关键字，是当作函数使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>this</title>
    <url>/blog/2018/06/19/js-this/</url>
    <content><![CDATA[<p><code>this</code> 在面向对象编程中十分常见，但若对 this 的概念未完全掌握，又怎敢说自己会面向对象编程呢。</p>
<p><code>JavaScript</code> 中的 <code>this</code> 与 <code>Java</code> 中的 <code>this</code> 有所不同，<code>Java</code> 中的 <code>this</code> 依赖于函数的声明，而在 <code>JavaScript</code> 中 <code>this</code> 则依赖于函数的执行，因此 <code>JavaScript</code>中的 <code>this</code> 常被称为调用上下文。</p>
<a id="more"></a>
<p>请看下面代码，问函数里面的 <code>this</code>等于什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jikezhuan</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我不知道这里的 <code>this</code> 等于什么，但它现在不等于 <code>window</code> ，因为它可能等于包括 <code>window</code> 在内的许多值。如开头所述，<strong>this 依赖于函数的执行，</strong>目前函数并未执行 <code>this</code> 是不可知的。</p>
<p>那么，接下来看看它有哪几种执行方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为函数进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jikezhuan</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line">jikezhuan();</span><br><span class="line"></span><br><span class="line">jikezhuan1 = jikezhuan;</span><br><span class="line">jikezhuan1();</span><br></pre></td></tr></table></figure>
<p>是的，如愿以偿，这两个都是输出 <code>Window</code> 对象。因为这两函数在执行时，其上下文是全局。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为方法进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jike = &#123;<span class="attr">name</span>: <span class="string">"jikezhuan"</span>&#125;;</span><br><span class="line"></span><br><span class="line">jike.skill = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jike.skill(); <span class="comment">//jikezhuan</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>jike</code> 对象的 <code>skill</code> 属性来调用函数，此时是作为 <code>jike</code> 的一个方法来调用的，该函数的上下文是 <code>jike</code> 即 <code>this</code> 指向 <code>jike</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为构造器进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.skill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span> &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jike1 = <span class="keyword">new</span> Jike();</span><br><span class="line"><span class="keyword">var</span> jike2 = <span class="keyword">new</span> Jike();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jike1.skill() === jike1) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"this指向jike1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jike2.skill() === jike2) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"this指向jike2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上代码，在控制台会输出 <code>this指向jike1</code>  ， <code>this指向jike2</code> 。 构造器 <code>Jike</code> 在函数的上下文对象上创建了一个 <code>skill</code>属性，该属性方法又返回了上下文自身。 在使用 <code>new</code> 关键字进行调用时，会创建一个空对象实例，并把该对象作为 <code>this</code> 参数传递给 <code>new</code> 后面的函数—— <code>jike2</code> 。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>apply, call, bind</title>
    <url>/blog/2018/06/20/js-this,call,apply,bind/</url>
    <content><![CDATA[<h2 id="this-与-apply-，call"><a href="#this-与-apply-，call" class="headerlink" title="this 与 apply() ，call()"></a>this 与 apply() ，call()</h2><p>​    函数调用方式之间的主要差异是：作为 this 参数传递给执行函数的上下文对象之间的区别。作为方法进行调用，上下文是该方法的拥有者；作为全局函数进行调用，其上下文是 window（也即该函数是 window 的一个方法）；作为构造函数进行调用，其上下文对象是新创建的对象实例。当一个事件处理程序被调用时，该函数的上下文将被设置为绑定事件的对象。</p>
<p>​    有时会出现这样的需求，需要自由地指定函数的上下文，而 apply() 、call() 方法就能实现这样的功能。Javascript 的每个函数都有 apply() 和 call() 方法。</p>
<p>​    apply() 方法接收两个参数，一个是作为函数上下文的对象，另一个是作为函数参数所组成的数组。call() 方法使用方式的不同点在于。给函数传入的参数是一个参数列表，而不是单个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123; <span class="comment">// arguments参数数组</span></span><br><span class="line">        result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.result = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个测试对象</span></span><br><span class="line"><span class="keyword">var</span> test1 = &#123;&#125;,</span><br><span class="line">    test2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用apply()、call()方法调用函数</span></span><br><span class="line">sum.apply(test1, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">sum.call(test2, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test1.result"</span>, test1.result); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test2.result"</span>, test2.result); <span class="comment">//18</span></span><br></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p><code>bind()</code>方法会返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。语法如下，第一个参数作为函数上下文的对象，以及若干个传入函数的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unboundGetX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(unboundGetX()); <span class="comment">// undefined，作为函数被执行，其上下文是window对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetX = unboundGetX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundGetX()); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p><code>bind</code> 会返回对应函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用 。</p>
<h2 id="多次绑定this"><a href="#多次绑定this" class="headerlink" title="多次绑定this"></a>多次绑定this</h2><p>如果对一个函数进行多次 <code>bind</code>，那么上下文永远由第一次 <code>bind</code> 决定。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure>
<p>上例等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>call</code> 、<code>apply</code> 、<code>bind</code> 进行 this 绑定时， <code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</p>
</blockquote>
<h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br></pre></td></tr></table></figure>
<p>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code> 这类函数是无效的。</p>
<hr>
<p>【参考】：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>
<p><a href="https://www.cnblogs.com/libin-1/p/6069031.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/6069031.html</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>web storage</title>
    <url>/blog/2018/06/17/js-web-storage/</url>
    <content><![CDATA[<p>cookie，通常用于记住用户登录信息，如：登录一个网站时记住密码的功能，就是通过cookie实现。cookie 的大小限制在 4k 以内，在客户端与服务器进行通信时，cookie 会被携带在 http 请求头中。cookie 中存放的字段有，过期时间、域名、路径等。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/14700637-4d5ec8dad4742abe.png" alt></p>
<a id="more"></a>
<p>通过给 cookie 中的字段加上 HttpOnly 标识，可以禁止客户端通过 js 读写该字段。</p>
<p>子级域名可以获取到自身的 cookie 和顶级域名中的 cookie，不能访问其他子域名的 cookie。顶级域名不能获取子域名的 cookie。</p>
<p>如果 cookie 设定了超时时间，那么 cookie 将在到期的时候失效。若未设定，那么 cookie 就是会话（session）级别的。会话（session）级别的 cookie ，在标签页关闭或刷新时，cookie 仍存在，多个标签页的 cookie 属于同一个会话（session），浏览器退出时才会清空 cookie。</p>
<p>sessionStorage 和 localStorage 是 HTML5 新增的。它们的大小一般限制在 5M 以内，会因浏览器不同而有所差别。</p>
<p>sessionStorage 不同于 cookie，它的访问限制更高一些，只有当前设定 sessionStorage 的域才能访问它。刷新页面时，sessionStorage 仍存在，在关闭页面时 sessionStorage  会被清空。</p>
<p>localStorage 没有过期时间，若不被用户清理，会永久存在。只有当前设定 localStorage  的域才能访问它，与 sessionStorage  不同的是，localStorage 设定后，新开 tab 也是可以访问到的。</p>
<p>cookie、sessionStorage 、localStorage 都是存字符串类型的数据。</p>
<p>.</p>
<hr>
<p>【参考】：</p>
<p>【1】<a href="http://caibaojian.com/localstorage-sessionstorage.html" target="_blank" rel="noopener">http://caibaojian.com/localstorage-sessionstorage.html</a><br>【2】<a href="https://juejin.im/entry/578444c979bc440050a89fab" target="_blank" rel="noopener">https://juejin.im/entry/578444c979bc440050a89fab</a><br>【3】<a href="http://www.cnblogs.com/polk6/p/5512979.html" target="_blank" rel="noopener">http://www.cnblogs.com/polk6/p/5512979.html</a><br>【4】域名之间的cookie：<a href="https://segmentfault.com/a/1190000006932934" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006932934</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件的捕获与冒泡</title>
    <url>/blog/2018/10/10/js-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h4 id="事件的捕获与冒泡"><a href="#事件的捕获与冒泡" class="headerlink" title="事件的捕获与冒泡"></a>事件的捕获与冒泡</h4><p><img src="https://github.com/riversword/images/raw/master/blog/2018-10-10_203634.png" alt></p>
<p>捕获：事件的传播顺序，从最外层容器传至内层触发事件的目标。</p>
<p>DOM 事件捕获具体流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window ——&gt; document ——&gt; html ——&gt; body ——&gt; 父级元素 ——&gt; 目标元素</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>document.documentElement</code> api 可以获取到 <code>html</code> 标签元素；</p>
</blockquote>
<p>冒泡：事件的传播顺序，从触发事件的目标传到最外层容器。与捕获流程刚好相反。</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"china"</span>&gt;</span></span><br><span class="line">            中国</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"guangdong"</span>&gt;</span></span><br><span class="line">                广东</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"shenzhen"</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        china = <span class="built_in">document</span>.getElementById(<span class="string">'china'</span>)</span></span><br><span class="line"><span class="javascript">        guangdong = <span class="built_in">document</span>.getElementById(<span class="string">'guangdong'</span>)</span></span><br><span class="line"><span class="javascript">        shenzhen = <span class="built_in">document</span>.getElementById(<span class="string">'shenzhen'</span>)</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        china.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'捕获 click china'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">        guangdong.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'捕获 click guangdong'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">        shenzhen.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'捕获 click shenzhen'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        china.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'冒泡 click china'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        guangdong.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'冒泡 click guangdong'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        shenzhen.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'冒泡 click shenzhen'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>)</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>element.addEventListener(type, function, bolean)，事件监听 addEventListener，中有 3 个参数，分别表示事件类型、调用的方法、是否捕获（默认false即冒泡）。</p>
<p>当点击“深圳”时，会依次显示弹框： ‘捕获 click china’ ——&gt; ‘捕获 click guangdong’ ——&gt; ‘捕获 click shenzhen’ ——&gt; ‘冒泡click shenzhen’ ——&gt; ‘冒泡click guangdong’ ——&gt; ‘冒泡click china’。</p>
<p>这就是事件捕获与冒泡的传播顺序。</p>
<h4 id="阻止事件传播与阻止事件发生"><a href="#阻止事件传播与阻止事件发生" class="headerlink" title="阻止事件传播与阻止事件发生"></a>阻止事件传播与阻止事件发生</h4><p><code>event.stopPropagation()</code> 会阻止捕获和冒泡阶段中当前事件的进一步传播。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"china"</span>&gt;</span></span><br><span class="line">            中国</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"guangdong"</span>&gt;</span></span><br><span class="line">                广东</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"shenzhen"</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        china = <span class="built_in">document</span>.getElementById(<span class="string">'china'</span>)</span></span><br><span class="line"><span class="javascript">        guangdong = <span class="built_in">document</span>.getElementById(<span class="string">'guangdong'</span>)</span></span><br><span class="line"><span class="javascript">        shenzhen = <span class="built_in">document</span>.getElementById(<span class="string">'shenzhen'</span>)</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        china.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'捕获 click china'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">        guangdong.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'捕获 click guangdong'</span>)</span></span><br><span class="line">            event.stopPropagation()</span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">        shenzhen.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'捕获 click shenzhen'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        china.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'冒泡 click china'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        guangdong.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'冒泡 click guangdong'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">        shenzhen.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'冒泡 click shenzhen'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>)</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>event.stopPropagation()</code> 会阻止事件的继续传播</strong>。当点击“深圳”时，会依次显示弹框： ‘捕获 click china’ ——&gt; ‘捕获 click guangdong’ ，就结束了，这是因为在 guangdong 的捕获阶段中调用了 event.stopPropagation() 方法，阻止了事件的传播，后续的捕获及冒泡都不会发生。</p>
<p>通过 <code>return false</code> 来阻止事件的传播呢？</p>
<p>在事件的回调函数中，用原生 JS 写 <code>return false</code> ，仅能阻止默认行为，并不能阻止事件的传播；</p>
<h4 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h4><p><code>event.preventDefault()</code> 阻止默认事件，如 <code>a</code> 标签的点击跳转；</p>
<p><code>event.stopPropagation()</code> 阻止冒泡</p>
<p><code>event.stopImmediatePropagation()</code> ，在一个元素的事件上绑定多个处理函数时，可以在其中一个回调函数中使用此方法，来阻止其他回调函数的执行；</p>
<p><code>event.currentTartget</code>，当前绑定事件的元素，如事件委托时，绑定事件的父元素。</p>
<p><code>event.target</code>，表示被点击的元素。</p>
<p>自定义事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'eventName'</span>); <span class="comment">// 声明一个自定义事件</span></span><br><span class="line">element.addEventListener(<span class="string">'eventName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'eventName'</span>)</span><br><span class="line">&#125;); <span class="comment">// 给事件绑定处理函数</span></span><br><span class="line"></span><br><span class="line">element.dispatchEvent(myEvent); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>
<p>另外还可以用 <code>CustomEvent</code> 做自定义事件，<code>CustomEvent</code> 可以给事件加数据（参数）。</p>
<hr>
<p>【参考】：</p>
<p><a href="https://segmentfault.com/a/1190000005349550" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005349550</a></p>
<p><a href="https://stackoverflow.com/questions/6348494/addeventlistener-vs-onclick" target="_blank" rel="noopener">https://stackoverflow.com/questions/6348494/addeventlistener-vs-onclick</a></p>
<p><a href="http://caibaojian.com/javascript-stoppropagation-preventdefault.html" target="_blank" rel="noopener">http://caibaojian.com/javascript-stoppropagation-preventdefault.html</a></p>
<p><a href="https://blog.csdn.net/senmage/article/details/78001962" target="_blank" rel="noopener">https://blog.csdn.net/senmage/article/details/78001962</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件绑定</title>
    <url>/blog/2018/10/07/js-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="DOM-0-级事件："><a href="#DOM-0-级事件：" class="headerlink" title="DOM 0 级事件："></a>DOM 0 级事件：</h3><p>DOM 0 级事件，形如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> <span class="attr">onclick</span>=<span class="string">"clickBtn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">clickBtn</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">'点击按钮'</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如下有两个按钮，分别用不同的方式进行事件绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> <span class="attr">onclick</span>=<span class="string">"clickOne"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">clickOne</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮1'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn2 = documentsByTagName(<span class="string">'input'</span>)[<span class="number">1</span>]</span></span><br><span class="line"><span class="javascript">    btn2.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮2-a'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    btn2.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮2-b'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当鼠标点击 “按钮2” 时，会显示弹窗 ‘点击按钮2-b’，btn2 后赋值的 onclick 属性覆盖了前面的 onclick 属性值。（在 DOM０级事件处理中，后定义的事件处理会覆盖前面的。 ）</p>
<a id="more"></a>
<blockquote>
<p> DOM 1 标准制定时，内容未涉及事件相关的内容。</p>
</blockquote>
<h3 id="DOM-2-级事件"><a href="#DOM-2-级事件" class="headerlink" title="DOM 2 级事件"></a>DOM 2 级事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h4 id="事件绑定："><a href="#事件绑定：" class="headerlink" title="事件绑定："></a>事件绑定：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">clickMe</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = documentsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, clickMe, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// btn.addEventListener() 传入3个参数： 事件类型，绑定的方法，是否捕获（默认false冒泡）</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮test2'</span>)</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>DOM 2 级事件允许对同一个 dom 对象绑定多个方法，当鼠标点击时，会依次按顺序执行。比如这里的，当鼠标点击 “按钮” 时，会依次显示弹窗 ‘点击按钮’、’点击按钮test2’。</p>
<h4 id="事件移除："><a href="#事件移除：" class="headerlink" title="事件移除："></a>事件移除：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">clickMe</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = documentsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, clickMe, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// btn.addEventListener() 传入3个参数： 事件类型，绑定的方法，是否捕获（默认false冒泡）</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'点击按钮test2'</span>)</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    btn.remove(<span class="string">'click'</span>, clickMe) <span class="comment">// 移除 btn 上绑定的clickMe方法</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>btn.remove(&#39;click&#39;, clickMe)</code>  移除 btn 上绑定的 clickMe 方法</p>
<h3 id="DOM-3-级事件"><a href="#DOM-3-级事件" class="headerlink" title="DOM 3 级事件"></a>DOM 3 级事件</h3><p>DOM 3 标准增加了事件类型，如鼠标事件、键盘事件等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>当需要对多个元素添加事件时，通过将事件添加至给它们的父节点上，来触发处理函数，这种方式叫做 javascript 的事件代理或委托。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对li元素进行事件监听</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line"><span class="keyword">var</span> lis = ul.getElementsByTagName(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].onclick = <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当ul中的子元素li较多时，或者子元素li被频繁地添加、删除时，像这样对每个li元素添加事件处理函数，过于复杂。</p>
<p>而更好的方法就是事件代理，当事件被抛到外层父节点时，会触发处理函数，通过事件的目标对象(target)又可以获取到事件源li，从而实现指定li节点进行特定的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件代理，监听父元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 检查事件源e.target</span></span><br><span class="line">  <span class="keyword">if</span>(e.target &amp;&amp; e.target.innerHtml == <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1 was clicked!"</span>)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p>【参考】：</p>
<p><a href="https://en.wikipedia.org/wiki/DOM_events#Event_handling_models" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/DOM_events#Event_handling_models</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>原型链（二）</title>
    <url>/blog/2019/04/06/js-%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><ul>
<li><p>如何准确判断一个变量是数组类型</p>
<p><code>instanceof</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// Object，typeof无法判断是否为数组类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>写一个原型链的例子</p>
<p>一个封装 DOM 查询的例子：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elem = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Elem.prototype.html = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="keyword">this</span>.elem;</span><br><span class="line">  <span class="keyword">if</span> (val) &#123;</span><br><span class="line">    elem.innerHtml = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 链式操作</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elem.innerHtml;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Elem.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="keyword">this</span>.elem;</span><br><span class="line">  elem.addEventListener(type, fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 链式操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> Elem(<span class="string">'div1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'div1.html()='</span>, div1.html());</span><br><span class="line"></span><br><span class="line">div1.html(<span class="string">'hello  world'</span>);</span><br><span class="line">div1.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'click'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">div1.html(<span class="string">'hello  world'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'click'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>描述 <code>new</code> 一个对象的过程：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为新对象添加属性）；</li>
<li>返回新对象；</li>
</ol>
</li>
</ul>
<ul>
<li>zepto （或 jquery）源码中如何使用原型（入口函数$、构造函数new、构造函数的原型）</li>
</ul>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my-zepto.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> zepto = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;len; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>[i] = dom[i]; <span class="comment">// 将dom元素赋值到 new Z的实例中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = len;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector || <span class="string">''</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  zepto.Z = <span class="function"><span class="keyword">function</span> (<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Z(dom, selector); <span class="comment">// 注意：出现了new关键字</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  zepto.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">    <span class="keyword">var</span> dom = slice.call(<span class="built_in">document</span>.querySelectorAll(selector)); <span class="comment">// 将类数组转化为数组</span></span><br><span class="line">    <span class="keyword">return</span> zepto.Z(dom, selector); <span class="comment">// 返回一个Z的实例</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 即使用zepto时候的$</span></span><br><span class="line">  <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zepto.init(selector);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.$ = $;</span><br><span class="line">  </span><br><span class="line">  $.fn = &#123;</span><br><span class="line">    css: <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'操作css'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'-操作css'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    html: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'操作html'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'-操作html'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Z.prototype = $.fn; <span class="comment">// Z的实例上就有了css和html方法</span></span><br><span class="line">  <span class="comment">// （构造函数的显示原型 == 其实例的隐式原型，实例上的方法 会到构造函数的显示原型上寻找）</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="comment">// 匿名函数自执行，避免全局变量被污染</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>原型在zepto中的应用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>zepto test 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>zepto test 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>zepto test 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>zepto test in div<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"my-zepto.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> $p = $(<span class="string">'p'</span>); <span class="comment">// 4个元素</span></span></span><br><span class="line"><span class="javascript">      $p.css(<span class="string">'font-size'</span>: <span class="string">'40px'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($p.html())； <span class="comment">// 仅打印第一个元素内容</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $div = $(<span class="string">'#div1'</span>)</span></span><br><span class="line"><span class="javascript">      $p.css(<span class="string">'color'</span>: <span class="string">'blue'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($div.html())；</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my-jquery.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  jQuery.fn = &#123;</span><br><span class="line">    css: <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'css操作'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'-css操作'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    html: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'html操作'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'-html操作'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> init = jQuery.fn.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">    <span class="keyword">var</span> dom = slice.call(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>[i] = domp[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = len;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  init.prototype = jQuery.fn <span class="comment">// 赋值给构造函数的原型</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="comment">// 匿名函数自执行，避免全局变量被污染</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>思考，为什么先把对象赋值给 <code>$.fn</code>，然后再赋值给  <code>Z.prototype</code>，直接将对象赋值给 <code>Z.prototype</code> 不就好了吗？</p>
<p>同理，<code>jquery</code> 中，为什么还要 <code>jquery.fn</code>，直接将对象赋值给 <code>init.prototype</code> 不就好了吗？</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn = &#123;</span><br><span class="line">  css: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  html: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">Z.prototype = $.fn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接如下，不就可以了吗？目的不就是，为了让实例继承就好了吗？</span></span><br><span class="line">Z.prototype = &#123;</span><br><span class="line">  css: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  html: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为了扩展插件</span></span><br></pre></td></tr></table></figure>
<p>这么做是为了扩展插件。</p>
<p>扩展插件需要将插件函数放到构造函数的原型中去，这样插件函数才能被实例 <code>$()</code> 继承。而构造函数在全局中不可访问，仅有 <code>$</code> 暴露给全局中，通过将 <code>$.fn</code> 赋值给构造函数的原型，我们在 <code>$.fn</code> 上扩展方法时，即是在构造函数的原型上扩展方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.fn.getNodeName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于init.prototype.getNodeName = function () &#123;&#125;</span></span><br><span class="line"><span class="comment">// 最终目的是将插件函数getNodeName，放到 init.prototype 中去（放到构造函数的原型中）。但是不能通过构造函数（init）的原型去拓展，因为构造函数（init）在全局上获取不到。</span></span><br></pre></td></tr></table></figure>
<p>原因：只有 <code>$</code> 会暴露在 <code>window</code> 全局变量；（封装软件或工具的一个设计模式是，仅暴露一个变量给全局就好了，软件或工具内的其他方法或变量的修改，通过这一个变量来实现就好了，避免造成全局变量污染。）</p>
<p>好处：将插件扩展统一到 <code>$.fn.xxx</code> 这一个接口，方便扩展使用；（通过这种方式，统一了构造函数扩展方法的规范。）</p>
<ul>
<li><p>原型如何体现它的扩展性？</p>
<p>如上所述的 <code>jquery</code> 和 <code>zepto</code> 插件扩展机制。（插件扩展到了 <code>$.fn</code>，原因是构造函数并没有开放出来，只有 <code>$</code> 被开放到全局中了。好处是，可以通过这种方式，统一规范，构造函数的扩展。）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>原型在jQuery中的应用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>jquery test 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>jquery test 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>jquery test 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>jquery test in div<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.3.1"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'$.fn='</span>, $.fn)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 插件扩展</span></span></span><br><span class="line"><span class="javascript">      $.fn.getNodeName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'NodeName='</span>, <span class="keyword">this</span>[<span class="number">0</span>].nodeName)</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 验证插件扩展</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $p = $(<span class="string">'p'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($p);</span></span><br><span class="line">      $p.getNodeName();</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> $div1 = $(<span class="string">'#div1'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($div1);</span></span><br><span class="line">      $div1.getNodeName();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>发布订阅模式</title>
    <url>/blog/2019/05/04/js-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>发布者-订阅者（ publisher-subscriber）模式（又名观察者模式），用JavaScript的话来说，这种模式的实质就是可以对程序中某个对象的状态进行观察，并且在其发生改变时能够得到通知。观察者模式中存在两个角色：观察在和被观察者（发布者和订阅者）。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在JavaScript中有多种方法可以实现发布者－订阅者模式。</p>
<ul>
<li>订阅者可以订阅和退订。</li>
<li>发布者负责投迭。</li>
</ul>
<a id="more"></a>
<h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报社（发布者）</span></span><br><span class="line"><span class="keyword">var</span> Publisher = <span class="keyword">new</span> Observable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读者（订阅者）</span></span><br><span class="line"><span class="keyword">var</span> Subscriber = <span class="function"><span class="keyword">function</span> (<span class="params">news</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// news delivered directly to my front porch</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报社登记其顾客</span></span><br><span class="line">Publisher.subscribeCustomer(Subscriber);</span><br><span class="line"><span class="comment">// 报社投送信息</span></span><br><span class="line">Publisher.deliver(<span class="string">'extre, extre, read all about it'</span>);</span><br><span class="line"><span class="comment">// 报社取消其顾客的订阅</span></span><br><span class="line">Publisher.unSubscribeCustomer(Subscriber);</span><br></pre></td></tr></table></figure>
<p>在这个模型中，可以看出发布者处于明显的主导地位．它们负责登记其顾客，而且有权停止<br>为其投送．最后，新的报纸出版后它们会将其投送给顾客．</p>
<p>上面的代码创建了一个新的可观察(observable)对象。它有三个实例方法：subscribeCustomer、unSubscribeCustomer和deliver，subscribeCustomer方法以一个代表订阅者的回调函数为参数。deliver方法在调用过程中将通过这些回调函数把数据发送给每一个订阅者。</p>
<h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建发布者（报社）</span></span><br><span class="line"><span class="keyword">var</span> NewYorkTimes = <span class="keyword">new</span> Publisher;</span><br><span class="line"><span class="keyword">var</span> AustinHerald = <span class="keyword">new</span> Publisher;</span><br><span class="line"><span class="keyword">var</span> SfChronicle = <span class="keyword">new</span> Publisher;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建订阅者（读者）</span></span><br><span class="line"><span class="keyword">var</span> Joe = <span class="function"><span class="keyword">function</span> (<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Delivery from '</span> + <span class="keyword">from</span> + <span class="string">' to Joe'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Lindsay = <span class="function"><span class="keyword">function</span> (<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Delivery from '</span> + <span class="keyword">from</span> + <span class="string">' to Lindsay'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Quadaras = <span class="function"><span class="keyword">function</span> (<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Delivery from '</span> + <span class="keyword">from</span> + <span class="string">' to Quadaras'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者，订阅发布者</span></span><br><span class="line">Joe.subscribe(NewYorkTimes)</span><br><span class="line">   .subscribe(SfChronicle);</span><br><span class="line"></span><br><span class="line">Lindsay.subscribe(AustinHerald)</span><br><span class="line">   		 .subscribe(SfChronicle);</span><br><span class="line">       .subscribe(NewYorkTimes);</span><br><span class="line"></span><br><span class="line">Quadaras.subscribe(AustinHerald)</span><br><span class="line">        .subscribe(SfChronicle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者，发布内容</span></span><br><span class="line">NewYorkTimes.deliver(<span class="string">'Here is your paper! Direct form the Big apple'</span>);</span><br><span class="line"></span><br><span class="line">AustinHerald.deliver(<span class="string">'News'</span>)</span><br><span class="line">            .deliver( <span class="string">'Reviews'</span>)</span><br><span class="line">            .deliver(<span class="string">'Coupons'</span>);</span><br><span class="line"></span><br><span class="line">SfChronicle.deliver(<span class="string">'The weather is still chilly'</span>)</span><br><span class="line">           .deliver(<span class="string">'Hi Mom! I\'m writing a book'</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，发布者的创建方式和订阅者接收数据的方式没有多少改变，但拥有订阅和退订权的一方变成了订阅者。当然，负责发送数据的还是发布者一方。<br>本例中的发布者是Publisher类的实例，它有一个deliver方法。而作为订阅者的函数对象则拥有subscribe和unsubscribe两个方法。订阅者只是普通的回调函数，那两个方法是通过扩展Function的prototype而加入的。</p>
<h3 id="构建观察者API"><a href="#构建观察者API" class="headerlink" title="构建观察者API"></a>构建观察者API</h3><p>首先，我们需要一个发布者的构造函数，它为该类实例定义了一个类型为数组的属性，用来保存订阅者的引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publisher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subscribers = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="投送方法"><a href="#投送方法" class="headerlink" title="投送方法"></a>投送方法</h4><p>所有Publisher实例都应该能够投送数据。只要把deliver方法添加到Publisher的prototype中，它就能够被所有Publisher实例对象共享：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Publisher.prototype.deliver = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对每一个订阅者执行回调函数（在这里，订阅者本身就是回调函数）</span></span><br><span class="line">  <span class="keyword">this</span>.subscribers.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn(data);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 将this作为返回值，可以对该方法进行链式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="订阅方法"><a href="#订阅方法" class="headerlink" title="订阅方法"></a>订阅方法</h4><p>给予订阅者订阅的能力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往发布者的用户列表中，添加新用户</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">publisher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 该用户是否已经存在</span></span><br><span class="line">  <span class="keyword">var</span> alreadyExists = publisher.subscribers.some(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> el === that;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!alreadyExists) &#123;</span><br><span class="line">    publisher.sbuscribers.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p>
<p>some() 方法会依次执行数组的每个元素：</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回<em>true</em> , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回false。</li>
</ul>
<p>some() 不会对空数组进行检测，some() 不会改变原始数组。</p>
</blockquote>
<h4 id="退订方法"><a href="#退订方法" class="headerlink" title="退订方法"></a>退订方法</h4><p><code>unsubscribe</code>方法可供订阅者用来停止对指定发布者的观察：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">publisher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 将该订阅者从指定的publisher中剔除</span></span><br><span class="line">  publisher.subscribers = publisher.subscribers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> el === that;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<p>filter() 不会对空数组进行检测，filter() 不会改变原始数组。</p>
</blockquote>
<p>有些订阅者在监听到某种一次性的事件之后会在回调阶段立即退订该事件。其做法大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> publisherObject = <span class="keyword">new</span> Publisher;</span><br><span class="line"><span class="keyword">var</span> observerObject = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// process data</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="comment">// unsubscribe from this publisher</span></span><br><span class="line">  <span class="built_in">arguments</span>.callee.unsubscribe(publisherObject);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observerObject.subscribe(publisherObject);</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax 请求的error、succ 等事件。 或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</p>
<p>发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实现发布-订阅模式的步骤：</p>
<ul>
<li>首先指定好谁充当发布者；</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者；</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函<br>数。</li>
</ul>
<hr>
<p>【参考】：</p>
<p>《JavaScript设计模式》</p>
<p>《JavaScript设计模式与开发实践》</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>循环</title>
    <url>/blog/2019/04/01/js-%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="跳出多层-for-循环"><a href="#跳出多层-for-循环" class="headerlink" title="跳出多层 for 循环"></a>跳出多层 for 循环</h2><p>label 语句可以在代码中添加标签，以便将来由 break 或 continue 语句引用。</p>
<blockquote>
<p>遇到 <code>break</code>，不再执行 <code>break</code> 后的代码，并跳出当前层的 for 循环；</p>
<p>遇到 <code>continue</code>，不执行 <code>continue</code> 后的代码，跳过当前层 for 循环的这个次循环，执行下一次循环； </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost: <span class="comment">// label</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p>当 <code>i == 5 &amp;&amp; j == 5</code> 成立的时候，会跳出 <code>outermost</code> 标签表示的 for 循环，即最外层 for 循环。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost: <span class="comment">// label</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p>当 <code>i == 5 &amp;&amp; j == 5</code> 成立的时候，会跳过 <code>outermost</code> 标签表示的 for 循环的本次循环，即跳过最外层 for 循环的这次循环，执行下一个循环（ <code>i=6</code> 的循环）。</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p><code>ECMAScript 6</code> 新方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想修改语句块中的变量 , 也可以使用const代替let。</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">fname</span>:<span class="string">"John"</span>, <span class="attr">lname</span>:<span class="string">"Doe"</span>, <span class="attr">age</span>:<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fname</span></span><br><span class="line"><span class="comment">// lname</span></span><br><span class="line"><span class="comment">// age</span></span><br></pre></td></tr></table></figure>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><p><code>for in</code> 以任意顺序循环遍历一个对象的可枚举属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">fname</span>:<span class="string">"John"</span>, <span class="attr">lname</span>:<span class="string">"Doe"</span>, <span class="attr">age</span>:<span class="number">25</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> txt = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> person)  <span class="comment">// x 为属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    txt = txt + person[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(txt);</span><br><span class="line"><span class="comment">// JohnDoe25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>节流与防抖</title>
    <url>/blog/2019/03/05/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019061801.png" alt="防抖"></p>
<a id="more"></a>
<p>现有场景，需对用户的输入，进行提示，多次输入间隔若小于400ms，仅对最后一次输入，进行检索。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 400ms后才执行回调，若在这个400ms内又触发了事件，则清除上一次的定时，重新计时400ms后执行回调</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  clearTimeout(timer);</span><br><span class="line">  timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(e.target.value)</span><br><span class="line">  &#125;, <span class="number">400</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ajax request '</span> + content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先触发式防抖"><a href="#先触发式防抖" class="headerlink" title="先触发式防抖"></a>先触发式防抖</h4><p>上例是在触发事件，一段事件后，再执行回调。但是，我们有时会希望，在触发事件时就立即调用回调，如：用户的频繁点击操作，我们希望在一连串的连续点击中，仅执行第一次点击的回调（两次点击间隔小于400ms时，仅执行前一次）：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019061802.png" alt="防抖前置"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> outTime = <span class="literal">true</span>; <span class="comment">// 当前click距上一次click，是否已超过400ms内</span></span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (outTime) &#123;</span><br><span class="line">    callBack();</span><br><span class="line">    outTime = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearTimeout(timer);</span><br><span class="line">  timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    outTime = <span class="literal">true</span>;</span><br><span class="line">  &#125;, <span class="number">400</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callBack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'clicked me'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019061803.jpg" alt="节流"></p>
<p>方法一（后置式节流），比较两次时间间隔（当前时刻与上一次执行回调时的时间间隔）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> lastTime = <span class="number">0</span>; <span class="comment">// 上一次执行回调的时刻</span></span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="keyword">if</span> (lastTime &amp;&amp; (now - lastTime &gt; <span class="number">400</span>)) &#123;</span><br><span class="line">    ajax(e.target.value)</span><br><span class="line">    lastTime = now;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ajax request '</span> + content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二（后置式节流）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> isTime = <span class="literal">true</span>; <span class="comment">// 当前click距上一次执行回调，是否间隔400ms;</span></span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isTime) &#123;</span><br><span class="line">    isTime = <span class="literal">false</span>;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      ajax(e.target.value);</span><br><span class="line">      isTime = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ajax request '</span> + content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前置式节流：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> isTime = <span class="literal">true</span>; <span class="comment">// 当前click距上一次执行回调，是否间隔400ms;</span></span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isTime) &#123;</span><br><span class="line">    ajax(e.target.value);</span><br><span class="line">    isTime = <span class="literal">false</span>;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      isTime = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ajax request '</span> + content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节流与防抖的区别"><a href="#节流与防抖的区别" class="headerlink" title="节流与防抖的区别"></a>节流与防抖的区别</h3><p>以上面的例子来说明，用户在 2s 内不间断地进行输入操作。</p>
<ul>
<li><p>应用<code>防抖</code>之后，仅会在 2.4s 时会执行一次回调；</p>
</li>
<li><p>应用 <code>节流</code>之后，每间隔 400ms 就执行 1 次回调，一共执行了 6 次回调；</p>
</li>
</ul>
<p>防抖：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时，<strong>连续触发仅执行一次回调</strong>；</p>
<p>节流：规定在一个单位时间内，只能触发一次回调函数。<strong>连续触发时，稀释为每间隔一段时间执行回调</strong>；</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/blog/2018/10/27/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="正则表达式元字符"><a href="#正则表达式元字符" class="headerlink" title="正则表达式元字符 :"></a>正则表达式元字符 :</h3><ul>
<li><p><code>\</code>  反斜杠用于转义特殊字符。</p>
</li>
<li><p><code>^</code>  匹配开头位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。</p>
</li>
<li><p><code>?</code>  匹配前面一个表达试 0 次或者 1 次。等价于 {0, 1}。</p>
</li>
<li><p><code>+</code>  匹配前面一个表达式 1 次或者多次。等价于 {1, }。</p>
</li>
<li><p><code>*</code>  匹配前一个表达式0次或多次。等价于 {0,}。 </p>
</li>
<li><p><code>(x)</code>  匹配 x 并且记住匹配项，括号被称为捕获括号。 </p>
<blockquote>
<p>模式 <code>/(foo) (bar) \1 \2/</code>中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。 </p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h3 id="正则表达式运算符优先级"><a href="#正则表达式运算符优先级" class="headerlink" title="正则表达式运算符优先级"></a>正则表达式运算符优先级</h3><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>相同优先级的从左到右进行运算。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?:), (?=), []</td>
<td>圆括号和方括号</td>
</tr>
<tr>
<td>*, +, ?, {n}, {n,}, {n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^, $, \任何元字符、任何字符</td>
<td>定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td>\</td>
<td>替换，”或”操作 字符具有高于替换运算符的优先级，使得”m\</td>
</tr>
</tbody>
</table>
<h3 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h3><p><code>/\d{2,5}?/</code> 表示惰性匹配，虽然2到5次都行，当有2个的时候，就不再往下尝试了 </p>
<p>通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：</p>
<blockquote>
<p><code>{m,n}?</code><br><code>{m,}?</code><br><code>??</code><br><code>+?</code><br><code>*?</code></p>
</blockquote>
<h3 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h3><p><img src="https://github.com/riversword/images/raw/master/blog/95d0faf6b21f9414d24c8281b3046746?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p>
<p>在ES5中，共有6个锚字符，可以匹配位置，配置位置可以理解为匹配该位置的空字符。</p>
<blockquote>
<p>^    $    \b    \B    (?=p)    (?!p)</p>
</blockquote>
<p><code>^</code>（脱字符）匹配开头，在多行匹配中匹配行开头。 </p>
<p><code>$</code>（美元符号）匹配结尾，在多行匹配中匹配行结尾。 </p>
<p><code>\b</code> 是单词边界，具体就是<code>\w</code>和<code>\W</code>之间的位置，也包括<code>\w</code>和<code>^</code>之间的位置，也包括<code>\w</code>和<code>$</code>之间的位置。 </p>
<p><code>\B</code> 就是<code>\b</code>的反面的意思，非单词边界。例如在字符串中所有位置中，去掉<code>\b</code>，剩下的都是<code>\B</code>的。 </p>
<p><code>(?=p)</code> 其中 <code>p</code> 是一个子模式，即 <code>p</code> 前面的位置。 </p>
<p><code>(?!p)</code> 是 <code>(?=p)</code> 的反面意思 </p>
<h3 id="案例：给整数添加千位分隔符"><a href="#案例：给整数添加千位分隔符" class="headerlink" title="案例：给整数添加千位分隔符"></a>案例：给整数添加千位分隔符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> milliFormat = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> num &amp;&amp; num.toString().replace(<span class="regexp">/(?=(?!^)(\d&#123;3&#125;)+$)/g</span>, <span class="string">','</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据运算优先级，先运算括号内的表达式</p>
<p>整个表达式分解成3个部分，<code>(?!^)</code>  表示不能是开头位置，<code>(\d{3})+$)</code>  表示以3个数字或3的倍数个数字结尾，<code>(?=p)</code>  其中p为子表达式，表示子表达式的前面位置。</p>
<p>综上，<code>/(?=(?!^)(\d{3})+$)/g</code>  表示全局匹配，以 3n 个数字结尾的目标的前面位置，并且该位置不能是开头位置。</p>
<h4 id="进阶，给数字（整数和小数）添加千位分隔符"><a href="#进阶，给数字（整数和小数）添加千位分隔符" class="headerlink" title="进阶，给数字（整数和小数）添加千位分隔符"></a>进阶，给数字（整数和小数）添加千位分隔符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> milliFormat = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> num &amp;&amp; num.toString()</span><br><span class="line">        .replace(<span class="regexp">/^\d+/g</span>, (m) =&gt; m.replace(<span class="regexp">/(?=(?!^)(\d&#123;3&#125;)+$)/g</span>, <span class="string">','</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>^\d+</code>  匹配从起始位到小数点之间的数字。</p>
<p><code>.replace()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringObject.replace(regexp/substr,replacement)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>regexp/substr</td>
<td>必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</td>
</tr>
<tr>
<td>replacement</td>
<td>必需。一个字符串值。规定了替换文本或生成替换文本的函数。</td>
</tr>
</tbody>
</table>
<p>replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。 </p>
<h3 id="案例：获取-url-中的参数"><a href="#案例：获取-url-中的参数" class="headerlink" title="案例：获取 url 中的参数"></a>案例：获取 url 中的参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取URL参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(^|&amp;)'</span> + name + <span class="string">'=([^&amp;]*)(&amp;|$)'</span>)</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg) <span class="comment">// 匹配目标参数</span></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getUrlParam decodeURI(r[2]) ='</span>, <span class="built_in">decodeURI</span>(r[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">decodeURI</span>(r[<span class="number">2</span>]) <span class="comment">// 返回参数值，转码中文使中文参数不乱码</span></span><br><span class="line">    <span class="comment">// return unescape(r[2]) // 返回参数值，中文出现乱码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>(^|&amp;)</code> 表示^或&amp;匹配，即匹配name开头或者以字符&amp;后接name，<code>=([^&amp;]*)(&amp;|$)</code> 第一个括号表示=后面接除&amp;外的内容，第二个括号表示内容后可以接&amp;或者就以内容本身结尾。</p>
<p>例如：window.location.href=’<a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=javascript&#39;，则" target="_blank" rel="noopener">https://www.baidu.com/s?ie=UTF-8&amp;wd=javascript&#39;，则</a> window.location.search.substr(1) = ‘ie=UTF-8&amp;wd=javascript’。getUrlParam (wd)</p>
<p><em>string</em>.match(<em>regexp</em>) 返回匹配结果的数组，本例的正则表达式中有3个括号，返回匹配结果时，数组中元素会有4个 [“&amp;wd=javascript”, “&amp;”, “javascript”, “”]，第1个元素是整个正则匹配到的结果，第2个元素是第1个子正则（括号）匹配到的结果，以此类推，需要获取到的参数值是第2个子正则匹配到的内容。</p>
<p>window.loaction 对象包含的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>从井号 (#) 开始的 URL（锚）</td>
</tr>
<tr>
<td>host</td>
<td>主机名和当前 URL 的端口号</td>
</tr>
<tr>
<td>hostname</td>
<td>当前 URL 的主机名</td>
</tr>
<tr>
<td>href</td>
<td>完整的 URL</td>
</tr>
<tr>
<td>pathname</td>
<td>当前 URL 的路径部分</td>
</tr>
<tr>
<td>port</td>
<td>当前 URL 的端口号</td>
</tr>
<tr>
<td>protocol</td>
<td>当前 URL 的协议</td>
</tr>
<tr>
<td>search</td>
<td>从问号 (?) 开始的 URL（查询部分）</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域请求Jsonp</title>
    <url>/blog/2018/11/29/js-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82jsonp/</url>
    <content><![CDATA[<p>跨域：获取不同源的资源时，就属于跨域。源：协议、域名、端口。默认端口是80。三者任一不同就是跨域。</p>
<p>ajax 直接请求跨域的资源时，存在跨域无权限访问的问题。而页面上的引入 js 文件时则不受跨域影响，并且可以发现凡拥有 <code>src</code> 属性的标签，都拥有跨域的能力，比如 <code>&lt;script&gt;</code>、<code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> 。</p>
<p>而跨域请求 jsonp 正是利用了，<code>&lt;script&gt;</code> 标签的跨域能力。</p>
<a id="more"></a>
<h2 id="大致原理"><a href="#大致原理" class="headerlink" title="大致原理"></a>大致原理</h2><p>首先在页面中定义一个 handle 函数，然后通过引入的 <code>&lt;script&gt;</code> ，传入参数并执行 handle 函数，传入的参数即页面期望跨域请求拿到的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(data);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).innerHtml = res.result;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.riverjean.com/test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            result is <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>test.js 文件内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line">handle(&#123;<span class="string">"result"</span>: <span class="string">"riverjean"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="简单的-jsonp-实现"><a href="#简单的-jsonp-实现" class="headerlink" title="简单的 jsonp 实现"></a>简单的 jsonp 实现</h2><p>动态地创建 <code>script</code> 标签，实现 jsonp 请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(data);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).innerHtml = res.result;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">jsonp</span> (<span class="params">url, callback</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    			<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">    			<span class="keyword">var</span> target = url + <span class="string">'？callback='</span> + callback；</span></span><br><span class="line">    			script.setAttribute(src, target);</span><br><span class="line"><span class="javascript">                 <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">            jsonp(<span class="string">'http://www.riverjean.com/testjsonp'</span>, handle)</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            result is <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后服务端会返回一段代码给客户端执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handle(&#123;<span class="string">"result"</span>: <span class="string">"riverjean"</span>&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶函数与数组</title>
    <url>/blog/2019/05/25/js-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>高阶函数：函数作为参数传入，返回值为一个函数。</p>
<p>下面来通过高阶函数来简化循环操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">12</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">28</span>, <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canDrink0 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ages.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ages[i] &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">		canDrink0.push(ages[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'canDrink0='</span>, canDrink0);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach()</code> 方法按升序为数组中含有效值的每一项执行一次callback函数，没有返回值。（修改原数组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canDrink1 = [];</span><br><span class="line">ages.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">		canDrink1.push(age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'canDrink1='</span>, canDrink1);</span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter()</code>  方法会创建一个新的数组, 其包含通过所提供函数实现的测试的所有元素。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canDrink2 = ages.filter(<span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age &gt;= <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'canDrink2='</span>, canDrink2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canDrink3 = ages.filter(<span class="function">(<span class="params">age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> age &gt;= <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'canDrink3='</span>, canDrink3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canDrink4 = ages.filter(<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'canDrink4='</span>, canDrink4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>, <span class="attr">age</span>: <span class="number">10</span>, <span class="attr">gender</span>: <span class="string">'male'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Jean'</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">gender</span>: <span class="string">'female'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Lucy'</span>, <span class="attr">age</span>: <span class="number">17</span>, <span class="attr">gender</span>: <span class="string">'female'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Jim'</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> boys = people.filter(<span class="function"><span class="params">person</span> =&gt;</span> (person.age &lt; <span class="number">18</span> &amp;&amp; person.gender === <span class="string">'male'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boys='</span>, boys);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>箭头函数可以有一个“简写体”或常见的“块体”。</p>
<p>在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的<code>return</code>语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">// 简写函数 省略return</span></span><br><span class="line">&gt; <span class="keyword">var</span> func = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 常规编写 明确的返回值</span></span><br><span class="line">&gt; <span class="keyword">var</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>注意：<code>params =&gt; {object:literal}</code>这种简单的语法返回对象字面量是行不通的。记得用圆括号把对象字面量包起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map()</code> 方法对数组中每个元素进行操作，并返回一个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> usersInfo = people.map(<span class="function"><span class="params">person</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;person.name&#125;</span>,​<span class="subst">$&#123;person.gender&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'usersInfo='</span>, usersInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式操作，对返回的数组继续用map操作</span></span><br><span class="line"><span class="keyword">var</span> usersInfo2 = people</span><br><span class="line">	.map(<span class="function"><span class="params">person</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;person.name&#125;</span>,<span class="subst">$&#123;person.gender&#125;</span>,age:<span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">	.map(<span class="function"><span class="params">info</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;info&#125;</span>,[update: 20190101]`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'usersInfo2='</span>, usersInfo2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>map</code>不修改调用它的原数组本身（当然可以在 <code>callback</code> 执行时改变原数组）。</p>
<p>使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。</p>
</blockquote>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>sort()</code> 方法对数组的元素进行排序，并返回数组。（修改原数组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortPeople = people.sort(<span class="function"><span class="keyword">function</span> (<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 按从小到大排列</span></span><br><span class="line">  <span class="keyword">if</span> (p1.age &gt; p2.age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sortPeople='</span>, sortPeople);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sortPeople1 = people.sort(<span class="function">(<span class="params">p1, p2</span>) =&gt;</span> (p1.age &gt; p2.age ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sortPeople1='</span>, sortPeople1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// param1-param2从小到大排，param2-param1从大到小排</span></span><br><span class="line"><span class="keyword">const</span> sortPeople2 = people.sort(<span class="function">(<span class="params">p1, p2</span>) =&gt;</span> p1 -p2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sortPeople2='</span>, sortPeople2);</span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce()</code> 方法对数组中的每个元素执行一次提供的函数(升序执行)，将其结果汇总为单个返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ageSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">  ageSum += people[i].age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ageSum='</span>, ageSum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ageSum2 = people.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">total, person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + person.age;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 令total初始值为0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ageSum2='</span>, ageSum2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ageSum3 = people.reduce(<span class="function">(<span class="params">total, person</span>) =&gt;</span> total + person.age, <span class="number">0</span>); <span class="comment">// 令total初始值为0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ageSum2='</span>, ageSum2);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合链式操作</span></span><br><span class="line"><span class="keyword">const</span> combined = people</span><br><span class="line">	.map(<span class="function"><span class="params">person</span> =&gt;</span> person.age) <span class="comment">/* [10, 23, 17, 20] */</span></span><br><span class="line">  .filter(<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= <span class="number">20</span>) <span class="comment">/* [23, 20] */</span></span><br><span class="line">	.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b) <span class="comment">/* [20, 23] */</span></span><br><span class="line">	.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>); <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'combined'</span>, combined);</span><br></pre></td></tr></table></figure>
<hr>
<p>【参考】：</p>
<p><a href="https://www.youtube.com/watch?v=rRgD1yVwIvE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rRgD1yVwIvE</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E5%87%BD%E6%95%B0%E4%BD%93" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E5%87%BD%E6%95%B0%E4%BD%93</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/blog/2018/06/18/js-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>函数嵌套函数，内部函数可以访问外部函数的参数和变量，内部函数在外部函数之外被调用时，就形成了闭包。闭包是一个环境，能读取到其他函数内部的变量。</p>
<blockquote>
<p>闭包是一个函数在创建时允许自身函数访问并操作该自身函数之外的变量时所创建的作用域。换句话说，闭包可以让函数访问所有的变量和函数，只要这些变量和函数存在于该函数声明时的作用域内就行。</p>
<p>——《JavaScript忍者秘籍》p86</p>
</blockquote>
<blockquote>
<p>当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量。其原理是：在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，<strong>当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。</strong></p>
<p>——《JavaScript高级程序设计》p192</p>
</blockquote>
<a id="more"></a>
<h3 id="闭包的优点："><a href="#闭包的优点：" class="headerlink" title="闭包的优点："></a>闭包的优点：</h3><ul>
<li><p><strong>可以在外部读取到函数内部的变量，可以让这些变量的值始终保持在内存中</strong>。</p>
</li>
<li><p><strong>避免全局变量的污染。</strong>定义过多全局变量可能会造成命名冲突，而使用闭包，外层函数的变量或属性，只有通过内部函数访问到，无法通过其他途径访问修改，从而达到了保护变量安全的效果（避免变量污染）。</p>
</li>
<li><p>通过闭包<strong>实现了 JavaScript 私有属性和私有方法的效果</strong>。若每个模块都可以调用修改变量，当程序越来越复杂之后，会带不可预测的危险。所以推荐变量尽量私有化，当需要让局部变量发挥全局变量的作用时，可以考虑使用闭包。</p>
</li>
</ul>
<blockquote>
<p>使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下：创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。</p>
<p><strong>闭包还可以用于在对象中创建私有变量</strong>，相关概念和要点如下。即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。有权访问私有变量的公有方法叫做特权方法。可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块方式、增强的模式来实现单例的特权方法。</p>
<p>因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。</p>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。</p>
<p>——《JavaScript高级程序设计》p192</p>
</blockquote>
<p>例，循环中使用闭包解决 <code>var</code> 定义函数的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。</p>
<p>使用闭包来解决上述问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.</p>
<h3 id="闭包的缺点："><a href="#闭包的缺点：" class="headerlink" title="闭包的缺点："></a>闭包的缺点：</h3><p>闭包会使函数中的变量一直保存在内存中，不会被浏览器内存回收机制清理，内存消耗大。解决办法是，在退出函数之前，将不需要使用的局部变量删除掉。</p>
<blockquote>
<p>一旦数据不再有用，最好通过将其值设置为 <code>null</code>，来释放其引用——这个做法叫做解除引用。适用于大多数全局变量和全局变量的属性。局部变量会在它们离开执行环境时自动被解除引用。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
<p>——《JavaScript高级程序设计》p81</p>
</blockquote>
<h3 id="销毁闭包"><a href="#销毁闭包" class="headerlink" title="销毁闭包"></a>销毁闭包</h3><p>先来看一个闭包的例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(element.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据浏览器垃圾回收机制中的<strong>引用计数</strong>策略可知，这里的引用类型 <code>someElement</code> 被赋值给了变量 <code>element</code>，而 <code>element</code> 变量又被事件处理函数引用，dom 对象的引用计数是 2，这样就形成了循环引用，当事件处理函数被多次调用时，就会导致大量内存无法被回收。</p>
<blockquote>
<p><strong>引用计数</strong>的含义是，跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。</p>
</blockquote>
<p>在前端性能优化中，我们通常将不再需要的变量置空，让浏览器垃圾回收机制回收，避免占内存。这里也可以通过将变量设置为 <code>null</code>，来清除循环引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var element = document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    var id = element .id;</span><br><span class="line">    element .onclick = function () &#123;</span><br><span class="line">        alert(id); </span><br><span class="line">    &#125;</span><br><span class="line">    element = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.</p>
<hr>
<p>【参考】：</p>
<p>《JavaScript高级程序设计》p80、p184</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/blog/2018/05/03/vue-axios/</url>
    <content><![CDATA[<h3 id="axios-安装"><a href="#axios-安装" class="headerlink" title="axios 安装"></a>axios 安装</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure>
<h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><ul>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.options(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<a id="more"></a>
<h3 id="axios-基础"><a href="#axios-基础" class="headerlink" title="axios 基础"></a>axios 基础</h3><p>利用axios.all方法可同时调用多个接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用.all方法可同时调用两个接口</span></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//Both requests are now complete</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>axios 请求方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">"#app"</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    msg: <span class="string">''</span></span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//全局拦截 拦截请求（请求发出前执行）</span></span></span><br><span class="line"><span class="javascript">    axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"request init"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> config;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//全局拦截 拦截响应（响应返回前执行）</span></span></span><br><span class="line"><span class="javascript">    axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"response init"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> response;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">get</span>: function() &#123;</span></span><br><span class="line"><span class="javascript">      axios.get(<span class="string">"../package.json"</span>, &#123;</span></span><br><span class="line">        params: &#123;</span><br><span class="line"><span class="javascript">          userId: <span class="string">"999"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        headers: &#123;</span><br><span class="line"><span class="javascript">          token: <span class="string">"riversword"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        before: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"before init"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.msg = res.data;</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;<span class="comment">//捕获异常</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"error="</span> + error);</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    post: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      axios.post(<span class="string">"../package.json"</span>, &#123;</span></span><br><span class="line"><span class="javascript">        userId: <span class="string">"888"</span></span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line"><span class="javascript">          token: <span class="string">"riversword2"</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.msg = res.data;</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"error="</span> + error);</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    http: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      axios(&#123;</span><br><span class="line"><span class="javascript">        url: <span class="string">"../package.json"</span>,</span></span><br><span class="line"><span class="javascript">        method: <span class="string">"get"</span>,</span></span><br><span class="line"><span class="javascript">        params: &#123; <span class="comment">//get请求参数</span></span></span><br><span class="line"><span class="javascript">          userId: <span class="string">"http-get"</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// method: "post",</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// data: &#123; //post请求参数</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     userId: "101"</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;,</span></span></span><br><span class="line">        headers: &#123;</span><br><span class="line"><span class="javascript">          token: <span class="string">"riversword3"</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.msg = res.data;</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"error="</span> + error);</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>axios</tag>
        <tag>Vue</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>轮播插件 swiper 的配置</title>
    <url>/blog/2018/07/13/swiper%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="swiper-的基本配置"><a href="#swiper-的基本配置" class="headerlink" title="swiper 的基本配置"></a>swiper 的基本配置</h1><p>以 <a href="mailto:swiper@4.3.2" target="_blank" rel="noopener">swiper@4.3.2</a> 为例，swiper 的基本配置如下：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">    direction: <span class="string">'vertical'</span>, <span class="comment">// 设置slide的方向为竖直排列</span></span><br><span class="line">    slideActiveClass: <span class="string">'active'</span>, <span class="comment">// 活动块的className</span></span><br><span class="line">    slideNextClass: <span class="string">'bandListItemActive'</span>, <span class="comment">// 设置活动元素的下一个元素的className</span></span><br><span class="line">    slideDuplicateClass: <span class="string">'my-slide-duplicate'</span>, <span class="comment">// 循环模式下被复制的slide类名</span></span><br><span class="line">    autoplay: <span class="literal">true</span>, <span class="comment">// 开启自动轮播，等同于以下设置</span></span><br><span class="line">    <span class="comment">// autoplay: &#123;</span></span><br><span class="line">    <span class="comment">//   delay: 3000,</span></span><br><span class="line">    <span class="comment">//   stopOnLastSlide: false, // 在最后一个slide时，停止自动轮播</span></span><br><span class="line">    <span class="comment">//   disableOnInteraction: true, // 用户操作slide后，就停止自动播放</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    </span><br><span class="line">    noSwiping: <span class="literal">true</span>, <span class="comment">// 禁止class为stop-swiping的slide</span></span><br><span class="line">    noSwipingClass: <span class="string">'stop-swiping'</span>, <span class="comment">// 为禁止的slide标记一个class名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// slideToClickedSlide: true, // 点击滑动到对应的slide</span></span><br><span class="line">    initialSlide: <span class="number">0</span>, <span class="comment">// 设置初始活动块</span></span><br><span class="line">    observer: <span class="literal">true</span>, <span class="comment">// 修改swiper自己或子元素时，自动初始化swiper</span></span><br><span class="line">    observerParents: <span class="literal">true</span>, <span class="comment">// 修改swiper的父元素时，自动初始化swiper</span></span><br><span class="line">    loop: <span class="literal">true</span>, <span class="comment">// 开启循环轮播模式</span></span><br><span class="line">    loopAdditionalSlides: <span class="number">0</span>, <span class="comment">// 循环模式下复制的slide个数</span></span><br><span class="line">    slidesPerView: <span class="number">7</span>, <span class="comment">// 容器中可见的slide个数</span></span><br><span class="line">    spaceBetween: <span class="string">'1%'</span>, <span class="comment">// slide之间的间距</span></span><br><span class="line">    centeredSlides: <span class="literal">true</span>， <span class="comment">// 活动块在容器中央显示</span></span><br><span class="line">    </span><br><span class="line">    on: &#123; <span class="comment">// 事件监听 回调</span></span><br><span class="line">        click: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'触发click事件'</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// instance.clickedSlide 获取到被点击的slide</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'instance.clickedSlide='</span>, instance.clickedSlide)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 跳转到指定索引的slide</span></span><br><span class="line">            instance.slideToLoop(index, <span class="number">100</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'slideToLoop 回调'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 滑至前一个slide，第一个参数为回调函数，true即slideChange..函数；第二个参数为时间</span></span><br><span class="line">            instance.slidePrev(<span class="literal">true</span>, <span class="number">50</span>) </span><br><span class="line">            instance.slideNext(<span class="literal">true</span>, <span class="number">50</span>) <span class="comment">// 滑至后一个slide</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在移动端，click 事件会有延迟甚至失效，用tap事件来替代</span></span><br><span class="line">        tap: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'触发tap事件'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// slide滑动会触发以下事件</span></span><br><span class="line">        slideChange: <span class="function"><span class="keyword">function</span> (<span class="params">swiper</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// this.activeIndex 当前活动块的索引</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'slideChanges事件 this.activeIndex='</span>, <span class="keyword">this</span>.activeIndex)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// this.activeIndex 当前活动块的真实索引（用于Loop模式下）</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'slideChanges事件 this.realIndex='</span>, <span class="keyword">this</span>.realIndex)</span><br><span class="line">        &#125;,</span><br><span class="line">        slideChangeTransitionStart: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'slideChangeTransitionStart事件'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        slideChangeTransitionEnd: <span class="function"><span class="keyword">function</span> (<span class="params">swiper</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 每次执行slideNext都会触发slideChangeTransitionEnd</span></span><br><span class="line">            <span class="comment">// 循环执行slideNext 直至 nextTimes - 1 不大于 0</span></span><br><span class="line">            <span class="keyword">if</span> (nextTimes - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            	nextTimes--</span><br><span class="line">            	that.listSwiper.slideNext(<span class="literal">true</span>, timeLength)</span><br><span class="line">           		<span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="捣鼓-swiper-以适应特殊场景"><a href="#捣鼓-swiper-以适应特殊场景" class="headerlink" title="捣鼓 swiper 以适应特殊场景"></a>捣鼓 swiper 以适应特殊场景</h1><p>swiper 默认容器中第一个 slide 为活动块，即被激活（active）的 slide 会放在容器中的第一项的位置；当设置 <code>centeredSlides: true</code> 时，激活的 slide 会放在容器中间。</p>
<p>有时会遇到这样的需求，要将 swiper 容器中的第二个 slide 显示为活动块，这时 swiper 的基本配置项就不够用了。</p>
<h2 id="自定义活动-slide-的样式"><a href="#自定义活动-slide-的样式" class="headerlink" title="自定义活动 slide 的样式"></a>自定义活动 slide 的样式</h2><p>可以考虑如下设置，将 swiper 的默认活动块取消高亮显示，给第二个 slide 添加高亮样式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">slideActiveClass: <span class="string">'noStyle'</span>, <span class="comment">// 自定义活动slide的class，将其取消高亮显示</span></span><br><span class="line">slideNextClass: <span class="string">'secondSlide'</span>, <span class="comment">// 设置活动slide的下一个slide的class</span></span><br></pre></td></tr></table></figure>
<h2 id="滑动至指定的-slide"><a href="#滑动至指定的-slide" class="headerlink" title="滑动至指定的 slide"></a>滑动至指定的 slide</h2><p>利用开头基本配置中提及的方法<code>instance.slideNext()</code> 和 <code>slideChangeTransitionEnd</code> ，首先获取到当前活动 slide 的索引，以及目标 slide 的索引，通过差值计算可以知道，需要滑动几次可以滑到目标 slide ，然后利用滑动必会触发<code>slideChangeTransitionEnd</code> 事件这一特性，进行循环回调执行 <code>slideNext()</code> 直至滑到目标 slide。</p>
<hr>
<h1 id="循环轮播中的数学问题"><a href="#循环轮播中的数学问题" class="headerlink" title="循环轮播中的数学问题"></a>循环轮播中的数学问题</h1><p>这里将要说明的问题，并不是针对 swiper ，而是轮播本身。前段时间遇到循环轮播的问题，花费了不少时间，经点拨，发现这是一个简单的数学问题，突然感觉，这么多年数学白学了。</p>
<p>轮播场景是，一个容器中能容得下 7 个 slide ，现有 9 个 slide 需要在容器中进行循环轮播，并且当点击到哪个 slide 时，就滑至哪个 slide ，求解当点击某个 slide，需要滑动几次才能滑到该 slide？（每次滑动时，下一个 slide 向前滑动一个位置）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>] <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span>] <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> [<span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> [<span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> [<span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>前三项，用被点击的 slide 的索引，减去当前活动 slide 的索引，即可得到；</p>
<p>第四项，4 ——&gt; 1，9 - 4 + 1；</p>
<p>第五项，5 ——&gt; 1，9 - 5 +1；5 ——&gt; 2，9 - 5 + 2；</p>
<p>第五项，6 ——&gt; 1，9 - 6 +1；6 ——&gt; 2，9 - 6 + 2；6 ——&gt; 3，9 - 6 + 3；</p>
<p>a ——&gt; b，（a &lt; b），9 - a + b = 9 + (b -a)</p>
<p>当前活动 slide 的索引为 curIndex，目标 slide 的索引为 objIndex，需要滑动的次数为 nextTimes 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> valueGap = objIndex - curIndex</span><br><span class="line"><span class="keyword">if</span> (valueGap) &#123;</span><br><span class="line">    nextTimes = valueGap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nextTimes = valueGap + slides.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nextTimes</span><br></pre></td></tr></table></figure>
<p>综上：</p>
<p><strong>当前索引 小于 目标索引时，滑动次数 即为 目标索引 减去 当前索引；</strong></p>
<p><strong>当前索引 大于 目标索引时，滑动次数 为 轮播 slide 总数 加上 当前索引 减去 目标索引；</strong></p>
]]></content>
      <tags>
        <tag>Swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue component</title>
    <url>/blog/2019/01/05/vue-component/</url>
    <content><![CDATA[<h3 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h3><p>vue组件示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： </p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#components-demo'</span> &#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是，没有 <code>el</code>这种根实例特有的选项 </p>
<p>另外要注意的是，<strong>一个组件的 data 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若组件与Vue实例一样，data选项为对象，则在组件进行复用时，同一组件的多个实例会相互影响：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/20190105.gif" alt></p>
<h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>用 <code>Vue.component</code> 创建的组件，为<strong>全局注册</strong>。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">  <span class="comment">// ... 选项 ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>全局注册</strong>的组件，在注册之后可以被用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中，或所有子组件中，包阔注册的这几个组件，也可以在各自内部相互使用。如 ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'component-a'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'component-b'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'component-c'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-c</span>&gt;</span><span class="tag">&lt;/<span class="name">component-c</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p>
<p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件，然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">    <span class="string">'component-b'</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于 <code>components</code> 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。 </p>
<p>注意：<strong>局部注册的组件在其子组件中不可用</strong>。例如，如果你希望 <code>ComponentA</code> 在 <code>ComponentB</code> 中可用，则你需要这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vue-cli构建的项目中进行模块化开发时，通常我们创建一个 <code>components</code> 目录，并将每个组件放置在其各自的文件中。然后在局部注册之前导入每个你想使用的组件。例如，在一个假设的 <code>ComponentB.js</code> 或 <code>ComponentB.vue</code> 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ComponentB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 <code>ComponentA</code> 和 <code>ComponentC</code> 都可以在 <code>ComponentB</code> 的模板中使用了。注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>currentTabComponent</code> 可以为<strong>已注册</strong>组件的名字，或一个组件对象。例如，一个点击按钮切换组件的demo，分别用这两种方式来实现：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019-01-05_154951.jpg" alt="1546674595871"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用已注册组件的名字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'tab-home'</span>, &#123; </span></span><br><span class="line"><span class="xml">	template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Home component<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'tab-posts'</span>, &#123; </span></span><br><span class="line"><span class="xml">	template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Posts component<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'tab-archive'</span>, &#123; </span></span><br><span class="line"><span class="xml">	template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Archive component<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">'#dynamic-component-demo'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    currentTab: <span class="string">'Home'</span>,</span></span><br><span class="line"><span class="javascript">    tabs: [<span class="string">'Home'</span>, <span class="string">'Posts'</span>, <span class="string">'Archive'</span>]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line"><span class="javascript">    currentTabComponent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="string">'tab-'</span> + <span class="keyword">this</span>.currentTab.toLowerCase()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dynamic-component-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"tab in tabs"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"tab"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:class</span>=<span class="string">"['tab-button', &#123; active: currentTab === tab &#125;]"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:click</span>=<span class="string">"currentTab = tab"</span></span></span><br><span class="line"><span class="tag">  &gt;</span>&#123;&#123; tab &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"tab"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用一个组件对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> tabs = [</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    name: <span class="string">'Home'</span>, </span></span><br><span class="line">    component: &#123; </span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Home component<span class="tag">&lt;/<span class="name">div</span>&gt;</span>' </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    name: <span class="string">'Posts'</span>,</span></span><br><span class="line">    component: &#123;</span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Posts component<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    name: <span class="string">'Archive'</span>,</span></span><br><span class="line">    component: &#123;</span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Archive component<span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">'#dynamic-component-demo'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line">  	tabs: tabs,</span><br><span class="line">    currentTab: tabs[0]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dynamic-component-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"tab in tabs"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"tab.name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:class</span>=<span class="string">"['tab-button', &#123; active: currentTab.name === tab.name &#125;]"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:click</span>=<span class="string">"currentTab = tab"</span></span></span><br><span class="line"><span class="tag">  &gt;</span>&#123;&#123; tab.name &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:is</span>=<span class="string">"currentTab.component"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"tab"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.nextTick 监听 DOM 渲染完毕</title>
    <url>/blog/2018/07/17/vue-Vue.nextTick/</url>
    <content><![CDATA[<p>在 vue 项目中使用 swiper、echarts 等插件时，经常会遇到这样的需求，页面首次加载时不显示 swiper、echarts，进行交互操作后再显示出 swiper、echarts 。而 swiper 和 echarts 的实例化，都需要在 DOM 渲染完毕后才能进行，于是需要一个方法来监听 DOM 渲染完毕，这个方法就是 <code>Vue.nextTick()</code> 。</p>
<p>关于 <code>Vue.nextTick()</code> ，官方的解释为：</p>
<blockquote>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 </p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'渲染已经完成'</span>)</span><br><span class="line">      <span class="comment">// swiper初始化</span></span><br><span class="line">      that.instance = that.generateSwiper()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>computed、watch、状态管理 三者结合使用</title>
    <url>/blog/2018/07/15/vue-computed%E3%80%81watch%E3%80%81%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%20%E4%B8%89%E8%80%85%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>myTest.vue 文件 ，vue 实例配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	name: <span class="string">'home'</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">			myNum: <span class="number">0</span>,</span><br><span class="line">             sum: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        num () &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.$store.state.testNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        num () &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">this</span>.addNum()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addNum () &#123;</span><br><span class="line">            <span class="keyword">this</span>.sum = <span class="keyword">this</span>.myNum + <span class="keyword">this</span>.num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当状态管理 state 中的 testNum 值发生改变时，这里的计算属性 computed 中的 num 就会随之变化；watch 监听到 num 的变化，就会执行 <code>addNum()</code> 方法。</p>
<a id="more"></a>
<hr>
<p>store.js 文件，状态管理配置如下（<strong>注意：mutations 方法中传参的定义</strong>）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        testNum: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        updateTestNum (state, num) &#123; <span class="comment">// 传入参数num</span></span><br><span class="line">            state.testNum = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<hr>
<p>App.vue 文件，vue 实例配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> width = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">             <span class="comment">// 执行 mutations 中的 updateTestNum 方法，并传入参数 width</span></span><br><span class="line">            that.$store.commit(<span class="string">'updateTestNum'</span>, width) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当浏览器窗口宽度发生变化时，就执行状态管理 store 中的方法，更新 testNum 的值。</p>
<hr>
<p>这一整个过程可归纳为如下：</p>
<p>​    浏览器窗口宽度变化；</p>
<p>——&gt;</p>
<p>​    App.vue 中监听到 onresize 事件，更新 store 中 testNum 的值；</p>
<p>——&gt;</p>
<p>​    myTest.vue 计算属性中的 num 发生变化，watch 到 num 变化，执行 <code>addNum()</code> 方法，更新 data 中 sum 的值；</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>eventBus</title>
    <url>/blog/2018/09/02/vue-eventBus/</url>
    <content><![CDATA[<p>前面有提到父子组件之间的通信。</p>
<p>子组件的 props 属性，可以实现父向子传递数据；而利用 ref 又可以在父组件中调用子组件内的方法。</p>
<p>利用 emit 可以在子组件内触发父组件中的事件，通过给事件传参还能实现子向父传递数据；</p>
<p>这里又有另外一种方法，可以实现不同组件之间事件触发、监听。</p>
<p>在 main.js 里面，初始化 app 之前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$eventHub = <span class="keyword">new</span> Vue() <span class="comment">// 创建消息事件总线</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在组件1里面触发事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$eventHub.$emit(<span class="string">'switchCompany'</span>)</span><br></pre></td></tr></table></figure>
<p>在组件2里面监听事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    this.$eventHub.$on(&apos;switchCompany&apos;, () =&gt; &#123;</span><br><span class="line">        console.log(&apos;监听到switchCompany事件触发&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发事件并传参：</p>
<p>触发事件的组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'sourceCode'</span>, <span class="keyword">this</span>.sourceCodeList[<span class="keyword">this</span>.currenTab].value)</span><br></pre></td></tr></table></figure>
<p>监听事件的组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$eventHub.$on(<span class="string">'sourceCode'</span>, (msg) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.carStyle = msg</span><br><span class="line">    <span class="keyword">this</span>.getData()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex 中的 dispatch 与 commit</title>
    <url>/blog/2018/07/29/vue-Vuex%E4%B8%AD%E7%9A%84dispatch%E4%B8%8Ecommit/</url>
    <content><![CDATA[<p>mutation 通过 store.commit 方法触发，mutation 是更改 Vuex 的 store 中状态的唯一方法，并且 mutation 是同步的操作。</p>
<p>action 通过 store.dispatch 方法触发，提交的是 mutation ，间接地更新状态，action 可以包含任意异步操作。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。 </p>
<p>在组件中调用 mutation 和 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'increment'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实践中，我们会经常用到 ES2015 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 action 内部执行<strong>异步</strong>操作： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 mutation 向 <code>store.commit</code> 传入额外的参数 ，action 也可以向 <code>store.commit</code> 传入额外的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/blog/2018/05/06/vue-Vuex/</url>
    <content><![CDATA[<p>Vuex —— 状态（变量）管理，每个组件的 data 中的变量即为状态。 Vuex 可以让变量在多个页面中使用。</p>
<h2 id="Vuex-核心"><a href="#Vuex-核心" class="headerlink" title="Vuex 核心"></a>Vuex 核心</h2><ul>
<li><p>State，数据源</p>
</li>
<li><p>Getters</p>
</li>
<li><p>Mutations，</p>
</li>
<li><p>Actions</p>
</li>
<li><p>Modules</p>
</li>
</ul>
<a id="more"></a>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State 是 vuex 中唯一的数据源，存放在 state 中的数据，可以在任何页面中使用。单一状态树。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">    template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    computed: &#123; <span class="comment">//计算属性</span></span><br><span class="line">        count () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this.$store</code> 获取到 vuex 对象，<code>this.$store.state.count</code>  获取到 vuex state 中的 count 属性；</p>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>通过 Getter 可以派生出一些新的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        todos: [</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">"内容1"</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">"内容2"</span>, done <span class="literal">false</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个 doneTodos 变量，其数据为 todos 中 done 属性为 true 的元素</span></span><br><span class="line">    getters: &#123;</span><br><span class="line">        doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>Mutations 是更改 Vuex 的 store 中状态的唯一方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++;  //更新count的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>调用 mutations 中的方法来更新状态：<code>store.commit(&#39;increment&#39;)</code></p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 提交 mutations，间接地更新状态。Action 可包含任意异步操作，而 mutation 执行的是同步操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    actions: &#123;</span><br><span class="line">        increment (context) &#123;</span><br><span class="line">            context.commit(<span class="string">'increment);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>当执行完 actions 中的 increment 后，就会调用 mutations 中的 increment 方法，来令状态中的 count ++。action 可包含任意异步操作，即可以在 actions 的 increment 方法中写异步代码来执行 <code>context.commit(&#39;increment&#39;)</code>，而 mutations 中 increment 方法中的代码只能是同步执行的。</p>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>模块化，面对复杂的应用程序，当管理的状态比较多时，我们需要将 Vuex 的 store 对象分割成模块（modules）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.State(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 核心概览</title>
    <url>/blog/2018/05/01/vue-vue%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h3 id="Vue-核心概览"><a href="#Vue-核心概览" class="headerlink" title="Vue 核心概览"></a>Vue 核心概览</h3><p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_102525.png" alt></p>
<a id="more"></a>
<h3 id="通过MVVM的数据绑定实现自动同步"><a href="#通过MVVM的数据绑定实现自动同步" class="headerlink" title="通过MVVM的数据绑定实现自动同步"></a>通过MVVM的数据绑定实现自动同步</h3><p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_103049.png" alt></p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_103335.png" alt></p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p><code>Object.defineProperty()</code>  函数实现双向数据绑定，<code>Object.defineProperty()</code> 函数会给一个对象扩展属性。如下面的情形，会在 <code>obj</code>  对象上添加 <code>get</code> 和 <code>set</code> 属性（方法）。set 和 get 是属于 Object.defineProperty() 函数内部的 api ，当 <code>obj</code> 的 <code>userName</code> 属性发生改变时（被赋值时），会触发 <code>obj</code> 中的 <code>set</code> 方法；当获取 <code>obj</code> 的 <code>userName</code> 属性时（ <code>var a = obj.userName</code>），会触发 <code>obj</code> 中的 <code>get</code> 方法；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Object.defineProperty实现数据双向绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"userName"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"uName"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        pwd: <span class="string">"123456"</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// Object.defineProperty()函数给一个对象扩展属性</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//给obj对象扩展一个"userName"属性，属性的描述为&#123;get: ... , set: ...&#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"userName"</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//value: 'river',</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">get</span>: function () &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"get init"</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="keyword">set</span>: function (val) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">" set init"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"uName"</span>).innerText = val;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//监听键盘事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"userName"</span>).addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//document.getElementById("uName").innerText = event.target.value;</span></span></span><br><span class="line">        obj.userName = event.target.value;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>event.target.value 触发事件的对象的值</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 基础语法</title>
    <url>/blog/2018/05/02/vue-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><ul>
<li>Mustache语法：{{ msg }}</li>
<li>Html赋值：v-html = “”</li>
<li>绑定属性：v-bind:id = “”</li>
<li>使用表达式：{{ ok ? "YES" : "NO" }}</li>
<li>文本赋值：v-text = “”</li>
<li>指令：v-if = “”</li>
<li>过滤器：{{ message || capitalize}}，v-bind:id=”rawId | formatId”</li>
</ul>
<a id="more"></a>
<h3 id="Class-和-style-绑定"><a href="#Class-和-style-绑定" class="headerlink" title="Class 和 style 绑定"></a>Class 和 style 绑定</h3><ul>
<li>对象语法：v-bind:class=”{ active: isActive, ‘text-danger’: hasError }”</li>
<li>数组语法：<code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code> </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    activeClass: <span class="string">"active"</span>,</span><br><span class="line">    errorClass: <span class="string">"text-danger"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>style 绑定对象语法：<code>v-bind:style=&quot;{color:activeColor, fontSize: fontSize + &#39;px&#39;}&quot;</code></li>
</ul>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ul>
<li>v-if</li>
<li>v-else</li>
<li>v-else-if</li>
<li>v-show</li>
<li>v-cloak</li>
</ul>
<p>v-if 控制dom是否渲染，v-show 控制隐藏/显示</p>
<h3 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h3><ul>
<li>v-on:click=”greet”，或 @click=”greet”</li>
<li>v-on:click.stop、v-on:click.stop.prevent、v-on:click-self、v-on:click-once</li>
<li>v-on:keyup.enter<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
</li>
</ul>
<h3 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h3><p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_145403.png" alt></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/blog/2018/06/16/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>Vue 官网的生命钩子示意图：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/lifecycle.png" alt="Vue生命周期"></p>
<a id="more"></a>
<p>通过代码来测试 Vue 生命周期的执行顺序：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Vue.js v2.6.8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">          message : <span class="string">"vue lifecycle"</span> </span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">       beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'beforeCreate===============》'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeCreate this="</span>, <span class="keyword">this</span>); <span class="comment">// &#123;object&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeCreate this.$el="</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined，，DOM显示&#123;&#123; message &#125;&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeCreate this.$data="</span>, <span class="keyword">this</span>.$data); <span class="comment">// undefined </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeCreate this.message="</span>, <span class="keyword">this</span>.message); <span class="comment">// undefined </span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'created===============》'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"created this.$el="</span>, <span class="keyword">this</span>.$el); <span class="comment">// undefined，DOM显示&#123;&#123; message &#125;&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"created this.$data="</span>, <span class="keyword">this</span>.$data); <span class="comment">// &#123;message:"vue lifecycle"&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"created this.message="</span>, <span class="keyword">this</span>.message); <span class="comment">// vue lifecycle</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'beforeMount===============》'</span>);</span></span><br><span class="line"><span class="xml">            console.log("beforeMount this.$el=", this.$el); // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>，DOM显示&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeMount this.$data="</span>, <span class="keyword">this</span>.$data); <span class="comment">// &#123;message:"vue lifecycle"&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeMount this.message="</span>, <span class="keyword">this</span>.message); <span class="comment">// vue lifecycle</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'mounted===============》'</span>);</span></span><br><span class="line"><span class="xml">            console.log("mounted this.$el=", this.$el); // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>vue lifecycle<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>，DOM显示vue lifecycle</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"mounted this.$data="</span>, <span class="keyword">this</span>.$data); <span class="comment">// &#123;message:"vue lifecycle"&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"mounted this.message="</span>, <span class="keyword">this</span>.message); <span class="comment">// vue lifecycle</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">      </span><br><span class="line"><span class="javascript">        beforeUpdate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'beforeUpdate===============》'</span>);</span></span><br><span class="line"><span class="xml">            console.log("beforeUpdate this.$el=", this.$el); // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>vue lifecycle<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> ，DOM显示vue lifecycle</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeUpdate this.$data="</span>, <span class="keyword">this</span>.$data); <span class="comment">// &#123;message:"hello"&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeUpdate this.message="</span>, <span class="keyword">this</span>.message); <span class="comment">// hello</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'updated===============》'</span>);</span></span><br><span class="line"><span class="xml">            console.log("updated this.$el=", this.$el); // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> ，DOM显示hello</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"updated this.$data="</span>, <span class="keyword">this</span>.$data); <span class="comment">// &#123;message:"hello"&#125;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"updated this.message="</span>, <span class="keyword">this</span>.message); <span class="comment">// hello</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'beforeDestroy===============》'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeDestroy this.$el="</span>, <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeDestroy this.$data="</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"beforeDestroy this.message="</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        destroyed: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'destroyed===============》'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"destroyed this.$el="</span>, <span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"destroyed this.$data="</span>, <span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"destroyed this.message="</span>, <span class="keyword">this</span>.message);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019-03-12_222432.jpg" alt></p>
<p><strong>注意</strong>：<code>console.log</code> 打印引用类型数据时，显示的是最终值。这里是用 <code>debug</code> 来查看。</p>
<p>改变 data 中 message 的值，触发 <code>beforeUpdate</code> 和 <code>updated</code> 钩子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.$data.message = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>beforeUpdate</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'beforeUpdate this.$el= &lt;div id="app"&gt;&lt;p&gt;vue lifecycle&lt;/p&gt;&lt;/div&gt;'</span> <span class="comment">// DOM显示vue lifecycle</span></span><br><span class="line"><span class="string">'beforeUpdate this.$data= &#123;message: "hello"&#125;'</span></span><br><span class="line"><span class="string">'beforeUpdate this.message= hello'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>updated</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'updated this.$el= &lt;div id="app"&gt;&lt;p&gt;hello&lt;/p&gt;&lt;div&gt;'</span> <span class="comment">// DOM显示hello</span></span><br><span class="line"><span class="string">'updated this.$data= &#123;message: "hello"&#125;'</span></span><br><span class="line"><span class="string">'updated this.message= hello'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019-03-12_222624.jpg" alt></p>
<p>当声明一个 Vue 实例时，会先执行这几个生命钩子：beforeCreate ——&gt; created ——&gt; beforeMount ——&gt; mounted ；</p>
<ul>
<li>beforeCreate，dom 元素 <code>el</code> 和 data 都未初始化；</li>
<li>created，初始化 data；</li>
<li>beforeMount，初始化 dom 元素 <code>el</code>；</li>
</ul>
<p>当 data 中的 message 发生改变时，会执行 beforeUpdate 和 updated；并且在 beforeUpdate 状态， data 和 <code>el</code> 的内容就已经改变；</p>
<ul>
<li><p>beforeCreate </p>
<p>实例初始化之后，this 指向创建的实例，不能访问到data、computed、watch、methods上的数据和方法（undefined）。</p>
</li>
<li><p>created </p>
<p>实例创建完成，可访问 data、computed、watch、methods上的方法和数据，未挂载到 DOM，不能访问到$el 属性，$ref 属性内容为空数组。</p>
<p>常用于简单的ajax请求。</p>
</li>
<li><p>beforeMount </p>
<p>在挂载开始之前被调用，创建 VDOM，可访问 $el，$el 内数据为 <code>{message}</code>。beforeMount 之前，会找到对应的 template，并编译成 render 函数。</p>
</li>
<li><p>mounted </p>
<p>将 VDOM 渲染为真实 DOM 并且渲染数据。vue 实例挂载到 DOM上，响应式数据关联的 DOM 渲染完毕，此时可以通过 DOM API获取到DOM节点，$ref 属性可以访问。</p>
</li>
<li><p>beforeUpdate </p>
<p>与模板（template）关联的数据发生改变时，会触发 beforeUpdate 和 updated。数据改变——导致虚拟DOM的改变——调用 beforeUpdate 和 updated 这两个生命钩子去改变视图。</p>
<p>发生在虚拟DOM打补丁之前。</p>
<p>此时，数据改变了，但是 DOM 还未更新。适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
</li>
<li><p>updated</p>
<p>虚拟 DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM的操作。</p>
<p>避免在这个钩子函数中操作数据，可能陷入死循环。</p>
</li>
<li><p>beforeDestroy</p>
<p>实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。</p>
<p>常用于销毁定时器、解绑全局事件、销毁插件对象等操作。</p>
</li>
<li><p>destroyed</p>
<p>实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</p>
</li>
</ul>
<p>组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。（页面created，组件created，组件mounted，页面mounted。）</p>
<p>.</p>
<hr>
<p>【参考链接】：</p>
<p><a href="https://juejin.im/entry/5aee8fbb518825671952308c" target="_blank" rel="noopener">https://juejin.im/entry/5aee8fbb518825671952308c</a></p>
<p><a href="https://juejin.im/post/5afd7eb16fb9a07ac5605bb3" target="_blank" rel="noopener">https://juejin.im/post/5afd7eb16fb9a07ac5605bb3</a></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/blog/2019/04/30/vue-%E8%99%9A%E6%8B%9FDOM/</url>
    <content><![CDATA[<h3 id="virtual-dom（虚拟-dom）"><a href="#virtual-dom（虚拟-dom）" class="headerlink" title="virtual dom（虚拟 dom）"></a>virtual dom（虚拟 dom）</h3><p>Virtual DOM 产生的原因是，浏览器中的 DOM 是很“昂贵”的，为了更直观的感受，我们可以把一个简单的 div 元素的属性都打印出来，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> item, result = [];</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> div) &#123;</span><br><span class="line">  result.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(result.length); <span class="comment">// 240</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为打印内容</span></span><br><span class="line">[<span class="string">"align"</span>, <span class="string">"title"</span>, <span class="string">"lang"</span>, <span class="string">"translate"</span>, <span class="string">"dir"</span>, <span class="string">"dataset"</span>, <span class="string">"hidden"</span>, <span class="string">"tabIndex"</span>, <span class="string">"accessKey"</span>, <span class="string">"draggable"</span>, <span class="string">"spellcheck"</span>, <span class="string">"autocapitalize"</span>, <span class="string">"contentEditable"</span>, <span class="string">"isContentEditable"</span>, <span class="string">"inputMode"</span>, <span class="string">"offsetParent"</span>, <span class="string">"offsetTop"</span>, <span class="string">"offsetLeft"</span>, <span class="string">"offsetWidth"</span>, <span class="string">"offsetHeight"</span>, <span class="string">"style"</span>, <span class="string">"innerText"</span>, <span class="string">"outerText"</span>, <span class="string">"oncopy"</span>, <span class="string">"oncut"</span>, <span class="string">"onpaste"</span>, <span class="string">"onabort"</span>, <span class="string">"onblur"</span>, <span class="string">"oncancel"</span>, <span class="string">"oncanplay"</span>, <span class="string">"oncanplaythrough"</span>, <span class="string">"onchange"</span>, <span class="string">"onclick"</span>, <span class="string">"onclose"</span>, <span class="string">"oncontextmenu"</span>, <span class="string">"oncuechange"</span>, <span class="string">"ondblclick"</span>, <span class="string">"ondrag"</span>, <span class="string">"ondragend"</span>, <span class="string">"ondragenter"</span>, <span class="string">"ondragleave"</span>, <span class="string">"ondragover"</span>, <span class="string">"ondragstart"</span>, <span class="string">"ondrop"</span>, <span class="string">"ondurationchange"</span>, <span class="string">"onemptied"</span>, <span class="string">"onended"</span>, <span class="string">"onerror"</span>, <span class="string">"onfocus"</span>, <span class="string">"oninput"</span>, <span class="string">"oninvalid"</span>, <span class="string">"onkeydown"</span>, <span class="string">"onkeypress"</span>, <span class="string">"onkeyup"</span>, <span class="string">"onload"</span>, <span class="string">"onloadeddata"</span>, <span class="string">"onloadedmetadata"</span>, <span class="string">"onloadstart"</span>, <span class="string">"onmousedown"</span>, <span class="string">"onmouseenter"</span>, <span class="string">"onmouseleave"</span>, <span class="string">"onmousemove"</span>, <span class="string">"onmouseout"</span>, <span class="string">"onmouseover"</span>, <span class="string">"onmouseup"</span>, <span class="string">"onmousewheel"</span>, <span class="string">"onpause"</span>, <span class="string">"onplay"</span>, <span class="string">"onplaying"</span>, <span class="string">"onprogress"</span>, <span class="string">"onratechange"</span>, <span class="string">"onreset"</span>, <span class="string">"onresize"</span>, <span class="string">"onscroll"</span>, <span class="string">"onseeked"</span>, <span class="string">"onseeking"</span>, <span class="string">"onselect"</span>, <span class="string">"onstalled"</span>, <span class="string">"onsubmit"</span>, <span class="string">"onsuspend"</span>, <span class="string">"ontimeupdate"</span>, <span class="string">"ontoggle"</span>, <span class="string">"onvolumechange"</span>, <span class="string">"onwaiting"</span>, <span class="string">"onwheel"</span>, <span class="string">"onauxclick"</span>, <span class="string">"ongotpointercapture"</span>, <span class="string">"onlostpointercapture"</span>, <span class="string">"onpointerdown"</span>, <span class="string">"onpointermove"</span>, <span class="string">"onpointerup"</span>, <span class="string">"onpointercancel"</span>, <span class="string">"onpointerover"</span>, <span class="string">"onpointerout"</span>, <span class="string">"onpointerenter"</span>, <span class="string">"onpointerleave"</span>, <span class="string">"onselectstart"</span>, <span class="string">"onselectionchange"</span>, <span class="string">"nonce"</span>, <span class="string">"click"</span>, …]</span><br><span class="line"><span class="number">240</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以看到，真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。尽量减少 DOM 操作，而不是“推倒从来”（清空 DOM 节点内所有内容，再次添加所有内容）。</p>
<p>而 Virtual DOM 就是用一个原生的 JS 对象去模拟一个 DOM 节点，DOM 变化的对比，放在 JS 层来做（JS 是图灵完备语言，可做逻辑判断和算法），仅对数据更新的 DOM 进行重新渲染，提高重绘性能，所以它比创建一个 DOM 的代价要小很多。（相对来说 JS 运行效率高）</p>
<p>HTML DOM：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虚拟 DOM：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  	tag: <span class="string">'ul'</span>,</span><br><span class="line">  	attrs: &#123;</span><br><span class="line">    	id: <span class="string">'list'</span></span><br><span class="line">  	&#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        tag: <span class="string">'li'</span>,</span><br><span class="line">        attrs: &#123;<span class="attr">className</span>: <span class="string">'item'</span>&#125;,</span><br><span class="line">        children: [<span class="string">'item 1'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        tag: <span class="string">'li'</span>,</span><br><span class="line">        attrs: &#123;<span class="attr">className</span>: <span class="string">'item'</span>&#125;,</span><br><span class="line">        children: [<span class="string">'item 2'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Virtual-DOM的核心API"><a href="#Virtual-DOM的核心API" class="headerlink" title="Virtual DOM的核心API"></a>Virtual DOM的核心API</h3><p>Vue.js 中 Virtual DOM 的实现，借鉴了一个开源库 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a> 。</p>
<p><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a>- h 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">'snabbdom/h'</span>).default; <span class="comment">// helper function for creating vnodes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vnode = h(<span class="string">'div#container.two.classes'</span>, &#123;<span class="attr">on</span>: &#123;<span class="attr">click</span>: someFn&#125;&#125;, [</span><br><span class="line">  h(<span class="string">'span'</span>, &#123;<span class="attr">style</span>: &#123;<span class="attr">fontWeight</span>: <span class="string">'bold'</span>&#125;&#125;, <span class="string">'This is bold'</span>),</span><br><span class="line">  <span class="string">' and this is just normal text'</span>,</span><br><span class="line">  h(<span class="string">'a'</span>, &#123;<span class="attr">props</span>: &#123;<span class="attr">href</span>: <span class="string">'/foo'</span>&#125;&#125;, <span class="string">'I\'ll take you places!'</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span></span><br><span class="line">patch(container, vnode); <span class="comment">// 初次渲染</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newVnode = h(<span class="string">'div#container.two.classes'</span>, &#123;<span class="attr">on</span>: &#123;<span class="attr">click</span>: anotherEventHandler&#125;&#125;, [</span><br><span class="line">  h(<span class="string">'span'</span>, &#123;<span class="attr">style</span>: &#123;<span class="attr">fontWeight</span>: <span class="string">'normal'</span>, <span class="attr">fontStyle</span>: <span class="string">'italic'</span>&#125;&#125;, <span class="string">'This is now italic type'</span>),</span><br><span class="line">  <span class="string">' and this is still just normal text'</span>,</span><br><span class="line">  h(<span class="string">'a'</span>, &#123;<span class="attr">props</span>: &#123;<span class="attr">href</span>: <span class="string">'/bar'</span>&#125;&#125;, <span class="string">'I\'ll take you places!'</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Second `patch` invocation</span></span><br><span class="line">patch(vnode, newVnode); <span class="comment">// Snabbdom efficiently updates the old view to the new state（数据改变后再次渲染）</span></span><br></pre></td></tr></table></figure>
<p>h函数生成一个vnode。</p>
<p>snabbdom - patch 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vnode = h(<span class="string">'ul#list'</span>, &#123;&#125;, [</span><br><span class="line">  h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item 1'</span>),</span><br><span class="line">  h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item 2'</span>),</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line">patch(container, vnode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟改变</span></span><br><span class="line"><span class="keyword">var</span> btnChange = <span class="built_in">document</span>.getElementById(<span class="string">'btn-change'</span>);</span><br><span class="line">btnChange.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newVnode = h(<span class="string">'ul#list'</span>, &#123;&#125;, [</span><br><span class="line">    h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item 1'</span>),</span><br><span class="line">    h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item b'</span>),</span><br><span class="line">    h(<span class="string">'li.item'</span>, &#123;&#125;, <span class="string">'item 3'</span>)</span><br><span class="line">  ]);</span><br><span class="line">  patch(vnode, newVnode);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>patch函数将vnode渲染到dom节点中。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli webpack 配置</title>
    <url>/blog/2018/05/28/vue-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="font-awesome-字体引用"><a href="#font-awesome-字体引用" class="headerlink" title="font-awesome 字体引用"></a>font-awesome 字体引用</h3><p>若在 vue 组件中引用 font-awesome 字体，当上传生产包至云端时，会出现 .woff2 等文件加载错误。 更好的方式是直接在根目录的 index.html 文件中进行引用。</p>
<a id="more"></a>
<h3 id="去掉打包文件中的-hash"><a href="#去掉打包文件中的-hash" class="headerlink" title="去掉打包文件中的 hash"></a>去掉打包文件中的 hash</h3><p>vue-cli webpack 默认打包时会在文件后加 hash，每次改动代码执行 <code>run build</code> 都会先清空 dist 目录下的文件，生成的文件会采用新的 hash ，导致文件名变化，这对于使用 SVN 版本管理的用户很不方便。</p>
<p>可以通过以下配置来禁止向打包后的文件名中加入 hash，打开 <code>build</code> 文件夹下的 <code>webpack.prod.conf.js</code> ，去掉配置中的<code>.[chunkhash]</code>即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filename: utils.assetsPath('js/[name].[chunkhash].js'),  //lj-</span></span><br><span class="line"><span class="comment">// chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')</span></span><br><span class="line">filename: utils.assetsPath(<span class="string">'js/[name].js'</span>), </span><br><span class="line">chunkFilename: utils.assetsPath(<span class="string">'js/[id].js'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-28_233554.png" alt></p>
<h3 id="请求代理"><a href="#请求代理" class="headerlink" title="请求代理"></a>请求代理</h3><p>开发环境下，利用 <code>proxyTable</code> 代理跨域请求。 <code>config\index.js</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dev: &#123;</span><br><span class="line">        proxyTable: &#123;</span><br><span class="line">            <span class="string">'/goods'</span>:&#123; <span class="comment">//当访问goods时将其转到目标地址</span></span><br><span class="line">                target:<span class="string">'http://vuemail.leanapp.cn'</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">                <span class="comment">//   '^/goods': ''</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">        &#125;, </span><br><span class="line">    &#125;,</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 项目初始化</title>
    <url>/blog/2018/05/02/vue-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装淘宝镜像：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>安装 vue ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm install vue --save</span><br></pre></td></tr></table></figure>
<p> vue-cli 构建 SPA 应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g vue-cli</span><br><span class="line">vue init webpack-simple demo</span><br><span class="line">vue init webpack demo2</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="vue-init-webpack-simple-demo"><a href="#vue-init-webpack-simple-demo" class="headerlink" title="vue init webpack-simple demo"></a><code>vue init webpack-simple demo</code></h3><p>使用 <code>vue init webpack-simple demo</code>  时生成的文件目录：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_112327.png" alt></p>
<h3 id="vue-init-webpack-demo"><a href="#vue-init-webpack-demo" class="headerlink" title="vue init webpack demo"></a><code>vue init webpack demo</code></h3><p>使用 <code>vue init webpack demo</code>  时生成的文件目录：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_112557.png" alt></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_113912.png" alt></p>
<p><code>/build</code>  打包配置文件；</p>
<p> <code>/config</code> 项目配置文件；</p>
<p><code>/dist</code> 存放 run build 打包生成的文件 ；</p>
<p><code>/node_modules</code>  npm 安装的模块；</p>
<p> <code>/src</code> 项目源代码， <code>/src/App.vue</code>  入口组件， <code>/src/main.js</code>  项目入口文件；<code>/static</code> 图片等静态资源；</p>
<p><code>.babelrc</code> 解析es6语法的配置；</p>
<p><code>.editorconfig</code> 编辑器的配置；</p>
<p><code>.gitignore</code> 配置 git 提交时忽略的文件；</p>
<p><code>.postcssrc.js</code> 配置 html 添加前缀；</p>
<p><code>index.html</code> 单页面入口；</p>
<p><code>package-lock.json</code> 项目描述（指定依赖源）；</p>
<p><code>package.json</code> 项目描述；</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 路由</title>
    <url>/blog/2018/05/03/vue-%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>路由是根据不同的 url 地址展示不同的内容或页面。</p>
<p>前端路由是把不同路由对应的内容或页面的任务交给前端来做，以前是通过服务端根据 url 的不同返回不同的页面来实现。</p>
<h4 id="前端路由应用场景"><a href="#前端路由应用场景" class="headerlink" title="前端路由应用场景"></a>前端路由应用场景</h4><p>在单页面应用，大部分页面结构不变，只改变部分内容时使用。</p>
<h4 id="前端路由的优缺点"><a href="#前端路由的优缺点" class="headerlink" title="前端路由的优缺点"></a>前端路由的优缺点</h4><ul>
<li>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</li>
<li>缺点：<ul>
<li>不利于SEO。</li>
<li>使用浏览器的前进、后退，会重新发送请求，没能合理利用缓存。</li>
<li>单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>vue-router用来构建SPA</p>
<p><code>&lt;router-link&gt;&lt;/router-link&gt;</code> (类似于 a 标签) 或  <code>this.$router.push({ path:&quot;&quot; })</code>（编程式路由，利用 js 来让页面进行跳转）。</p>
<p><code>&lt;router-view&gt;&lt;/router-view&gt;</code> ，根据跳转 url 渲染内容，与页面跳转配合使用。</p>
<h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>$route.params 可以拿到 url 中传入的参数。vue-route 对象实质上是对浏览器 history 的封装。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-05-20_184016.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GoodsList <span class="keyword">from</span> <span class="string">'./../views/GoodsList.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/goods/:goodsId'</span>,</span><br><span class="line">      name: <span class="string">'GoodsList'</span>,</span><br><span class="line">      component: GoodsList </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; $route.params.goodsId &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mode 属性可指定路由的模式为 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>, <span class="comment">//指定路由模式为history</span></span><br><span class="line">  <span class="comment">//mode: 'hash',</span></span><br><span class="line">  routes: [</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>路由嵌套路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="keyword">import</span> GoodsList <span class="keyword">from</span> <span class="string">'./../views/GoodsList.vue'</span></span><br><span class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./../views/Title.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/goods'</span>,</span><br><span class="line">      name: <span class="string">'GoodsList'</span>,</span><br><span class="line">      component: GoodsList,</span><br><span class="line">      children: [&#123;</span><br><span class="line">          path: <span class="string">'title'</span>, <span class="comment">// 访问/goods/title</span></span><br><span class="line">      	  name: <span class="string">'title'</span>,</span><br><span class="line">      	  component：Title</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--GoodsList.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/goods/title"</span>&gt;</span>显示商品标题<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h3><p>通过 js 来实现页面的跳转，<code>$router.push(&quot;name&quot;)</code> , <code>$router.push({path: &quot;name&quot;})</code> , <code>$router.push({path: &quot;name?a=123&quot;})</code> 或 <code>$router.push({path:&quot;name&quot;,query:{a: 123}})</code>, <code>$router.go(1)</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--GoodsList.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>跳转至购物车页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        data()&#123;&#125;,</span><br><span class="line">        method: &#123;</span><br><span class="line">            jump()&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">//this.$router.push("/cart");</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//this.$router.push(&#123;path: "/cart"&#125;);</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">"/cart?goodsId=123"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Cart.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;$route.query.goodsId&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>$route.query.goodsId</code> 获取 url 中传递的参数。</p>
<h3 id="命名路由和命名视图"><a href="#命名路由和命名视图" class="headerlink" title="命名路由和命名视图"></a>命名路由和命名视图</h3><p>给路由定义不同的名字，根据名字进行匹配。给不同的 router-view 定义名字，通过名字进行对应组件的渲染。</p>
<p>命名路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="keyword">import</span> GoodsList <span class="keyword">from</span> <span class="string">'./../views/GoodsList.vue'</span></span><br><span class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./../views/Title.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/goods'</span>,</span><br><span class="line">      name: <span class="string">'GoodsList'</span>, <span class="comment">//命名路由</span></span><br><span class="line">      component: GoodsList,</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">      path: '/cart',</span></span><br><span class="line"><span class="comment">      name: 'Cart', //命名路由</span></span><br><span class="line"><span class="comment">      component: GoodsList,</span></span><br><span class="line"><span class="comment">    &#125;，*/</span></span><br><span class="line">      &#123;</span><br><span class="line">      path: <span class="string">'/cart/:cartId'</span>, <span class="comment">//带参数的路由</span></span><br><span class="line">      name: <span class="string">'Cart'</span>, <span class="comment">//命名路由</span></span><br><span class="line">      component: GoodsList,</span><br><span class="line">    &#125;，</span><br><span class="line">  ]</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--GoodsList.vue--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;router-link v-bind:to="&#123;name: 'Cart'&#125;"&gt;跳转到购物车&lt;/router-link&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span>=<span class="string">"&#123;name: 'Cart', params: &#123;cartId: 123&#125;&#125;"</span>&gt;</span>跳转到购物车<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>命名视图：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--App.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="keyword">import</span> GoodsList <span class="keyword">from</span> <span class="string">'./../views/GoodsList.vue'</span></span><br><span class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./../views/Title.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/goods'</span>,</span><br><span class="line">      name: <span class="string">'GoodsList'</span>, <span class="comment">//命名路由</span></span><br><span class="line">      components: &#123;</span><br><span class="line">            <span class="keyword">default</span>: GoodsList,</span><br><span class="line">            title: Title,</span><br><span class="line">            img: Image</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/cart/:cartId'</span>, <span class="comment">//带参数的路由</span></span><br><span class="line">      name: <span class="string">'Cart'</span>, <span class="comment">//命名路由</span></span><br><span class="line">      component: GoodsList,</span><br><span class="line">    &#125;，</span><br><span class="line">  ]</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack(一)</title>
    <url>/blog/2018/10/30/webpack(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="webpack-简介"><a href="#webpack-简介" class="headerlink" title="webpack 简介"></a>webpack 简介</h2><p><img src="https://github.com/riversword/images/raw/master/blog/1543924552847.png" alt="1543924552847"></p>
<p>webpack 是一个打包工具，它可以将项目依赖的脚本文件、样式文件、图片等打包压缩，从而减少项目的体积，同时简化项目目录。官方是这么介绍的：</p>
<blockquote>
<p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。 </p>
</blockquote>
<a id="more"></a>
<p>webpack 中有两个重要的概念——入口 entry 和出口 output。</p>
<p>入口 entry ，设置 webpack 打包时的入口文件，入口文件的作用是，告诉 webpack 该项目的依赖文件是哪些。在打包时，webpack 就会根据入口文件的提示，读取的所有依赖文件，将它们打包成压缩文件。最终， index.html 只需引用压缩文件作为依赖即可运行。</p>
<p>出口 output，设置 webpack 将打包后的压缩文件，将输出至哪个文件夹，以及对压缩后的文件如何命名。</p>
<h2 id="从一个-demo-开始，学习-webpack-的使用"><a href="#从一个-demo-开始，学习-webpack-的使用" class="headerlink" title="从一个 demo 开始，学习 webpack 的使用"></a>从一个 demo 开始，学习 webpack 的使用</h2><p>首先  <code>npm init</code>  初始化项目，生成 package.json 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>安装 webpack，作为开发依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure>
<p>webpack 版本为 4.24.0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ webpack -v</span><br><span class="line">4.24.0</span><br></pre></td></tr></table></figure>
<p>现有如下的项目目录，希望通过 webpack 将依赖的多个 js 文件，打包成一个 js 文件。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1543984047457.png" alt="1543984047457"></p>
<p>index.html 引入了 main.js 作为依赖。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack demo01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意：浏览器JS不支持模块系统，需要加上type="module" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./src/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>main.js 又以 hello.js 和 introduce.js 为依赖。通过 mian.js 即可知道，整个应用依赖的所有 js。因此 main.js 即可作为 webpack 打包的入口文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js </span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">"./hello.js"</span>;</span><br><span class="line"><span class="keyword">import</span> introduce <span class="keyword">from</span> <span class="string">"./introduce.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#root"</span>).appendChild(hello());</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#root"</span>).appendChild(introduce());</span><br></pre></td></tr></table></figure>
<h2 id="打包的方式"><a href="#打包的方式" class="headerlink" title="打包的方式"></a>打包的方式</h2><h3 id="命令行打包"><a href="#命令行打包" class="headerlink" title="命令行打包"></a>命令行打包</h3><p>命令行打包时，命令格式是  <code>webpack &lt;entry&gt; -o &lt;output&gt;</code>，<code>&lt;entry&gt;</code> 是打包的入口文件，<code>&lt;output&gt;</code> 是打包后输出的文件。 </p>
<p>执行  <code>webpack src/main.js public/bundle.js</code>  时，发现报错：Error: Cannot find module ‘webpack’。这是由于 webpack 未全局安装时，运行 webpack 会找不到 webpack 命令模块，可以在命令行中指定 webpack 所在的具体路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ webpack src/main.js -o public/bundle.js</span><br><span class="line">D:\MyData\node_modules\webpack-cli\bin\cli.js:244</span><br><span class="line">                                throw err;</span><br><span class="line">                                ^</span><br><span class="line"></span><br><span class="line">Error: Cannot find module <span class="string">'webpack'</span></span><br><span class="line">    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:507:25)</span><br></pre></td></tr></table></figure>
<p>指定 webpack 所在的模块路径为 node_modules/.bin/webpack。再次运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node_modules/.bin/webpack src/main.js -o public/bundle.js</span><br><span class="line">Hash: 963eaaa5f268b2c342a6</span><br><span class="line">Version: webpack 4.24.0</span><br><span class="line">Time: 954ms</span><br><span class="line">Built at: 2018-12-04 23:33:56</span><br><span class="line">    Asset     Size  Chunks             Chunk Names</span><br><span class="line">bundle.js  1.2 KiB       0  [emitted]  main</span><br><span class="line">Entrypoint main = bundle.js</span><br><span class="line">[0] ./src/main.js + 2 modules 591 bytes &#123;0&#125; [built]</span><br><span class="line">    | ./src/main.js 201 bytes [built]</span><br><span class="line">    | ./src/hello.js 186 bytes [built]</span><br><span class="line">    | ./src/introduce.js 204 bytes [built]</span><br><span class="line"></span><br><span class="line">WARNING <span class="keyword">in</span> configuration</span><br><span class="line">The <span class="string">'mode'</span> option has not been <span class="built_in">set</span>, webpack will fallback to <span class="string">'production'</span> <span class="keyword">for</span> this value. Set <span class="string">'mode'</span> option to <span class="string">'development'</span> or <span class="string">'production'</span> to <span class="built_in">enable</span> defaults <span class="keyword">for</span> each environment.</span><br><span class="line">You can also <span class="built_in">set</span> it to <span class="string">'none'</span> to <span class="built_in">disable</span> any default behavior. Learn more: https://webpack.js.org/concepts/mode/</span><br></pre></td></tr></table></figure>
<p>警告信息提示，需要设置打包模式，<code>--mode development</code> 开发模式，<code>--mode production</code> 生产模式。</p>
<p>执行 <code>node_modules/.bin/webpack app/main.js -o public/bundle.js --mode development</code> ，按开发模式进行打包，可得到未压缩的 bundle.js 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node_modules/.bin/webpack src/main.js -o public/bundle.js --mode development</span><br><span class="line">Hash: 9f06c0a0ad993497c1ee</span><br><span class="line">Version: webpack 4.24.0</span><br><span class="line">Time: 142ms</span><br><span class="line">Built at: 2018-12-04 23:34:57</span><br><span class="line">    Asset      Size  Chunks             Chunk Names</span><br><span class="line">bundle.js  5.54 KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = bundle.js</span><br><span class="line">[./src/hello.js] 186 bytes &#123;main&#125; [built]</span><br><span class="line">[./src/introduce.js] 204 bytes &#123;main&#125; [built]</span><br><span class="line">[./src/main.js] 201 bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure>
<p>到此 webpack 已经打包成功，index.html 仅需依赖 bundle.js ，即可运行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack demo01<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./public/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="npm-run-dev-build-打包"><a href="#npm-run-dev-build-打包" class="headerlink" title="npm run dev / build 打包"></a>npm run dev / build 打包</h2><p>在 package.json 文件中，增加如下的脚本命令，用于开发模式和生产模式的打包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack --mode deveplopment"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --mode production"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>运行 <code>npm run dev</code>  或 <code>npm run build</code> 时，执行的即是 <code>webpack --mode deveplopment</code>  或 <code>webpack --mode production</code> 。webpack 会默认将 src 文件夹下的 index.js 作为入口文件，出口为 dist 文件夹下的 bundle.js 。</p>
<p>因此，需要将原项目中的 mian.js ，改名为 index.js，再进行打包 。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1543969184527.png" alt="1543969184527"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run dev</span><br><span class="line"></span><br><span class="line">&gt; demo01@1.0.0 dev D:\newjean\GitHub\webpack-guide\demo01</span><br><span class="line">&gt; webpack --mode development</span><br><span class="line"></span><br><span class="line">Hash: 25495e2ac8b7ea9bb3a0</span><br><span class="line">Version: webpack 4.24.0</span><br><span class="line">Time: 199ms</span><br><span class="line">Built at: 2018-12-05 08:25:37</span><br><span class="line">  Asset      Size  Chunks             Chunk Names</span><br><span class="line">main.js  5.55 KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = main.js</span><br><span class="line">[./src/hello.js] 186 bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.js] 201 bytes &#123;main&#125; [built]</span><br><span class="line">[./src/introduce.js] 204 bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure>
<h2 id="配置-webpack-config-js-进行打包"><a href="#配置-webpack-config-js-进行打包" class="headerlink" title="配置 webpack.config.js 进行打包"></a>配置 webpack.config.js 进行打包</h2><p>在项目根目录下，新建 webpack.config.js ，webpack.config.js 是 webpack 打包时的配置文件，可以自定义打包的入口、出口等。这时，再运行 <code>npm run dev</code> 或 <code>webpack --mode development</code> ，webpack 就会遵循 webpack.config.js 中的设置来进行打包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'./public/bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行打包时，发现打包输出文件是 dist/public/bundle.js，也就是说 webpack 还是默认将打包后的文件放在 dist 文件夹下。</p>
<p>为打包输出至自定义的路径，还需要在 output 中设置 path 属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./app/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/public'</span></span><br><span class="line">    <span class="comment">// __dirname表示当前路径，即webpack.config.js所在的路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再运行打包命令，即可得到理想的打包文件路径。需要注意的是 path 的值要求是绝对路径。</p>
]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>web前端中的资源引用路径</title>
    <url>/blog/2018/08/06/web%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>在web开发时，我们首先就会在 index.html 文件里面引入 .css 样式文件和 .js 脚本文件，并且毫无疑问，在填写引入的路径时，直接写上 .css（.js）文件 相对于 index.html 的路径就可以了。</p>
<p>但是在 .css 或 .js 文件中，再去引入其他的资源，关于引用路径的写法，是否直接填上目标资源相对于 .css （或 .js ）的路径就可以了呢？</p>
<a id="more"></a>
<h2 id="在-js-中引用图片资源时，引用地址是相对于谁呢"><a href="#在-js-中引用图片资源时，引用地址是相对于谁呢" class="headerlink" title="在 js 中引用图片资源时，引用地址是相对于谁呢"></a>在 js 中引用图片资源时，引用地址是相对于谁呢</h2><p>例如在 test 文件夹下有如下文件：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-08-06_223631.png" alt="1533566199003"></p>
<p>index.html 的内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/layout.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/vue.png"</span> <span class="attr">title</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gallery"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现需要给 <code>id=&quot;gallery&quot;</code> 的元素设置一个背景图，背景图片为 image 文件夹下的 node.jpg 图片。</p>
<ul>
<li><p>在 layout.css 文件中设置背景图，layout.css 内容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#gallery</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'../image/node.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，图片的地址是，该图片相对于 layout.css 文件的路径。</p>
</li>
</ul>
<ul>
<li><p>在 main.js 文件中设置背景图，main.js 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'gallery'</span>).style.backgroundImage = <span class="string">'url(image/node.jpg)'</span></span><br></pre></td></tr></table></figure>
<p>可以看到，图片的地址并不是 node.jpg 图片相对于 main.js 文件的路径，实质上这里的图片地址是 node.jpg 图片相对于 index.html 文件的路径。</p>
</li>
</ul>
<p>.js 文件中引用图片等静态资源时，引用地址是图片相对于其宿主的相对路径。（谁引用了该 .js 文件，谁就是宿主，这里宿主指的就是 index.html ，所以引用地址就是 node.jpg 图片相对于 index.html 文件的路径。）</p>
<h2 id="Vue-cli-项目中的资源路径"><a href="#Vue-cli-项目中的资源路径" class="headerlink" title="Vue-cli 项目中的资源路径"></a>Vue-cli 项目中的资源路径</h2><p>相信每个使用 vue 的新童鞋，都遇到过这样的问题，通过 Vue-cli 脚手架生成项目时，在本地 <code>run dev</code> 跑起来相当好，但是通过 <code>run build</code> 打包后部署到服务端后，再去访问时，会报出 404（not found）的错误信息。</p>
<p>这也是一个资源引用路径的问题，Vue-cli 初始化的项目，默认打包后的项目文件是放在根目录中的，其根路径设置的是 ‘/‘，然而很少会有人把整个项目文件直接部署在服务器的根目录，通常是部署在服务器根目录中的某个文件夹下，这时就需要更改项目引用资源的根路径了，将 config/index.js 文件中 build 对象中的 assetsPublicPath  属性值由 ‘ / ’ 改为  ‘ . / ’。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    env: <span class="built_in">require</span>(<span class="string">'./prod.env'</span>),</span><br><span class="line">    index: path.resolve(__dirname, <span class="string">'../dist/index.html'</span>),</span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    <span class="comment">// assetsPublicPath: '/',</span></span><br><span class="line">    assetsPublicPath: <span class="string">'./'</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>安全</title>
    <url>/blog/2019/05/03/web%E5%89%8D%E7%AB%AF-%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-site request forgery），跨站请求伪造。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1561793790146.png" alt="1561793790146"></p>
<a id="more"></a>
<p>用户在网站 A 登录成功后，网站 A 会下发 cookie 给用户的浏览器；用户再访问网站 B，B网页上会引诱用户点击，点击时会向网站 A 的某个漏洞接口发请求，该请求会默认携带上用户的 cookie，网站 A 即识别该请求是合法请求。</p>
<p>实现 CSRF 攻击的两大因素：</p>
<ul>
<li>用户在被攻击网站登录过；</li>
<li>被攻击网站的某个接口存在漏洞；</li>
</ul>
<h4 id="CSRF-预防措施"><a href="#CSRF-预防措施" class="headerlink" title="CSRF 预防措施"></a>CSRF 预防措施</h4><ul>
<li><p>Token 验证；</p>
<p>用户登录网站 A 后，服务器给客户端下发一个tooken。调用接口需要传token，才能正常访问。token是发请求时手动添加（A 网站的代码实现），而 cookie 在发请求时会自动添加（用户访问 B 网站，调 A 的接口并自动带上cookie）；</p>
</li>
<li><p>Referer 验证；</p>
<p>判断请求来源，是否来于自己的网站。</p>
</li>
<li><p>隐藏令牌</p>
<p>类似于Token验证，放在请求头中</p>
</li>
</ul>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS（cross-site scripting），跨域脚本攻击；</p>
<p>不需事先登录验证，本质是向页面中注入 JS 并运行。</p>
<p>如，在评论表单中提交 <code>script</code> 标签</p>
<h4 id="攻击方式："><a href="#攻击方式：" class="headerlink" title="攻击方式："></a>攻击方式：</h4><ul>
<li><p>反射型</p>
<p>发出请求时，XSS 代码出现在 URL中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，故叫反射型 XSS。</p>
</li>
</ul>
<p>如，地址栏中输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localhost:<span class="number">3000</span>/?content=<span class="xml"><span class="tag">&lt;<span class="name">img%20src="null"</span> <span class="attr">onerror</span>=<span class="string">"alert('fuck you！')"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>服务器将 search 中的 content 解析后，返回给客户端，客户端将 content 渲染在页面。</p>
<ul>
<li><p>存储型</p>
<p>存储型 XSS 和反射型 XSS 的差别仅在于，提交的代码会存储在服务端（数据库，内存，文件系统等），下次请求目标页面时，不用再提交 XSS代码。</p>
</li>
</ul>
<h4 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h4><ul>
<li><p>编码</p>
<p>对用户输入的数据进行 HTML Entity 编码，如：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">十进制</th>
<th style="text-align:center">转义字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><code>&amp;#32;</code></td>
<td style="text-align:center"><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center"><code>&amp;#62;</code></td>
<td style="text-align:center"><code>&amp;gt;</code></td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center"><code>&amp;#60;</code></td>
<td style="text-align:center"><code>&amp;lt;</code></td>
</tr>
</tbody>
</table>
<ul>
<li><p>过滤</p>
<p>移除用户上传的 DOM 属性，如 <code>onerror</code> 等；</p>
<p>移除用户上传的 Style 节点、Script 节点、Iframe 节点等；</p>
</li>
</ul>
<ul>
<li><p>校正</p>
<p>避免直接对 HTML Entity 解码；</p>
<p>使用 DOM Parse 转换，校正不匹配的 DOM 标签；</p>
</li>
</ul>
<hr>
<p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/09/27/fe-security.html</a></p>
]]></content>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>通信</title>
    <url>/blog/2019/05/02/web%E5%89%8D%E7%AB%AF-%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取；</li>
<li>DOM 无法获得；</li>
<li>Ajax 请求不能发送；</li>
</ul>
<blockquote>
<p> 源：协议、域名、端口，默认端口是 80。这三者有一个不同，就是不同的源，属于跨域了。</p>
</blockquote>
<a id="more"></a>
<h3 id="前后端的通信方式："><a href="#前后端的通信方式：" class="headerlink" title="前后端的通信方式："></a>前后端的通信方式：</h3><ul>
<li>Ajax，Ajax 是同源策略下的通信方式；</li>
<li>WebSocket，WebSocket 是不限制源的通信方式；</li>
<li>CORS，CORS 是新的通信标准，既支持跨域通信也支持同源通信；</li>
</ul>
<h3 id="跨域通信的方式"><a href="#跨域通信的方式" class="headerlink" title="跨域通信的方式"></a>跨域通信的方式</h3><ul>
<li><strong>Jsonp</strong></li>
</ul>
<p>凡拥有 <code>src</code> 属性的标签，都拥有跨域的能力，比如 <code>&lt;script&gt;</code>、<code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> ，跨域请求 jsonp 正是利用了 <code>&lt;script&gt;</code> 标签的跨域能力。</p>
<p>具体实现方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义一个响应处理函数</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(data);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).innerHtml = res.result;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 定义jsonp方法</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span> (<span class="params">url, callback</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> target = url + <span class="string">'？callback='</span> + callback；</span></span><br><span class="line">  script.setAttribute(src, target);</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); <span class="comment">// 添加标签（发出请求）</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 执行jsonp</span></span></span><br><span class="line"><span class="javascript">jsonp(<span class="string">'http://www.riverjean.com/testjsonp'</span>, handle);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      result is <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后服务端返回如下内容，给客户端执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handle(&#123;<span class="string">"result"</span>: <span class="string">"riverjean"</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Hash</strong>，（Hash 即 url 中 # 后的内容，hash 改变时页面不会刷新，而 ? 后的 search 改变时，页面会刷新，所以 search 不能用作跨域通信。）</li>
</ul>
<p>如，A页面通过 <code>iframe</code> 标签引入跨域的页面 B，在 A页面中改变 iframe src属性中的 hash，会触发 B 的 <code>hashChange</code> 事件，B 页面中监听该事件即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pageA</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>];</span><br><span class="line">B.src = B.src + <span class="string">'#'</span> + <span class="string">'dataContent'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pageB</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data='</span>, data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>postMessage</strong>，（h5 标准）</li>
</ul>
<p>窗口 A （<code>http://a.com</code>）向跨域的窗口 B（<code>http://b.com</code>）发送信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pageA</span></span><br><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">'data'</span>, <span class="string">'http://b.com'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pageB</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.origin); <span class="comment">// http://a.com</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.source); <span class="comment">// A window</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.data); <span class="comment">// data</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>WebSocket</strong></li>
</ul>
<p>WebSocket 协议标识符是 <code>ws</code>（如果加密，则为<code>wss</code>），后接服务器网址就是 URL。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> webSocket(<span class="string">'wss://echo.websoket.org'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Connection open ...'</span>);</span><br><span class="line">  ws.send(<span class="string">'Hello webSocket'</span>); <span class="comment">// 发送数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received Message: '</span> + evt.data);</span><br><span class="line">  ws.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听关闭</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Connect closed'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CORS</strong>，可理解为支持跨域通信的 ajax，在发跨域请求时，在识别到用户发送了一个跨域的 ajax 请求时，会在请求头部加上一个 origin。而一般情况下的 ajax 是不支持跨域通信的，ajax 发送跨域请求时，浏览器会拦截掉。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'/some/url'</span>, &#123;</span><br><span class="line">  method: <span class="string">'get'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
]]></content>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>在真机上调试本地项目</title>
    <url>/blog/2018/08/11/%E5%9C%A8%E7%9C%9F%E6%9C%BA%E4%B8%8A%E8%B0%83%E8%AF%95%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="chrome-开发者工具模拟各种设备靠谱吗？"><a href="#chrome-开发者工具模拟各种设备靠谱吗？" class="headerlink" title="chrome 开发者工具模拟各种设备靠谱吗？"></a>chrome 开发者工具模拟各种设备靠谱吗？</h2><p>目前的 web 应用，普遍要求适配各种设备终端。而开发时，通常是使用 chrome 浏览器的开发者工具，来模拟各种设备的屏幕尺寸。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018081101.png" alt></p>
<a id="more"></a>
<p>然而，chrome 浏览器的开发者工具，仅仅是模拟出设备的屏幕尺寸，并不能模拟设备运行的真实环境（如浏览器内核）。</p>
<p>也就是说，你可以依靠 chrome 的开发者工具来测试，UI 大小、位置等方面的问题。但是某些属性（比如 CSS3 的渐变色属性）会因浏览器内核不同而表现不同，在 chrome 上测试 ok 了，在真机上测试可能又会是另一种结果。</p>
<p>最靠谱的，还是直接到真机上进行测试。在真机上测试，就一定要将项目部署至服务端，然后设备访问在线地址来测试，非也，非也。</p>
<h2 id="通过局域网ip地址来访问本地项目"><a href="#通过局域网ip地址来访问本地项目" class="headerlink" title="通过局域网ip地址来访问本地项目"></a>通过局域网ip地址来访问本地项目</h2><p>打开 cmd：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018081102.png" alt></p>
<p>键入 <code>ipconfig /all</code>，回车：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018081103.png" alt></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018081104.png" alt></p>
<p>可以看到打印出的信息中有 Ipv4 这一项，然后将项目开发环境的 host 地址，换成 Ipv4 地址即可。最后，在电脑上 <code>npm run dev</code> 将项目跑起来时，此时项目就是运行在 <a href="http://192.168.0.106:8080" target="_blank" rel="noopener">http://192.168.0.106:8080</a> 这个地址上了，各设备就可以通过这个地址来访问该项目了（注意：运行项目的电脑，和访问该项目的设备需要处在同一个局域网中）。</p>
<p>开发环境中项目运行的 host 地址，配置如下。以 vue-cli 项目为例，项目结构文件大体为：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018081105.png" alt></p>
<p>host 及端口的配置，在 config 文件夹的 index.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">dev: &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Paths</span></span><br><span class="line">assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">proxyTable: &#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Various Dev Server settings</span></span><br><span class="line">host: <span class="string">'localhost'</span>, <span class="comment">// can be overwritten by process.env.HOST</span></span><br><span class="line">port: <span class="number">8080</span>, <span class="comment">// can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span></span><br><span class="line">autoOpenBrowser: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其中的 host 地址改成上面拿到的 Ipv4 地址即可， <code>host: &#39;localhost&#39;</code>  改为 <code>host:&#39;192.168.0.106&#39;</code> 。</p>
]]></content>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器项目部署（一）</title>
    <url>/blog/2018/05/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>服务器系统 Ubuntu（16.04）64位，本地系统windows10 64位。</p>
<h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><p>使用软件的是 MobaXterm ，方便查看服务器的文件目录。</p>
<p>点击左上角的 Session ，在弹出窗中选择 SSH ，输入公网 IP ，点击 OK 后进入到命令行。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051501.png" alt></p>
<a id="more"></a>
<p>用户名默认为 root ，输入密码时不会显示出来，输入完毕回车即可。<br><img src="https://github.com/riversword/images/raw/master/blog/18051502.png" alt></p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>为方便管理文件，<code>cd /</code> 进入根目录，下载安装文件：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//npm.taobao.org/mirrors/node/v8.11.1/node-v8.11.1-linux-x64.tar.xz</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051503.png" alt></p>
<p>解压成 tar 格式文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz -d node-v8.11.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>
<p>将得到的 tar 文件再次解压（注意：在哪个目录下执行此命令，解压后的文件就被放到了哪个目录）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf node-v8.11.1-linux-x64.tar</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051504.png" alt></p>
<p>进入 bin 文件夹，执行 <code>./node -v</code> 可查看 node 版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd node-v8.11.1-linux-x64/bin/</span><br><span class="line">./node -v</span><br></pre></td></tr></table></figure>
<p>给 bin 目录下的这三个文件建立命令指向，这里是指向到 <code>/usr/local/bin</code> 目录下。这样就可以在所有目录下直接使用 <code>node</code> ，<code>npm</code> 命令了。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ln -s /node-v8<span class="number">.11</span><span class="number">.1</span>-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /node-v8<span class="number">.11</span><span class="number">.1</span>-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class="line">ln -s /node-v8<span class="number">.11</span><span class="number">.1</span>-linux-x64/bin/npx /usr/local/bin/npx</span><br></pre></td></tr></table></figure>
<p> <img src="https://github.com/riversword/images/raw/master/blog/18051505.png" alt></p>
<h3 id="安装monodb"><a href="#安装monodb" class="headerlink" title="安装monodb"></a>安装monodb</h3><p>  进入 mongdb 官网，复制下载链接。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051506.png" alt></p>
<p>下载文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.6.4.tgz</span><br></pre></td></tr></table></figure>
<p>centos等其他linux系统，下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.4.tgz</span><br></pre></td></tr></table></figure>
<p>解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-ubuntu1604-3.6.4.tgz</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051507.png" alt></p>
<p>新建一个文件夹 mongodb ，将解压出的文件夹移入 mongodb 文件夹。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir  mongodb</span><br><span class="line">mv  mongodb-linux-x86_64-ubuntu1604-3.6.4  mongodb</span><br></pre></td></tr></table></figure>
<p>进入mongodb文件夹，新建 data，logs，etc 三个文件夹。在 logs 文件夹下新建 mongo.log 文件，用来存放日志文件，在 etc 文件夹下新建 mongo.conf 配置文件。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051508.png" alt></p>
<p>编辑 <code>mongo.conf</code> 文件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi mongo.conf</span><br></pre></td></tr></table></figure>
<p>进入编辑界面后，输入 <code>i</code> 开始编辑内容，编辑完毕后，敲 <code>esc</code> ，输入 <code>:wq</code>， 就会自动保存并回到命令行。dbpath 指定数据库存放目录，logpath 指定日志文件，logappend=true 指定日志以追加的形式保存，journal 数据故障恢复和持久化数据，quiet 过滤日志，默认 quiet 和 journal 为 true，port 指定端口。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051509.png" alt></p>
<p>同样地建立命令指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s  /mongodb/mongodb-linux-x86_64-ubuntu1604-3.6.4/bin/mongo  /usr/local/bin/mongo</span><br><span class="line">ln -s  /mongodb/mongodb-linux-x86_64-ubuntu1604-3.6.4/bin/mongod  /usr/local/bin/mongod</span><br></pre></td></tr></table></figure>
<p>指定配置文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod -f /mongodb/etc/mongo.conf</span><br></pre></td></tr></table></figure>
<p>新开一个窗口，登录到服务器，输入 mongo 即可连接到数据库</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/18051510.png" alt></p>
<p>以后每次登录到服务器，需要先在一个窗口中执行 <code>mongod -f /mongodb/etc/mongo.conf</code> ，然后另开一个窗口执行 <code>mongo</code> ，才会连接到数据库。</p>
<p>linux 常用命令：</p>
<p><code>df -h</code> 查看硬盘使用情况。</p>
<p><code>rm -ir /usr/local/bin/node</code>  删除 ‘/usr/local/bin/‘ 路径下的 node 文件。（会有提示，是否删除？）</p>
<p><code>rm -r /usr/local/bin/node</code>  删除 ‘/usr/local/bin/‘ 路径下的 node 文件。（没有提示）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rm -ir /usr/local/bin/node</span></span><br><span class="line">rm: remove symbolic link ‘/usr/<span class="built_in">local</span>/bin/node’? y</span><br></pre></td></tr></table></figure>
<p>linux下文件改名，名为www的文件，改名为demo-server。（mv 是移动文件的命令）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv www demo-server</span><br></pre></td></tr></table></figure>
<p><code>mkdir</code> 新建文件夹</p>
<p><code>touch</code> 新建文件</p>
<p><code>vi app.js</code> 在当前目录下，新建 app.js 文件，并进入编辑模式；键入 <code>i</code> 即可进行编辑。编辑完毕后，点击 esc后，键入<code>:wq!</code> 并回车，即可保存回到命令行。</p>
<p>项目部署在 80 端口，可以通过ip直接进行访问。</p>
<p><code>ps a</code> 显示所有程序；</p>
<p><code>kill PID</code> 杀掉进程PID，其中PID是上一步，<code>ps a</code> 查到的某个程序的进程号。</p>
<p>查看那个程序在使用4000端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i:4000</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>路由跳转至项目外</title>
    <url>/blog/2018/08/11/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E8%87%B3%E9%A1%B9%E7%9B%AE%E5%A4%96/</url>
    <content><![CDATA[<p>近日遇到一个场景，需要将多个前端项目集成到一起，并实现各个项目之间相互跳转。</p>
<p>项目间的跳转，实质上是文件路径之间的跳转。比如：当两个前端项目文件部署在服务器，它俩文件夹位置关系为并列关系：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018081401.png" alt></p>
<p>假设当前浏览器访问的是 A 中的 index.html，此时，需要跳转到 B 中的 index.html， 跳转的相对路径就是 ‘../B/index.html’。</p>
<a id="more"></a>
<p>当尝试使用 <code>this.$router.push({path: &#39;../B/index.html&#39;})</code> ，来访问 B 中的 index.html 时，会发现页面渲染的仍是项目 A 的内容，只是控制台会t提示找不到当前路由对应的页面，而非期望地跳转到 B 项目中，因为项目 A 中的 <code>Vue Router</code> 仅在当前项目 A 的 Vue 应用内有效，而此处的场景是要跳出到当前的 Vue 应用外。</p>
<p>另外，可以知道的是通过给 a 标签的 href 属性赋值 ‘../B/index.html’，能实现文件间的跳转。而 <code>&lt;router-link :to=&quot;path&quot;&gt;</code>  会被渲染为 a 标签，那么将 <code>&lt;router-link :to=&quot;path&quot;&gt;</code> 渲染为 a 标签，是否也可以达到同样的效果呢。</p>
<p>通过查看页面 DOM 可以发现，由 <code>&lt;router-link :to=&quot;../B/index.html&quot;&gt;</code> 渲染出的 a 标签，为 <code>&lt;a href=&quot;/B/index.html&quot;&gt;</code> ，其href 属性值为 ‘/B/index.html’，而非 ‘../B/index.html’。故通过 <code>&lt;router-link :to=&quot;path&quot;&gt;</code>  渲染 a 标签的方式，不能达到预期目的。</p>
<p>除了利用 a 标签 href 来进行路径跳转，还可以直接利用 <code>window.location.href = path</code> 来实现路径跳转，当某个导航按钮发生点击事件时，对 <code>window.location.href</code> 进行赋值，即可达到预期效果。</p>
]]></content>
      <tags>
        <tag>web前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器项目部署（二）</title>
    <url>/blog/2018/05/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="安装-mongodb"><a href="#安装-mongodb" class="headerlink" title="安装 mongodb"></a>安装 mongodb</h2><p>下载mongodb安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.4.tgz</span><br></pre></td></tr></table></figure>
<p>解压压缩包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mongodb-linux-x86_64-4.0.4.tgz</span><br></pre></td></tr></table></figure>
<p>将解压后的文件夹，移动到新建的mongodb文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir mongdb</span><br><span class="line">mv mongodb-linux-x86_64-4.0.4 mongodb</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>配置 mongodb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> mongodb</span><br><span class="line">mkdir data</span><br><span class="line">mkdir logs</span><br><span class="line">mkdir etc</span><br><span class="line"><span class="built_in">cd</span> etc</span><br><span class="line">vi mongo.conf</span><br></pre></td></tr></table></figure>
<p>编辑 <code>mongo.conf</code> 文件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi mongo.conf</span><br></pre></td></tr></table></figure>
<p>进入编辑界面后，输入 <code>i</code> 开始编辑内容，编辑完毕后，敲 <code>esc</code> ，输入 <code>:wq</code>， 就会自动保存并回到命令行。dbpath 指定数据库存放目录，logpath 指定日志文件，logappend=true 指定日志以追加的形式保存，journal 数据故障恢复和持久化数据，quiet 过滤日志，默认 quiet 和 journal 为 true，port 指定端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbpath=/mysoftware/mongodb/data</span><br><span class="line">logpath=/mysoftware/mongodb/logs/mongo.log</span><br><span class="line">logappend=true</span><br><span class="line">journal=true</span><br><span class="line">quiet=true</span><br><span class="line">port=27017</span><br></pre></td></tr></table></figure>
<h2 id="远程连接数据库："><a href="#远程连接数据库：" class="headerlink" title="远程连接数据库："></a>远程连接数据库：</h2><p>首先在阿里云控制台，配置安全组规则后，重启服务器使规则生效：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-12-02_105827.png" alt="1543719517079"></p>
<p>在 shell 中指定 mongodb 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod -f /mysoftware/mongodb/etc/mongo.conf</span><br></pre></td></tr></table></figure>
<p>在客户端中连接远程服务器的mongo数据库</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-12-02_094110.png" alt="1543719644444"></p>
<p>导入数据</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-12-02_130036.png" alt="1543726891535"></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-12-02_131321.png" alt="1543727636806"></p>
<p>注意导入数据的格式，对象与对象之间没有逗号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"productId"</span> : <span class="string">"201710003"</span>,</span><br><span class="line">    <span class="string">"productName"</span> : <span class="string">"平衡车"</span>,</span><br><span class="line">    <span class="string">"salePrice"</span> : <span class="number">1999</span>,</span><br><span class="line">    <span class="string">"productImage"</span> : <span class="string">"pingheng.jpg"</span>,</span><br><span class="line">    <span class="string">"productUrl"</span> : <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"productId"</span> : <span class="string">"201710004"</span>,</span><br><span class="line">    <span class="string">"productName"</span> : <span class="string">"头戴式耳机-3"</span>,</span><br><span class="line">    <span class="string">"salePrice"</span> : <span class="number">80</span>,</span><br><span class="line">    <span class="string">"productImage"</span> : <span class="string">"2.jpg"</span>,</span><br><span class="line">    <span class="string">"productUrl"</span> : <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mongodb-基本用法："><a href="#mongodb-基本用法：" class="headerlink" title="mongodb 基本用法："></a>mongodb 基本用法：</h2><p>注意在启动 mongodb 前，要先指定其配置。</p>
<p>指定 mongodb 的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod -f /mysoftware/mongodb/etc/mongo.conf</span><br></pre></td></tr></table></figure>
<p>输入 mongo 进入 mongodb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">MongoDB shell version v4.0.4</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017</span><br></pre></td></tr></table></figure>
<p>显示当前的数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line"><span class="built_in">local</span>   0.000GB</span><br></pre></td></tr></table></figure>
<p>创建数据库 vuemail，并切换至该数据库下。<code>use vuemail</code> 是切换到 vuemail 数据库，若没有名为 vuemail 的数据库，则先创建一个名为 vuemail 的数据库，并切换至该数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use vuemail</span><br><span class="line">switched to db vuemail</span><br></pre></td></tr></table></figure>
<p>在当前数据库下，创建一个名为 goods 的集合并插入字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.goods.insert(&#123;id:1000,<span class="string">"name"</span>:<span class="string">"this is a test"</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : 1 &#125;)</span><br></pre></td></tr></table></figure>
<p>在当前数据库创建集合，还有另一种方式，如创建集合 goods：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.createCollection(<span class="string">"goods"</span>)</span><br></pre></td></tr></table></figure>
<p>查看当前数据库中的集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure>
<p>删除当前数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>
<p>删除当前数据库中的user集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.user.drop()</span><br></pre></td></tr></table></figure>
<p>查看当前数据库中user集合下的所有数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.user.find()</span><br></pre></td></tr></table></figure>
<p>格式化查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.user.find().prety()</span><br></pre></td></tr></table></figure>
<p>创建角色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use vuemail</span><br><span class="line">switched to db vuemail</span><br><span class="line">&gt; db.createUser(&#123;user:&quot;test&quot;,pwd:&quot;test&quot;,roles:[&quot;root&quot;]&#125;)</span><br></pre></td></tr></table></figure>
<p>对账号和密码进行认证，才能使用，用户名及密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.auth(&quot;test&quot;,&quot;test&quot;)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>创建完用户后，以授权的方式启动mongodb。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod -f /mysoftware/mongodb/etc/mongo.conf --auth</span><br></pre></td></tr></table></figure>
<p>此时再用客户端连接数据库时，查看 vuemail 数据库，需要先配置用户名和密码，才有权限查看该数据库。当以授权的方式启动 mongodb 后，若某个数据库未设置账号、密码，则该数据库将不可访问。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx 的安装与配置</p>
<p>查询 nginx 文件路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># whereis nginx</span></span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz</span><br></pre></td></tr></table></figure>
<p>进入 /etc/nginx/conf.d/ 目录，编辑 default.conf 文件的内容，即 nginx 的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi default.conf</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#root   /usr/share/nginx/html;</span></span><br><span class="line">        root   /mysite/resume;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="string">"default.conf"</span> 46L, 1125C</span><br></pre></td></tr></table></figure>
<p>当访问服务器的 80 端口时，nginx 会进行代理，访问 /mysite/resume/ 目录下的 index.html。（访问服务器的ip时，默认访问80端口。）</p>
<h2 id="pm2-基本用法"><a href="#pm2-基本用法" class="headerlink" title="pm2 基本用法"></a>pm2 基本用法</h2><p>pm2启动一个服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start bin/www</span><br></pre></td></tr></table></figure>
<p>pm2停止服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop bin/www</span><br></pre></td></tr></table></figure>
<p>pm2删除进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 delete bin/www</span><br></pre></td></tr></table></figure>
<p>查看当前有哪些项目在运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure>
<p>查看日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 logs</span><br></pre></td></tr></table></figure>
<p>停止所有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 stop all</span><br></pre></td></tr></table></figure>
<p>启动所有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start all</span><br></pre></td></tr></table></figure>
<h2 id="上传文件至服务器"><a href="#上传文件至服务器" class="headerlink" title="上传文件至服务器"></a>上传文件至服务器</h2><p>本地的文件夹上传至服务器，将 /home/NewJean/Desktop/ 目录下的 server 文件夹，上传至服务器的 /myservers/vuemail_sever/ 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➤ scp -r  /home/NewJean/Desktop/server root@12.87.30.51:/myservers/vuemail_sever/</span><br></pre></td></tr></table></figure>
<h2 id="安装淘宝镜像"><a href="#安装淘宝镜像" class="headerlink" title="安装淘宝镜像"></a>安装淘宝镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>建立 cnpm 软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /mysoftware/node-v10.13.0-linux-x64/bin/cnpm /usr/<span class="built_in">local</span>/bin/cnpm</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>创建一个Node.js服务器（一）</title>
    <url>/blog/2018/01/20/bulid-Node.js-server-1/</url>
    <content><![CDATA[<p>一个简单的服务器，需要满足两个条件：</p>
<ol>
<li><p>接收请求</p>
</li>
<li><p>作出响应</p>
</li>
</ol>
<p>新建一个server.js文件，代码内容如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line">http.createServer( <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125; ).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure></p>
<p>在该文件目录中执行<code>node server.js</code>命令，然后在浏览器中访问<code>http://localhost:8888/</code> ，就能看到打印出的<code>Hello World</code>。</p>
<a id="more"></a>
<p>代码解析：</p>
<p><code>var http = require(&quot;http&quot;);</code> 引入nodejs的http模块，引用的目的是为使用它的<code>createServer</code>方法。</p>
<p><code>createServer</code>方法会返回一个对象，该对象有一个<code>listen</code>函数（方法），用于监听端口号，它接受一个参数，即端口号。</p>
<p>在<code>createServer</code>方法中，传入一个函数，该函数接受两个参数<code>request</code>和<code>response</code>，<code>response</code>负责收到请求后作出响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">response.write(&quot;Hello World&quot;);</span><br><span class="line">response.end();</span><br></pre></td></tr></table></figure>
<p>首先，使用<code>response.writeHead()</code> 函数发送一个HTTP状态 200 和 HTTP头的内容类型（content-type），分别表示请求成功和需要返回的text类型</p>
<p>然后使用 response.write() 函数在HTTP相应主体中发送文本Hello World，也就是需要显示的文本。</p>
<p>最后就是调用 response.end() 完成响应过程。</p>
<h2 id="代码模块化"><a href="#代码模块化" class="headerlink" title="代码模块化"></a>代码模块化</h2><p>在nodejs中，很多代码都是模块化的，就像我们上面在第一行<code>var http = require(&quot;http&quot;);</code>中的http模块一样，所以接下来首先来模块化我们的代码。</p>
<p>在这个代码片段之中，给<code>createServer</code>传入的是一个匿名函数，代码可读性到后来可能就没有那么好了，可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">	response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">	response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">	response.end();</span><br><span class="line">&#125;</span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们创建了一个<code>onRequest</code>方法，然后将其传给<code>createServer</code>方法，这个<code>onRequest</code>其实就是替代在第一部分我们传入的匿名函数。</p>
<p>其他的代码其实没有什么大变化，但是这样一看，其实我们的代码逻辑和结构会好很多，这些对于我们后续继续深入非常有好处。到这里，我们在代码结构之前迈进了一小步，但是这只是对于单个文件的优化而已，一旦我们将视野放到整个项目之后，我们就可以考虑一种更好的代码方式：</p>
<ol>
<li>我们能不能将server.js代码像var http = require(“http”);直接引用呢？因为在很多地方我们可能都会用到这个代码</li>
<li>我们能不能像PHP一样统一指定一个单入口文件index.js来处理所有进来的请求，然后我们根据请求的类型再去判断执行那一段代码？</li>
</ol>
<p>带着上面两个问题，我们进行下一步的代码优化：</p>
<p>根据<code>require(&quot;http&quot;)</code>的思路，我们尝试着将<code>server.js</code>也封装成一个模块，比如像http调用createServer的共用方法一样，我们可以将server.js代码放在一个共用方法之中，比如我们在server.js创建一个start方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    	response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    	response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    	response.end();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);<span class="comment">//用于调试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>这样的话，如果调用start方法，就可以达到上面一样的效果了。但是我们怎么在外部文件也可以用到这个start方法呢？这个问题的解决方法就是利用nodejs的exports机制了，我们通过exports.start = start; 将代码提供给其他页面引用。</p>
<p>接下来，我们解决第二个一问：index.js。我们创建一个index.js文件，我们来考虑一下，index.js需要做的哪些工作：</p>
<p>肯定是可以处理请求和作出回应<br>既然我们在server.js已经写好了可以处理请求和作出回应的服务器代码，我们就可以直接拿来用了，所以，其实现在的index.js只需要很简单的两行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);  </span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p>我们首先像<code>var http = require(&quot;http&quot;);</code>一样引入自己编写的server代码模块，然后就调用server中的start方法来处理。</p>
<p>在命令行执行<code>node index.js</code></p>
<p>再次访问<a href="http://localhost:8888/，会看到同样的Hello" target="_blank" rel="noopener">http://localhost:8888/，会看到同样的Hello</a> World，但是这个时候我们迈进了一大步：我们的代码现在可以很方便地进行管理了。</p>
<p>代码模块化做好之后，我们可以进一步改善我们的服务器，因为目前我们的服务器还是太过简单了，只能返回一个页面(Hello World的简单页面)；但是在现实生活中简单的服务器都是可以根据不同URL来返回不同的页面，所以在这里我们需要引入路由这个功能，也就是用户在请求不同的URL之后，我们根据相应的条件返回不同的页面(或者说数据)给用户。</p>
<h2 id="实现路由"><a href="#实现路由" class="headerlink" title="实现路由"></a>实现路由</h2><p>在开始之前，需要考虑一下实现路由需要哪几个关键点：</p>
<ol>
<li>对于用户输入的URL，我们可以获取到</li>
<li>服务器有多个事件处理方法，每个方法可以对应一个或一种URL格式</li>
<li>对于无法处理的URL，抛出相应的错误处理</li>
</ol>
<p>获取用户输入的URL，可以使用nodejs的官方模块url来实现。所以首先引入url模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br></pre></td></tr></table></figure>
<p>引入后，使用url模块的<code>parse</code>方法来解析，<code>parse</code>方法会返回一个对象，利用该对象的<code>pathname</code>属性就可以找出用户输入的url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pathname url.parse(request.url).pathname;</span><br></pre></td></tr></table></figure>
<p>这里的<code>request.url</code>就是我们传入的参数，我们只需要request的url部分。所以在<code>server.js</code>加上这两行关键代码后，代码结构长这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line">    </span><br><span class="line">    response.writeHead(<span class="number">200</span>,&#123;<span class="string">"content-type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello wWorld"</span>);</span><br><span class="line">    response.end;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>这时用<code>node index.js</code>重启服务器，然后在<code>http://localhost:8888</code>后面分别尝试加入<code>/upload</code> 或<code>/login</code>，你在命令行将会看到相应的输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Request <span class="keyword">for</span> /upload received.</span><br></pre></td></tr></table></figure>
<p>拿到url之后，接下来实现路由，编写<code>router.js</code>。</p>
<p>首先实现最简单的功能，打印出请求的url：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">&#125;</span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>像处理<code>server.js</code>一样，也将<code>router,js</code>模块化，因为后面需要将一些逻辑判断放在这里。这我们不管这些逻辑，我们先来把路由和服务器整合起来。既然上面的<code>route</code>方法接受一个参数，那么我们可以通过在server的<code>start</code>方法传入参数实现（函数可以被当作一个参数来传入另一个函数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    route(pathname);</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样之后，我们也需要相应地修改<code>index.js</code>，因为一切地调用都是从这里开始地，我们需要在<code>index.js</code>引入我们写的<code>router</code>，并且为<code>start</code>方法传入参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<p>引入<code>router</code>很熟悉，跟前面地都一样，然后我们将<code>router</code>的<code>route</code>方法直接传给<code>server</code>的<code>start</code>方法，也就相当于在<code>start</code>方法中使用的<code>route(pathname);</code> ，这时候我们重启服务器，再次访问<code>http://localhost:8888/upload</code>，就会看到类似下面这样的输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Server has started.</span><br><span class="line">About to route a request <span class="keyword">for</span> /upload</span><br><span class="line">Request <span class="keyword">for</span> /upload received.</span><br></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>根据不同的请求作出不同的响应</p>
<p>我们这里的策略也是一样的，将事件处理也作为一个模块，我们可以将其命名为：requestHandlers.js。这个文件负责</p>
<p>各种事件处理，所以这里基本就是有相对应方法，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"You visit /star"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"You visit /upload"</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>在我们的设想当中，这里的<code>start</code>和<code>upload</code>分别对应 <code>/start</code>和 <code>/upload</code>这两个路径，也就是说，当我们访问<code>http://localhost:8888/start</code>和<code>http://localhost:8888/upload</code>的时候，就执行这两段代码。</p>
<p>但是，考虑到现实中的情况是：请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，</p>
<p>都要为了在路由里完成请求而到处理程序重新写方法这样反复折腾。于是，我们以巧妙地引入<em>关联数组</em> 的方式来解决：我们将一系列请求处理程序通过一个对象来传递，然后将其中的方法名传给<code>route()</code>函数。这里可能你看的有点不明白，没关系，看一下代码，其实你就很清晰了：</p>
<p>我们首先稍微修改一下<code>index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestHandlers = <span class="built_in">require</span>(<span class="string">"./requestHandlers"</span>);  </span><br><span class="line"><span class="keyword">var</span> handle = &#123;&#125;;  </span><br><span class="line">handle[<span class="string">"/"</span>] = requestHandlers.start;  </span><br><span class="line">handle[<span class="string">"/start"</span>] = requestHandlers.start;  </span><br><span class="line">handle[<span class="string">"/upload"</span>] = requestHandlers.upload;  </span><br><span class="line">server.start(router.route, handle);</span><br></pre></td></tr></table></figure>
<p>这里我们就将<code>handle</code>作为我们地关联数组对象，我们声明以下三个来触发相对应地事件处理程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle[<span class="string">"/"</span>] = requestHandlers.start;  </span><br><span class="line">handle[<span class="string">"/start"</span>] = requestHandlers.start;  </span><br><span class="line">handle[<span class="string">"/upload"</span>] = requestHandlers.upload;</span><br></pre></td></tr></table></figure>
<p>也就是分别对应触发<code>requestHandlers</code>中对应地方法，这样做有什么好处呢？其实我们想达到地目的就是：比如我们在访问<code>/show</code>的时候可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle[<span class="string">"/show"</span>] = requestHandlers.show;</span><br></pre></td></tr></table></figure>
<p>最后我们将 <code>handle</code>传给<code>server</code>的<code>start</code>方法，就是为了</p>
<p>在<code>server</code>的<code>start</code>方法中使用<code>route</code>来处理<code>handle</code>，所以我们需要对<code>server</code>的<code>start</code>方法进行稍微地修改:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">        route(handle, pathname);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们得将<code>start</code>的参数改为两个<code>route</code>, <code>handle</code>，然后顺理成章地将<code>handle</code>传给<code>route</code>方法。那么在<code>route</code>方法接受到<code>handle</code>之后，我们就可以对这个关联数组来进行处理了，修改<code>router.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function route(handle, pathname) &#123;  </span><br><span class="line">    console.log(&quot;About to route a request for &quot; + pathname);  </span><br><span class="line">    if (typeof handle[pathname] === &apos;function&apos;) &#123;  </span><br><span class="line">        handle[pathname]();  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        console.log(&quot;No request handler found for &quot; + pathname);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>我们将<code>handle</code>对象作为参数传给服务器，再由路由接收，最后由路由来判断当前路径对应的请求处理程序存在否，</p>
<p>存在的话就调用对应的函数。</p>
<p>我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，</p>
<p>因此就有了简洁流畅的形如<code>handle[pathname]();</code>的表达式</p>
<p>这样一来，我们就可以根据不同请求作出不同的处理了。但是到这里，整条路都通了，但是貌似目前的服务器并没有给我们返回一些有意义的东西，不过不要担心，我们前面铺的路还是很有用的啊。我们只需要稍稍修改一些代码即可,就是以下两个点：</p>
<ol>
<li>让请求处理程序通过<code>onRequest</code>函数直接返回<code>（return()）</code>他们要展示给用户的信息。</li>
<li>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。</li>
</ol>
<p>我们需要将<code>requestHandler.js</code>修改为如下形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Start"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">exports.start = start;  </span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<p>我们不在是只单单<code>console.log</code>来查看我们的方法是否被调用了，这次我们分别使用return来返回相对应的内容。</p>
<p>既然有内容返回，请求路由也需要将请求处理程序返回给它的信息返回给服务器，也是在<code>router.js</code>加一个<code>return</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> handle[pathname]();  <span class="comment">// here</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"404 Not found"</span>;  <span class="comment">// here</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">exports.route=route;</span><br></pre></td></tr></table></figure>
<p>从上面代码看到的一样，如果请求路由不存在，我们直接抛给用户一个<code>404 Not Found</code>。</p>
<p>最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容展示给浏览器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">        <span class="comment">// other codes </span></span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">        <span class="keyword">var</span> content = route(handle, pathname);  </span><br><span class="line">        <span class="comment">// other codes</span></span><br><span class="line">        response.write(content);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他代码不用修改，我们只是将<code>route</code>返回的内容保存到<code>content</code>中，再用<code>response.write(content);</code>将不同的</p>
<p>返回信息输出。这样之后，我们重启以下服务器，分别访问下面几个url：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8888/start</span></span><br><span class="line">http:<span class="comment">//localhost:8888/upload</span></span><br><span class="line">http:<span class="comment">//localhost:8888/foo</span></span><br></pre></td></tr></table></figure>
<p>一个简单的服务器其实就已经实现了。</p>
]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/blog/2019/01/07/es6-promise/</url>
    <content><![CDATA[<p>在 <code>JavaScript</code> 中，所有代码都是单线程执行的。由于这个“缺陷”，导致 <code>JavaScript</code> 的所有网络操作，浏览器事件，都必须是异步执行。</p>
<h3 id="callback-hell（回调地狱）："><a href="#callback-hell（回调地狱）：" class="headerlink" title="callback hell（回调地狱）："></a>callback hell（回调地狱）：</h3><p>在 <code>promise</code> 出现之前，异步执行是通过回调函数来实现的。如下，定义了一个函数，旨在创建一个 <code>img</code> 标签，并在加载完成后，打印出 <code>img</code> 的宽度：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src, callback, fail</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = ducument.createElement(<span class="string">'img'</span>);</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(img);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fail();</span><br><span class="line">  &#125;</span><br><span class="line">  img.src = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = <span class="string">'https://www.imooc.com/static/img/index/logo.png'</span>;</span><br><span class="line">loadImg(src, <span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'img.width='</span>, img.width);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failed'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这是一个简单的一层函数嵌套回调。</p>
<p>函数嵌套回调的写法，与代码顺序执行逻辑并不相符，不易阅读。当遇到一个需要多次异步执行的场景，就要用到多层的函数嵌套回调，陷入回调地狱（callback hell），代码愈发地难读写、维护。</p>
<p>而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 的诞生，正是为了解决这样的问题。</p>
<a id="more"></a>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><blockquote>
<p><a href="http://javascript.ruanyifeng.com/advanced/promise.html" target="_blank" rel="noopener">Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code> 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败，分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise 对象。</a></p>
</blockquote>
<p>一个 <code>Promise</code> 有以下几种状态:</p>
<ul>
<li><em>pending</em>: 初始状态，既不是成功，也不是失败状态。</li>
<li><em>fulfilled</em>: 意味着操作成功完成。</li>
<li><em>rejected</em>: 意味着操作失败。</li>
</ul>
<p><code>promise</code> 的基本语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure>
<p>构造函数 <code>Promise</code>，接收一个执行函数 executor 作为参数，并且 executor 带有两个参数，<code>resolve</code> 函数和 <code>reject</code> 函数。（executor [ɪɡ’zekjʊtə(r)]，resolve [rɪ’zɒlv]， reject [rɪ’dʒekt]）</p>
<p><code>Promise</code> 构造函数执行时立即调用 executor 函数（executor 函数在 <code>Promise</code> 构造函数返回实例对象前被调用）。</p>
<p><code>resolve</code> 和 <code>reject</code> 函数被调用时，分别将 <code>promise</code> 的状态改为 <em>fulfilled</em>（完成）或 <em>rejected</em>（失败）。</p>
<p>Promise 实例通过 <code>then</code> 方法，来添加回调函数。<code>then</code> 方法可以接受两个回调函数，第一个是异步操作成功时（变为<code>fulfilled</code>状态）时的回调函数，第二个是异步操作失败（变为<code>rejected</code>）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p>
<p>上例改用 <code>promise</code> 的写法，整个逻辑会清晰许多：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src = <span class="string">'https://www.imooc.com/static/img/index/logo.png'</span>;</span><br><span class="line"><span class="keyword">var</span> result = loadImg(src);</span><br><span class="line"></span><br><span class="line">result.then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'img.width='</span>, img.width);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failed'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">result.then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'img.height='</span>, img.height);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>promise</code> 易拓展，易集成，例如，这里希望再打印出 <code>img</code> 的高度，在 <code>promise</code> 实例后追加 <code>.then()</code> 进行监听处理即可。 </p>
<h4 id="catch-捕获异常"><a href="#catch-捕获异常" class="headerlink" title="catch 捕获异常"></a>catch 捕获异常</h4><p>例1：在 catch 中捕获程序语法报错 Error</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(img);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'自定义错误'</span>);</span></span><br><span class="line"><span class="javascript">          img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            resolve(img)</span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            reject()</span><br><span class="line">          &#125;</span><br><span class="line">          img.src = src</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> promise</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result = loadImg(src);</span></span><br><span class="line"><span class="javascript">      result.then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'1 img.width='</span>, img.width)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> img <span class="comment">// 下一个.then函数才能接收到</span></span></span><br><span class="line"><span class="javascript">      &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'2 img.height='</span>, img.height)</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 统一捕获异常</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'err='</span>, err)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例2：在 catch 中捕获 reject</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(img);</span></span><br><span class="line"><span class="javascript">          img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            resolve(img)</span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            reject(<span class="string">'图片加载失败'</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">          img.src = src</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> promise</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result = loadImg(src);</span></span><br><span class="line"><span class="javascript">      result.then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'1 img.width='</span>, img.width)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> img <span class="comment">// 下一个.then函数才能接收到</span></span></span><br><span class="line"><span class="javascript">      &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'2 img.height='</span>, img.height)</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 统一捕获异常</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'err='</span>, err)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="链式执行处理多个异步串联"><a href="#链式执行处理多个异步串联" class="headerlink" title="链式执行处理多个异步串联"></a>链式执行处理多个异步串联</h4><p>promise 链式执行的好处，执行流程清晰，避免多层嵌套的 callback。</p>
<p>浏览器加载页面图片的方式是并行加载，不分先后顺序。现有如下场景，需要加载完一个图片后再加载另外一个图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(img);</span></span><br><span class="line"><span class="javascript">          img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            resolve(img)</span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            reject(<span class="string">'图片加载失败'</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">          img.src = src</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> promise</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src1 = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result1 = loadImg(src1);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src2 = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result1 = loadImg(src2);</span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      result1.then(<span class="function"><span class="keyword">function</span> (<span class="params">img1</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'第一个图片加载完毕'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'img1='</span>, img1);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> result2; <span class="comment">// 注意：若这里不加return result2，下面的then还是处理的result1 promise</span></span></span><br><span class="line"><span class="javascript">      &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">img2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'第二个图片加载完毕'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'img2='</span>, img2);</span></span><br><span class="line"><span class="javascript">      &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'err='</span>, err)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all 和 Promise.race"></a>Promise.all 和 Promise.race</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise.all 接收一个promise对象的数组（result1、result2为promise对象）</span></span><br><span class="line"><span class="comment">// 待全部promise完成之后，执行then</span></span><br><span class="line"><span class="built_in">Promise</span>.all([result1, result2]).then(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接收到的datas是一个数组，依次包含了多个promise返回的内容</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'datas[0]='</span>, datas[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'datas[1]='</span>, datas[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.race 接收一个包含多个promise对象的数组</span></span><br><span class="line"><span class="comment">// 只要有一个promise完成，就执行then</span></span><br><span class="line"><span class="built_in">Promise</span>.race([result1, result2]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data即最先执行完成的promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data='</span>, data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.all，等所有的 promise 都执行完毕了才会执行 then 中的方法</p>
<p>Promise.race，只要有任何一个 promise 执行完毕了，就会执行 then 中的方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>promise基本语法<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(img);</span></span><br><span class="line"><span class="javascript">          img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            resolve(img)</span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            reject(<span class="string">'图片加载失败'</span>)</span></span><br><span class="line">          &#125;</span><br><span class="line">          img.src = src</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> promise</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src1 = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result1 = loadImg(src1);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src2 = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> result1 = loadImg(src2);</span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.all([result1, result2]).then(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'datas[0]='</span>, datas[<span class="number">0</span>]); <span class="comment">// 即，resolve return的结果</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'datas[1]='</span>, datas[<span class="number">1</span>]);</span></span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="built_in">Promise</span>.race([result1, result2]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data='</span>, data);</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="async-await-（es7）"><a href="#async-await-（es7）" class="headerlink" title="async / await （es7）"></a>async / await （es7）</h4><p><code>Promise</code> 中 <code>then</code> 只是将 callback 拆分了（解决编写与执行逻辑不一致的问题），其实本质上还是 callback（<code>then</code> 中传入的是一个函数）。</p>
<p><code>async</code> / <code>await</code> 是最直接的同步写法，并被 babel 支持。（async [eɪˈsɪŋk]）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result1='</span>, result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result2='</span>, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load();</span><br></pre></td></tr></table></figure>
<p>使用 <code>await</code>，函数必须使用 <code>async</code> 标识，<code>await</code> 后面必须跟一个 <code>Promise</code> 实例，需要 babel-polyfill 来编译。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要用webpack babel 打包编译</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(img);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(img)</span><br><span class="line">    &#125;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">'图片加载失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = src</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> src1 = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result1='</span>, result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result2='</span>, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当调用一个 <code>async</code> 函数时，会返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 对象。当这个 <code>async</code> 函数返回一个值时，<code>Promise</code> 的 resolve 方法会负责传递这个值；当 <code>async</code> 函数抛出异常时，<code>Promise</code> 的 reject 方法也会传递这个异常值。</p>
<p><code>async</code> 函数中可能会有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener"><code>await</code></a> 表达式，这会使 <code>async</code> 函数暂停执行，等待 <code>Promise</code>  的结果出来，然后恢复<code>async</code>函数的执行并返回解析值（resolved）。</p>
<p>​    注意， <code>await</code> 关键字仅仅在 <code>async</code> function中有效。如果在 <code>async function</code>函数体外使用 <code>await</code> ，你只会得到一个语法错误（<code>SyntaxError</code>）。</p>
</blockquote>
<p><code>async</code> / <code>await</code>  使用了 <code>Promise</code>，并没有和 <code>Promise</code> 冲突，完全是同步的写法，再也没有回调函数。但是，改变不了 JS 单线程、异步的本质。</p>
<h3 id="promise练习——自定义请求函数"><a href="#promise练习——自定义请求函数" class="headerlink" title="promise练习——自定义请求函数"></a>promise练习——自定义请求函数</h3><p>在发送异步请求时，会需要用到这样的场景，首先发送一个请求，待响应回来以后，再发送第二个请求。如下面的场景：</p>
<blockquote>
<p>首先要先发送一个 jsonp 请求，获取验证信息，待拿到验证信息后，再发送下一个请求去获取接口数据。</p>
</blockquote>
<p>在 es6 以前通常是用函数嵌套来发送请求，而对返回的数据也没法灵活地进行自定义处理。而 es6 中的 promise 非常适合这种场景，将两个请求封装成一个方法，返回的数据可以在执行方法时，在 <code>then</code> 中进行处理。</p>
<p>模块化开发中，封装的自定义请求方法，<code>request.js</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>封装一个请求方法，先调jsonp请求进行验证，验证通过后再发请求获取数据。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>url 接口地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>method 请求方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;[Object]&#125;</span> </span>params 请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> jsonp <span class="keyword">from</span> <span class="string">'jsonp'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params">url, method, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> requestConfig = &#123;</span><br><span class="line">      url: url,</span><br><span class="line">      method: method,</span><br><span class="line">      data: params</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> errCount = <span class="number">0</span> <span class="comment">// jsonp请求错误计数</span></span><br><span class="line">        <span class="keyword">let</span> casUrl = <span class="string">'http://xxx.xxx.xxx'</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">jsonpRequest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          jsonp(casUrl, &#123;<span class="attr">timeout</span>: <span class="number">5000</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err &amp;&amp; errCount &lt; <span class="number">3</span>) &#123;</span><br><span class="line">              errCount++</span><br><span class="line">              jsonpRequest()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              axios(requestConfig).then(resolve).catch(reject)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        jsonpRequest()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request</span><br></pre></td></tr></table></figure></p>
<p>调用自定义的 <code>request</code> 方法时再处理响应数据：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'request.js'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">url, method, params</span>) </span>&#123;</span><br><span class="line">  request(url, method, params).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.apiData = response.data</span><br><span class="line">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// do something</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`获取数据失败：<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，它起到代理作用，充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口，让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>promise 的使用：</p>
<ul>
<li>new Promise 实例，并 return 实例；</li>
<li>new Promise 时要传入函数，函数有 resolve，reject 两个参数；</li>
<li>成功时执行 resolve() 失败时执行 reject()；</li>
<li>promise 实例 .then 监听结果，then() 返回的是一个 Promise 实例；</li>
</ul>
<hr>
<p>【参考】：</p>
<p><a href="http://javascript.ruanyifeng.com/advanced/promise.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/advanced/promise.html</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas</title>
    <url>/blog/2018/11/18/js-canvas/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"tutorial"</span> <span class="attr">width</span>=<span class="string">"150"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span></span><br><span class="line">这是替代内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;canvas&gt;</code> 标签只有两个属性—— width 和 height，利用 DOM properties 来设置。当没有设置宽度和高度的时候，canvas 会初始化宽度为 300 像素和高度为 150 像素。该元素可以使用 CSS 来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果 CSS 的尺寸与初始画布的比例不一致，它会出现扭曲。 </p>
<p>在 <code>&lt;canvas&gt;</code> 标签中提供了替换内容。不支持 <code>&lt;canvas&gt;</code> 的浏览器将会忽略容器并在其中渲染后备内容。而支持 <code>&lt;canvas&gt;</code> 的浏览器将会忽略在容器中包含的内容，并且只是正常渲染 canvas。 </p>
<a id="more"></a>
<h3 id="渲染上下文（the-rendering-context）"><a href="#渲染上下文（the-rendering-context）" class="headerlink" title="渲染上下文（the rendering context）"></a>渲染上下文（the rendering context）</h3><p>canvas 起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="noopener"><code>&lt;canvas&gt;</code></a>元素有一个叫做 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/getContext" target="_blank" rel="noopener"><code>getContext()</code></a> 的方法，这个方法是用来获得渲染上下文和它的绘画功能。getContext() 只有一个参数，上下文的格式。对于2D图像而言，你可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D" target="_blank" rel="noopener"><code>CanvasRenderingContext2D</code></a>。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'tutorial'</span>); <span class="comment">// 获取到canvas元素</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>); <span class="comment">// 获得canvas的上下文，并设置上下文类型为2d</span></span><br></pre></td></tr></table></figure>
<p>当浏览器不支持 canvas 时，是获取不到 canvas 上下文的，可用如下方式，判断浏览器是否支持 canvas：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'tutorial'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (canvas.getContext)&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="comment">// drawing code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// canvas-unsupported code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>例1，绘制矩形：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Learn about this code on MDN: https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span></span><br><span class="line">      if (canvas.getContext) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        ctx.fillStyle = <span class="string">"rgb(200,0,0)"</span>;</span></span><br><span class="line">        ctx.fillRect (10, 10, 55, 50);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        ctx.fillStyle = <span class="string">"rgba(0, 0, 200, 0.5)"</span>;</span></span><br><span class="line">        ctx.fillRect (30, 30, 55, 50);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"draw();"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"150"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>canvas 是一个二维网格，canvas 的左上角坐标为 (0, 0)。向右是 x 正方向，向下是 y 正方向。</p>
<p>fillStyle 属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是 #000000（黑色）。</p>
<p>fillRect(<em>x, y, width, height</em>) 方法定义了矩形当前的填充方式。</p>
<p>上例中，canvas 画出了两个矩形，第一个矩形从坐标点 (10, 10) 开始，绘制宽 55，长 50 的矩形，其填充色为 rgb(200,0,0)；第二个矩形，从坐标点 (30, 30) 开始，绘制宽 55，长 50 的矩形，其填充色为 rgba(0,0,200,0.5)；</p>
<p>例2，绘制温度折线图</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/20181118_01.png" alt="20181118_01"></p>
<p>需要绘制出如图所示的折线图，及数字。首先需要考虑画布的大小，保证画出的折线不会超出画布。注意canvas的y轴正方向是朝下。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2018-11-19_222220.png" alt></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        width: 402px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        border: 1px solid rgb(0,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        border: 1px solid rgb(255,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas_test"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tHigh = [<span class="number">27</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">24</span>, <span class="number">22</span>, <span class="number">24</span>]; <span class="comment">// 高温数组</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tLow = [<span class="number">22</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">16</span>]; <span class="comment">// 低温数组</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> tArr = tHigh.concat(tLow);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> dataMax = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, tArr); <span class="comment">// 温度最大值 (y最大值)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> dataMin = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, tArr); <span class="comment">// 温度最小值 (y最小值)</span></span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// winWidth为屏幕宽</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> winWidth = <span class="number">400</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xGap = winWidth * <span class="number">0.166</span>; <span class="comment">// 6列，每列的宽度</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xGap2 = (winWidth - xGap*<span class="number">6</span>) / <span class="number">2</span> + xGap / <span class="number">2</span>; <span class="comment">// 第1列中心点离左侧边缘的距离（第6列中心点离右侧边缘的距离）</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> scaleY = <span class="number">4</span>;<span class="comment">//y坐标放大倍数，考虑到高温和低温的差值不大，为便于观察将y值放大处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canHeight; <span class="comment">//画布高</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'dataMax='</span>, dataMax)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'dataMin='</span>, dataMin)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> paddingY = <span class="number">30</span>; <span class="comment">//画布上下内边距 px 要考虑折线上的文字高度 </span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> rangeY = scaleY*(dataMax - dataMin); <span class="comment">// y值的变化范围</span></span></span><br><span class="line"><span class="javascript">        canHeight = rangeY + paddingY * <span class="number">2</span>; <span class="comment">// 画布高</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> yArrH = []; <span class="comment">//高温度</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> yArrL = []; <span class="comment">//低温度</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//计算真实y坐标</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tHigh.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> y1 = (dataMax - dataMin)* (tHigh[i] - dataMin)/(dataMax - dataMin); <span class="comment">// 温度与最小温度的差值</span></span></span><br><span class="line"><span class="javascript">            y1 = scaleY*(dataMax - dataMin - y1) + paddingY; <span class="comment">// y坐标。温度与最小温度的差值，在y值的变化量程中的占比。</span></span></span><br><span class="line">            yArrH[i] = y1;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> y2 = (dataMax - dataMin)* (tLow[i] - dataMin)/(dataMax - dataMin);</span></span><br><span class="line">            y2 = scaleY*(dataMax - dataMin - y2) + paddingY;</span><br><span class="line">            yArrL[i] = y2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas_test'</span>); <span class="comment">// 获取到canvas元素</span></span></span><br><span class="line">        canvas.height = canHeight;</span><br><span class="line">        canvas.width = 400;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'canHeight='</span>, canHeight)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>); <span class="comment">// 获得canvas的上下文，并设置上下文类型为2d</span></span></span><br><span class="line"><span class="javascript">        context.strokeStyle = <span class="string">"#FFCC00"</span>;<span class="comment">//设置线条颜色</span></span></span><br><span class="line"><span class="javascript">        context.lineWidth = <span class="number">2</span>; <span class="comment">//设置线条宽度</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'yArrH='</span>, yArrH)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'xGap2='</span>, xGap2)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'xGap='</span>, xGap)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//画高温曲线</span></span></span><br><span class="line"><span class="javascript">        context.moveTo(xGap2,yArrH[<span class="number">0</span>]); <span class="comment">//移动至起始点</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;tHigh.length; i++)&#123;</span></span><br><span class="line">            context.lineTo(xGap2 + xGap * i, yArrH[i]);</span><br><span class="line"><span class="javascript">            <span class="comment">// 34+66.4*i</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        context.stroke(); <span class="comment">// 绘制</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//画圆点</span></span></span><br><span class="line"><span class="javascript">        context.beginPath();<span class="comment">//创建一条路径</span></span></span><br><span class="line"><span class="javascript">        context.strokeStyle = <span class="string">"#FFFFFF"</span>;<span class="comment">//设置描边颜色</span></span></span><br><span class="line"><span class="javascript">        context.fillStyle = <span class="string">"#FFCC00"</span>;<span class="comment">//设置填充颜色</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tHigh.length; i++)&#123;</span></span><br><span class="line">            context.moveTo(xGap2 + xGap*i + 4, yArrH[i]);</span><br><span class="line"><span class="javascript">            context.arc(xGap2 + xGap*i, yArrH[i], <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI,<span class="literal">false</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        context.fill(); <span class="comment">// 填充</span></span></span><br><span class="line"><span class="javascript">        context.stroke();<span class="comment">//描边</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//画文字</span></span></span><br><span class="line"><span class="javascript">        context.beginPath();<span class="comment">//创建一条路径</span></span></span><br><span class="line"><span class="javascript">        context.fillStyle = <span class="string">"#FFCC00"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tHigh.length; i++)&#123;</span></span><br><span class="line"><span class="javascript">            context.font = <span class="string">"12px Arial"</span>;</span></span><br><span class="line"><span class="javascript">            context.textAlign = <span class="string">'center'</span>;</span></span><br><span class="line"><span class="javascript">            context.fillText(tHigh[i]+<span class="string">"℃"</span>, xGap2 + xGap*i, yArrH[i] - <span class="number">10</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">        context.stroke();</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'yArrL='</span>, yArrL)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//画低温曲线</span></span></span><br><span class="line">        context.beginPath(); </span><br><span class="line"><span class="javascript">        context.strokeStyle = <span class="string">"#00FFFF"</span>;</span></span><br><span class="line">        context.lineWidth  = 2;</span><br><span class="line">        context.moveTo(xGap2,yArrL[0]);</span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;tLow.length; i++)&#123;</span></span><br><span class="line">            context.lineTo(xGap2 + xGap * i, yArrL[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        context.stroke();</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//画圆点</span></span></span><br><span class="line">        context.beginPath();</span><br><span class="line"><span class="javascript">        context.strokeStyle = <span class="string">"#FFFFFF"</span>;</span></span><br><span class="line"><span class="javascript">        context.fillStyle = <span class="string">"#00FFFF"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tLow.length; i++)&#123;</span></span><br><span class="line">            context.moveTo(xGap2 + xGap*i + 4, yArrL[i]);</span><br><span class="line"><span class="javascript">            context.arc(xGap2 + xGap*i, yArrL[i], <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>*<span class="built_in">Math</span>.PI,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 画圆的参数：x坐标，y坐标，半径，起始角度，结束角度，是否逆时针方向</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        context.fill();</span><br><span class="line">        context.stroke();</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//画文字</span></span></span><br><span class="line">        context.beginPath();</span><br><span class="line"><span class="javascript">        context.fillStyle = <span class="string">"#00FFFF"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tLow.length; i++)&#123;</span></span><br><span class="line"><span class="javascript">            context.font=<span class="string">"12px Arial"</span>;</span></span><br><span class="line"><span class="javascript">            context.textAlign = <span class="string">'center'</span>;</span></span><br><span class="line"><span class="javascript">            context.fillText(tLow[i]+<span class="string">"℃"</span>, xGap2 + xGap*i, yArrL[i] + <span class="number">20</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">        context.stroke();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>原型链（一）</title>
    <url>/blog/2019/04/05/js-%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数通常以大写字母开头（习惯约定）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.class = <span class="string">'class-1'</span>;</span><br><span class="line">  <span class="comment">// return this // 使用new操作符时，会默认返回一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Jim'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">'Jack'</span>, <span class="number">14</span>); <span class="comment">// 创建多个对象</span></span><br></pre></td></tr></table></figure>
<p>通过构造函数创建实例，必须使用 <code>new</code> 操作符。这种调用构造函数的方式，经历的过程是这样的：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为新对象添加属性）；</li>
<li>返回新对象；</li>
</ol>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo () &#123;...&#125; 其实是 var Foo = new Function (...)，Foo的构造函数是Function</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125; 其实是 var a = new Object() 的语法糖，a的构造函数是Object</span><br><span class="line">var a = [] 其实是 var a = new Array() 的语法糖，a的构造函数是Array</span><br></pre></td></tr></table></figure>
<p><strong>使用 <code>instanceof</code> 判断一个函数是否是一个实例对象的构造函数</strong></p>
<p>判断一个变量是否为数组，用 <code>变量 instanceof Array</code></p>
<h2 id="6-条原型规则"><a href="#6-条原型规则" class="headerlink" title="6 条原型规则"></a>6 条原型规则</h2><ul>
<li>所有的引用类型（数组、对象、函数），有具有对象特性，即可自由扩展属性（除了 null 以外）；</li>
<li>所有的引用类型（数组、对象、函数），都有一个 <code>__proto__</code> 属性，属性值是一个普通的对象；（<code>__proto__</code>，称为隐式原型）</li>
<li>所有的函数，都有一个 <code>prototype</code> 属性，属性值也是一个普通的对象；（ <code>prototype</code> ，称为显式原型）</li>
<li><strong>所有的引用类型（数组、对象、函数），<code>__proto__</code> 属性值指向它的构造函数的 <code>prototype</code> 属性值</strong>；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr = &#123;&#125;; arr.a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj.__proto__ ='</span>, obj.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr.__proto__ ='</span>, arr.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn.__proto__ ='</span>, fn.__proto__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn.prototype ='</span>, fn.prototype)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj.__proto__ === Object.prototype ?'</span>, obj.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code> （即，它的构造函数的 <code>prototype</code>）中寻找；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'this.name='</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Tom'</span>);</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this.name='</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.printName();</span><br><span class="line">f.alertName(); <span class="comment">// f 本身没有 alertName 属性，就去它的构造函数 Foo 的 prototype 中寻找</span></span><br></pre></td></tr></table></figure>
<p><code>f.printName();</code> ，作为 <code>f</code> 的属性执行，<code>this</code> 指向 <code>f</code> 本身；</p>
<p>执行 <code>f.alertName();</code> 时，<code>alertName</code> 方法中的 <code>this</code> 指向 <code>f</code> 本身；</p>
<p><strong>通过对象的属性执行函数时，无论函数是对象自身的属性，还是从原型中得到的属性，函数执行时其中的 <code>this</code> 永远指向对象本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> f) &#123;</span><br><span class="line">  <span class="comment">// 高级浏览器已经在 for in 中屏蔽了来自原型的属性</span></span><br><span class="line">  <span class="comment">// 但是这里建议还是加上判断，保证程序的健壮性</span></span><br><span class="line">  <span class="keyword">if</span> (f.hasOwnProperty(item)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'item='</span>, item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// item= name</span></span><br><span class="line"><span class="comment">// item= printName</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>一个构造函数的显式原型对象，其构造器即为构造函数本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于Foo为一个构造函数，Foo原型对象的构造器即为Foo</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__ === Foo.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <img src="https://github.com/riversword/images/raw/master/blog/1542759677703.png" alt="构造函数、实例、原型"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'this.name='</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Tom'</span>);</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this.name='</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.printName();</span><br><span class="line">f.alertName();</span><br><span class="line"></span><br><span class="line">f.toString(); <span class="comment">// 去 f.__proto__.__proto__ 中去查找toString属性</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/riversword/images/raw/master/blog//1554473221919.png" alt="原型链"></p>
<p><code>f</code> 的隐式原型 <code>f.__proto__</code> ，指向其构造函数的显式原型 <code>Foo.prototype</code>；（<strong><code>f.__proto__ === Foo.prototype</code></strong>）</p>
<p><code>Foo.prototype</code> 是一个对象，而对象都是 <code>Object</code> 构造函数的实例；故 <code>Foo.prototype</code> 的隐式原型 <code>Foo.prototype.__proto__</code> ，指向<code>Object</code> 的显示原型 <code>Object.prototype</code>；（<code>Foo.prototype.__proto__ === Object.prototype</code>）</p>
<p><strong>注意</strong>，<code>Object.prototype</code> 的隐式原型，指向的是 <code>null</code>。（JS 为了避免死循环，给出的特例。）</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 用于判断引用类型，是否为某个构造函数的实例（判断某个函数，是否为实例对象的构造函数）。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog//1554473221919.png" alt="instanceof"></p>
<p><code>f instanceof Foo</code> 的判断逻辑是，<code>f</code> 的 <code>__proto__</code> 一层一层往上查找，看是否与 <code>Foo.prototype</code> 为同一个引用。</p>
<ul>
<li>若是同一个引用，则返回 <code>true</code>；</li>
<li>若不是同一引用，则继续向上查找，一直查找到 <code>f.__proto__. ... .__proto__</code>  的值为 <code>Object.prototype</code> ，此过程中还没有相同的引用，就返回 <code>false</code> 。</li>
</ul>
<p><strong>只要是在 <code>f</code> 原型链上的构造函数，<code>instanceof</code> 都认为是实例对象 <code>f</code> 的构造函数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>例，<code>a instanceof A</code> 的整个逻辑过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a instanceof A 的逻辑：</span></span><br><span class="line">a.__proto__ === A.prototype ? <span class="comment">// false，则向上一层查找</span></span><br><span class="line">a.__proto__.__proto__ === A.prototype ? <span class="comment">// false，则向上一层查找</span></span><br><span class="line">a.__proto__.__proto__.__proto__ === A.prototype ? <span class="comment">// false，则向上一层查找</span></span><br><span class="line">.</span><br><span class="line">.. <span class="comment">// 若为true，则返回true；若为false，则向上一层查找</span></span><br><span class="line">...</span><br><span class="line">a.__proto__. ... .__proto__ === <span class="built_in">Object</span>.prototype ！= A.prototype <span class="comment">// 返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直到 a.__proto__. ... .__proto__ 的值为 Object.prototype，为止。</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>由 <code>instanceof</code> 的原理分析可知，<strong>用 <code>instanceof</code> 判断某个函数是否为实例对象的直接构造函数，是不准确的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instanceof判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> （构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。</p>
<p>即下例中，<code>Foo.prototype.constructor === Foo</code></p>
</blockquote>
<p><strong>一个构造函数的显式原型对象，其构造器即为构造函数本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constructor判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__.constructor === Foo) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__.constructor === <span class="built_in">Object</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>（构造）函数的原型最初只包含 <code>constructor</code> 属性，而该属性也是共享的，因此可以通过对象实例访问。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.constructor === Foo <span class="comment">// true</span></span><br><span class="line">f.constructor === <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.class = <span class="string">'class-1'</span>;</span><br><span class="line">  <span class="comment">// return this // 使用new操作符时，会默认返回一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Jim'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>new 运算符的原理：</p>
<ul>
<li>一个新对象被创建，它继承自 <code>Foo.prototype</code></li>
<li>构造函数 <code>Foo</code> 被执行，执行的时候，相应的传参会被传入，同时上下文（this） 会被指定为这个新实例对象。<code>new Foo</code> 等同于 <code>new Foo()</code> ，只能用在不传递任何参数的情况；</li>
<li>如果构造函数返回了一个“对象”，那么这个对象会取代整个 new 出来的结果。如果构造函数没有返回对象，那么 new 出来的结果为步骤 1 创建的对象；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟new运算符的原理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">'o3'</span>);</span><br><span class="line">M.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new运算符的工作原理，参数func为构造函数</span></span><br><span class="line"><span class="keyword">var</span> new2 = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(func.prototype); <span class="comment">// 创建一个空对象，继承构造函数的原型对象；（该空对象的隐式原型等于构造函数func的显式原型）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> k = func.call(o); <span class="comment">// 执行构造函数，将func的上下文转移为新对象o的上下文</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断构造函数的运行结果，是否为对象类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> k === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o6 = new2(M);</span><br><span class="line"></span><br><span class="line">o6 <span class="keyword">instanceof</span> M <span class="comment">// true</span></span><br><span class="line">o6 <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">o6.__proto__.constructor === M <span class="comment">// true</span></span><br><span class="line">o6.__proto__.constructor === <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">M.prototype.job = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I'm a coder"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o6.job(); <span class="comment">// I'm a coder</span></span><br><span class="line">o3.job(); <span class="comment">// I'm a coder</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>上例中使用到了 <code>Object.create</code> ，来创建空对象，我们通过以下实例来分析 <code>Object.create</code> 有何特别之处。</p>
<p>创建对象的 3 中方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式：字面量</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'obj1'</span>&#125;; <span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">'obj1'</span>&#125;);</span><br><span class="line"><span class="comment">// var obj1 = &#123;&#125; 其实是 var obj1 = new Object() 的语法糖，obj1的构造函数是Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式：构造函数</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> M(<span class="string">'obj2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方式：Object.create()</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">'p'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;name: 'obj1'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;name: 'obj2'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>由 <code>Object.create</code> 创建的对象 <code>obj3</code>，为空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三种方式：Object.create()</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">'p'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(p);</span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj3.__proto__ === p <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj3.name); <span class="comment">// p</span></span><br></pre></td></tr></table></figure>
<p>由前面的原型规则知，实例对象 <code>obj3</code> 的隐式原型 <code>obj3.__proto__</code> ，指向 <code>obj3</code> 构造函数的显示原型。而通过这里的判断可知，<code>obj3.__proto__</code> 指向 <code>p</code> 对象。</p>
<p><strong><code>Object.create(obj)</code> 方法，会生成一个空对象，并将传入的参数对象 <code>obj</code> 作为该空对象的原型对象。</strong></p>
<p><code>obj3</code> 本身没有 <code>name</code> 属性，它是从原型对象上查找 <code>name</code> 属性。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>异步单线程（二）</title>
    <url>/blog/2019/04/10/js-%E5%BC%82%E6%AD%A5%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="异步与单线程练习"><a href="#异步与单线程练习" class="headerlink" title="异步与单线程练习"></a>异步与单线程练习</h2><p>例1：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'t1'</span>) </span></span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span></span><br><span class="line">    resolve()</span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'then1-1'</span>) </span></span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'then1-2'</span>) </span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>同步代码顺序执行，异步任务放到异步队列中。</p>
<p><strong>异步任务又分为宏任务（macrotask）和微任务（microtask），它们所处的异步队列不是同一个异步队列。</strong></p>
<p><strong>同步代码执行完后，检查异步队列，优先执行异步队列中的微任务，微任务执行完了再执行宏任务。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure>
<p>Promise 的 executor 是一个同步、立即执行的函数。而 Promise 的 then 是微任务，链式调用 then，每次都会在内部生成一个全新的 Promise，然后执行 then，在执行过程中不断向微任务（microtask）推入新的函数，直至微任务（microtask）的队列清空后才会执行下一波的宏任务（macrotask）。</p>
<p>宏任务：setTimeout，setInterval，setImmediate；</p>
<p>微任务：promise.then，process.nextTick（process.nextTick 优先级高于 Promise.then）；</p>
<p>上例分析：</p>
<p>第一轮：</p>
<ul>
<li>主进程：[<code>Promise1的executor</code>，<code>console.log(&#39;end&#39;)</code>]</li>
<li>微任务：[<code>Promise1的第1个then</code>]</li>
<li>宏任务：[<code>console.log(&#39;t1&#39;)</code>]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Promise1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>第二轮：</p>
<ul>
<li>主进程：[<code>Promise1的第1个then</code>]</li>
<li>微任务：[<code>Promise1的第2个then</code>]</li>
<li>宏任务：[<code>console.log(&#39;t1&#39;)</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then1-1</span><br></pre></td></tr></table></figure>
<p>第三轮：</p>
<ul>
<li>主进程：[<code>Promise1的第2个then</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[<code>console.log(&#39;t1&#39;)</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then1-2</span><br></pre></td></tr></table></figure>
<p>第四轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;t1&#39;)</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1</span><br></pre></td></tr></table></figure>
<p>故运行结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise1</span><br><span class="line">end</span><br><span class="line">then1-1</span><br><span class="line">then1-2</span><br><span class="line">t1</span><br></pre></td></tr></table></figure>
<p>例1.2：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'t1'</span>) </span></span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'t2'</span>)</span></span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, 0)</span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'then1-1'</span>) </span></span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'then1-2'</span>) </span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;Promise1&#39;)</code>,   <code>end</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[<code>第一个setTimeout的函数体</code>,  <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>第二轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;t1&#39;)</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[ <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1</span><br></pre></td></tr></table></figure>
<p>第三轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;t2&#39;)</code>]</li>
<li>微任务：[<code>Promise1的第一个then</code>] （<strong>注意：执行resolve时，后面的then才被推入微任务队列</strong>）</li>
<li>宏任务：[]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t2</span><br></pre></td></tr></table></figure>
<p>第四轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;then1-1&#39;)</code>]</li>
<li>微任务：[<code>Promise1的第二个then</code>] </li>
<li>宏任务：[]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then1-1</span><br></pre></td></tr></table></figure>
<p>第五轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;then1-2&#39;)</code>]</li>
<li>微任务：[] </li>
<li>宏任务：[]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then1-2</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise1</span><br><span class="line">end</span><br><span class="line">t1</span><br><span class="line">t2</span><br><span class="line">then1-1</span><br><span class="line">then1-2</span><br></pre></td></tr></table></figure>
<p>例2：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'t1'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span></span><br><span class="line">      resolve()</span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'then1-1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span></span><br><span class="line">    resolve()</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'Promise3'</span>)</span></span><br><span class="line">      resolve()</span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'then3-1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'t2'</span>)</span></span><br><span class="line">    &#125;,0)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'then2-1'</span>)</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'Promise4'</span>)</span></span><br><span class="line">      resolve()</span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'then4-1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'then2-2'</span>) </span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Promise 的执行过程是这样的，Promise 的 executor 是立即执行的同步代码，executor 执行完后，将紧接其后的第一个 then 放到微任务队列；promise 中 then 的链式调用，一个 then 执行后，又将紧跟其后的下一个 then 放到微任务队列。</p>
<p>第一轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;Promise2&#39;)</code>,  <code>Promise3的executor</code>,  <code>end</code>]</li>
<li>微任务：[ <code>Promise3的then</code>, <code>Promise2的第一个then</code>]</li>
<li>宏任务：[<code>第一个setTimeout的函数体</code>,  <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise2</span><br><span class="line">Promise3</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>第二轮：</p>
<ul>
<li>主进程：[ <code>Promise3的then</code>, <code>console.log(&#39;then2-1&#39;)</code>, <code>Promise4的executor</code>]；</li>
<li>微任务：[<code>Promise4的then</code>, <code>Promise2的第二个then</code>]</li>
<li>宏任务：[<code>第一个setTimeout的函数体</code>,  <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then3-1</span><br><span class="line">then2-1</span><br><span class="line">Promise4</span><br></pre></td></tr></table></figure>
<p>第三轮：</p>
<ul>
<li>主进程：[<code>Promise4的then</code>, <code>Promise2的第二个then</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[<code>第一个setTimeout的函数体</code>,  <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then4-1</span><br><span class="line">then2-2</span><br></pre></td></tr></table></figure>
<p>第四轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;t1&#39;)</code>, <code>Promise1的executor</code>]</li>
<li>微任务：[<code>Promise1的then</code>]</li>
<li>宏任务：[ <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1</span><br><span class="line">Promise1</span><br></pre></td></tr></table></figure>
<p>第五轮：</p>
<ul>
<li>主进程：[<code>Promise1的then</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[ <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then1-1</span><br></pre></td></tr></table></figure>
<p>第六轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;t2&#39;)</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[ ]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t2</span><br></pre></td></tr></table></figure>
<p>所以，运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise2</span><br><span class="line">Promise3</span><br><span class="line">end</span><br><span class="line">then3-1</span><br><span class="line">then2-1</span><br><span class="line">Promise4</span><br><span class="line">then4-1</span><br><span class="line">then2-2</span><br><span class="line">t1</span><br><span class="line">Promise1</span><br><span class="line">then1-1</span><br><span class="line">t2</span><br></pre></td></tr></table></figure>
<p>例3：<code>async / await</code></p>
<p>async [eɪˈsɪŋk]</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/bluebird@3.5.3/js/browser/bluebird.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'t1'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span></span><br><span class="line">      resolve()</span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'then1-1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,0)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">resolveAfter0s</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'resolveAfter0s start'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'resolveAfter0s promise'</span>)</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        resolve(<span class="string">'0s'</span>);</span></span><br><span class="line">      &#125;, 0)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCall</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'asyncCalling'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> result = <span class="keyword">await</span> resolveAfter0s();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(result);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  asyncCall()</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>async/await</code> 影响的仅是函数内的执行，而不会影响到函数体外的执行顺序。当调用一个 <code>async</code> 函数时，会返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 对象。</p>
<p><code>await resolveAfter1s()</code> 相当于一个 <code>promise</code>，而 <code>console.log(result);</code> 则相当于 <code>promise</code> 的 <code>then</code> 中执行的函数。</p>
<p>上例分析：</p>
<p>第一轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;asyncCalling&#39;)</code>，<code>console.log(&#39;resolveAfter0s start&#39;)</code>，<code>resolveAfter0s的Promise</code> , <code>console.log(&#39;end&#39;)</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[<code>第一个setTimeout的函数体</code>, <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asyncCalling</span><br><span class="line">resolveAfter0s start</span><br><span class="line">resolveAfter0s promise</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>第二轮：</p>
<ul>
<li>主进程：[<code>console.log(&#39;t1&#39;)</code>, <code>promise1的executor</code>]</li>
<li>微任务：[<code>then1-1</code>]</li>
<li>宏任务：[ <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1</span><br><span class="line">Promise1</span><br></pre></td></tr></table></figure>
<p>第三轮：</p>
<ul>
<li>主进程：[<code>then1-1</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[ <code>第二个setTimeout的函数体</code>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then1-1</span><br></pre></td></tr></table></figure>
<p>第四轮：</p>
<ul>
<li>主进程：[<code>resolve(&#39;0s&#39;)</code>]</li>
<li>微任务：[<code>console.log(result)</code>] （<strong>注意：执行resolve时，后面的then才被推入微任务队列</strong>）</li>
<li>宏任务：[]</li>
</ul>
<p>第五轮：</p>
<ul>
<li>主进程：[<code>console.log(result)</code>]</li>
<li>微任务：[]</li>
<li>宏任务：[]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0s</span><br></pre></td></tr></table></figure>
<p>综上打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asyncCalling</span><br><span class="line">resolveAfter0s start</span><br><span class="line">resolveAfter0s promise</span><br><span class="line">end</span><br><span class="line">t1</span><br><span class="line">Promise1</span><br><span class="line">then1-1</span><br><span class="line">0s</span><br></pre></td></tr></table></figure>
<p>例4：</p>
<blockquote>
<p>实现一个LazyMan，可以按照以下方式调用:<br>LazyMan(“Hank”)输出:<br>Hi! This is Hank!</p>
<p>LazyMan(“Hank”).sleep(10).eat(“dinner”)输出<br>Hi! This is Hank!<br>//等待10秒..<br>Wake up after 10<br>Eat dinner~</p>
<p>LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出<br>Hi This is Hank!<br>Eat dinner~<br>Eat supper~</p>
<p>LazyMan(“Hank”).sleepFirst(5).eat(“supper”)输出<br>//等待5秒<br>Wake up after 5<br>Hi This is Hank!<br>Eat supper</p>
<p>以此类推。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://gist.github.com/dondevi/b5239d50de78d41c4fac738e7c2de645</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> man = &#123;name&#125;;</span><br><span class="line">  <span class="keyword">var</span> tasks = []; <span class="comment">// 存放执行任务</span></span><br><span class="line">  <span class="keyword">var</span> excute = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = tasks.shift();</span><br><span class="line">    task &amp;&amp; task();</span><br><span class="line">  &#125;</span><br><span class="line">  man.talk = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    tasks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi this is <span class="subst">$&#123;str&#125;</span>!`</span>);</span><br><span class="line">      excute(); <span class="comment">// 执行下一个任务</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> man; <span class="comment">// 用于链式操作</span></span><br><span class="line">  &#125;;</span><br><span class="line">  man.sleep = <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    tasks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">        excute();</span><br><span class="line">      &#125;, t);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> man;</span><br><span class="line">  &#125;;</span><br><span class="line">  man.eat = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    tasks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">      excute();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> man;</span><br><span class="line">  &#125;;</span><br><span class="line">  man.sleepFirst = <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    tasks.unshift(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">        excute();</span><br><span class="line">      &#125;, t);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> man;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 异步队列，让tasks都添加完了（同步任务）才去执行；</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    excute();</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  man.talk(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://juejin.im/post/5c9a43175188252d876e5903" target="_blank" rel="noopener">https://juejin.im/post/5c9a43175188252d876e5903</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function</a></p>
<p><a href="https://segmentfault.com/a/1190000011198232" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011198232</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>异步单线程（一）</title>
    <url>/blog/2019/04/09/js-%E5%BC%82%E6%AD%A5%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>Async [eɪˈsɪŋk]</p>
<p>问题：</p>
<ul>
<li>什么是单线程，和异步有什么关系</li>
<li>什么是 event-loop</li>
<li>是否用过 jQuery 的 Deferred</li>
<li>Promise 的基本使用和原理</li>
<li>介绍一下 async/await （和promise 的区别联系）</li>
<li>总结一下当前 JS 解决异步的方案</li>
</ul>
<p>什么是单线程，和异步有什么关系？</p>
<ul>
<li>单线程，即，只有一个线程，同一时间只能做一件事情，两段 js 不能同时执行；</li>
<li>原因，为了避免 DOM 渲染的冲突。浏览器需要渲染 dom，而 js 可以修改 dom 结构，js 执行的时候，浏览器 dom 渲染会暂停，两段 js 也不能同时执行（都修改同一个 dom 就冲突了）。（webworker 支持多线程，但是不能访问 dom）</li>
<li>单线程，带来了资源浪费，需要等待前面的任务执行完毕，才能进行后面的任务。解决方案是<strong>异步</strong>。异步是一种“无奈”的解决方案，虽然有很多问题。</li>
</ul>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>异步与单线程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>异步与单线程<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> i, sum = <span class="number">0</span>;</span></span><br><span class="line">      for (i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 以下js代码执行和dom渲染暂时卡顿，直到上面的循环执行完毕</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'sum='</span>, sum);</span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'hello'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解决方案-异步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 反正1000ms后执行，先不管它，先让其他JS代码执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">''</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">// ajax 加载完才执行，先不管它，先让其他JS代码执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>异步存在的问题：</p>
<ul>
<li>不能使用 <code>try catch</code> 捕获错误，不能 <code>return</code>；</li>
<li>代码不是按照书写方式顺序地执行，可读性差；</li>
<li><code>callback</code> 嵌套函数存在耦合性，一旦有所改变，就会牵一动而发全身；</li>
<li><code>callback</code> 嵌套函数过多时，很难处理错误；</li>
</ul>
<p>单线程，是同一时间只能做一件事，原因是为了避免 dom 渲染冲突，解决方案是异步，而具体实现方式是通过 <code>event-loop</code>。</p>
<p>什么是 event-loop（事件循环/事件轮询）？</p>
<p><code>event-loop</code> （事件轮询），是 JS 实现异步的具体解决方案，它的主要特点是：</p>
<ul>
<li>同步代码，直接执行</li>
<li>异步函数先放在 异步队列 中</li>
<li>待同步代码执行完毕，轮询执行 异步队列 的函数</li>
</ul>
<p>例1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行过程：先将异步函数放到异步队列中，将同步代码放到主进程中，主进程中的代码会被立即执行，主进程中的代码执行完后，查询异步队列中是否有任务，将异步队列中的任务放到主进程中执行。</p>
<p>例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123; // 100ms 放入异步队列</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123; // 立即放入异步队列</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(3) // 放入主进程，立即执行</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即放入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100ms 放入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>异步函数放到异步队列中，第一个 <code>setTimeout</code> 执行完后，异步队列中是没有任务的，要等100ms后才会将第一个 <code>setTimeout</code> 中的函数放入一步队列。</p>
<ul>
<li>执行完第一个 <code>setTimeout</code>，告诉计算机 100ms 后将内层函数放入异步队列中；</li>
<li>执行完第二个 <code>setTimeout</code> ，立即将内层函数放入异步队列；</li>
<li><code>console.log(3)</code> 放入主进程，立即执行，打印出 <code>3</code>；</li>
<li>主进程执行完毕后，事件轮询机制会查看异步队列中是否有任务需要执行，异步队列中只有第二个 <code>setTimeout</code> 的函数，将其放入主进程执行，打印出 <code>2</code>；</li>
<li>主进程执行完毕后，事件轮询机制（监听）再去查询异步队列，异步队列中没有任务了（100ms 对计算机来说，比较长，第二个 <code>setTimeout</code> 的函数还未添加到异步队列中）。JS 引擎会一直轮询地查看异步队列中是否有任务，若有则将异步队列中的任务放入主进程执行。</li>
</ul>
<p>例3：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'xxx'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>ajax 请求成功后，将success函数放入异步队列；（请求成功的时间多久不知道）</li>
<li>第一个 setTimeout 函数在 100ms 后放入异步队列；</li>
<li>第二个 setTimeout 函数立即放入异步队列；</li>
<li>同步代码 <code>console.log(&#39;d&#39;)</code> 放入主进程，立即执行，打印出 <code>d</code>；</li>
</ul>
<p>打印姐可能是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d c b a</span><br><span class="line">或</span><br><span class="line">d c a b</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即放入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -若ajax成功响应时间小于100ms</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100ms后放入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -若ajax成功响应时间大于100ms</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>事件轮询，是 JS 实现异步的具体解决方案；</li>
<li>同步代码，放到主进程直接执行；</li>
<li>异步函数先放在 异步队列 中；</li>
<li>待同步代码执行完毕后，轮询执行 异步队列 中的函数（主进程执行完毕后，查询异步队列中是否有任务，将异步队列中的任务放入主进程执行，如此反复）；</li>
</ul>
<h3 id="jQuery-Deferred"><a href="#jQuery-Deferred" class="headerlink" title="jQuery - Deferred"></a>jQuery - Deferred</h3><p> (deferred [dɪ’fɜd] 推迟)</p>
<p>jQuery 1.5 以前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jQuery 1.5之前的网络请求</span></span><br><span class="line"><span class="keyword">var</span> ajax = $.ajax(&#123;</span><br><span class="line">  url: <span class="string">'xxx.xxx.xxx'</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success2'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success3'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error='</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ajax); <span class="comment">// 返回一个XHR对象</span></span><br></pre></td></tr></table></figure>
<p>jQuery 1.5 之后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jQuery 1.5之后的网络请求 写法一：</span></span><br><span class="line"><span class="keyword">var</span> ajax = $.ajax(<span class="string">'xxx.xxx.xxx'</span>);</span><br><span class="line">ajax.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ajax) <span class="comment">// 返回一个deferred对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jQuery 1.5之后的网络请求 写法二：</span></span><br><span class="line"><span class="comment">// 很像Promise的写法</span></span><br><span class="line"><span class="keyword">var</span> ajax = $.ajax(<span class="string">'xxx.xxx.xxx'</span>);</span><br><span class="line">ajax.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success1'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ajax.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success2'</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error2'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>jQuery 1.5 的变化：</p>
<ul>
<li><p>无法改变 JS 异步和单线程的本质</p>
</li>
<li><p>只能从写法上 杜绝 callback 这种形式</p>
</li>
<li><p>它是一种语法糖形式，但是解耦了代码</p>
</li>
<li><p>很好的体现了：开发封闭原则；（对扩展开放，对修改封闭。23个设计模式，5个设计原则）</p>
<p>若需要对’请求成功’，做进一步的操作，如打印 <code>success3</code>。在 jQuery 1.5 以前，需要修改回调函数的代码（没有扩展性，只能修改代码）；而 jQuery 1.5 之后，只需在处理函数加 <code>.done</code> 就好了（对扩展开放，无需修改以前已有的处理函数，只需增加函数）。在多人开发时，每人开发一个模块，互不干扰，方便管理代码；同时方便了测试，以往代码未修改，无需测试，只需测试新增的函数即可。</p>
</li>
</ul>
<p>上述写法是利用到了 jQuery 的 Deferred</p>
<h3 id="使用-jQuery-Deferred"><a href="#使用-jQuery-Deferred" class="headerlink" title="使用 jQuery Deferred"></a>使用 jQuery Deferred</h3><p>有如下异步操作函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wait  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(task, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">wait()；</span><br></pre></td></tr></table></figure>
<p>现新增需求：要在执行完成后，再进行一系列的任务操作（可能会分好几个步骤去执行），如何进行改写实现？</p>
<p>关键：异步函数传入一个 <code>deferred</code> 对象，并且最后返回这个 <code>deferred</code> 对象；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.6.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred() <span class="comment">// 创建一个deferred对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> wait  = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123; <span class="comment">// 要求传入一个deferred对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>)</span></span><br><span class="line"><span class="javascript">      dtd.resolve() <span class="comment">// 表示异步任务已经完成</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// dtd.reject() // 表示异步任务失败或出错</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(task, 2000);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> dtd <span class="comment">// 要求返回deferred对象</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 注意，这里一定要有返回值</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> wait(dtd); <span class="comment">// 返回的是dtd（deferred对象）</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> w = waitHandle(); <span class="comment">// waitHandle()返回的是dtd</span></span></span><br><span class="line"><span class="javascript">w.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'success1'</span>); <span class="comment">// resolve时执行</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// w.reject(); // 无效；一个deferred对象，状态已经发生改变，无法再次修改；</span></span></span><br><span class="line"><span class="javascript">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'error1'</span>); <span class="comment">// reject时执行</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">w.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'success2'</span>); <span class="comment">// resolve时执行</span></span></span><br><span class="line"><span class="javascript">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'error2'</span>); <span class="comment">// reject时执行</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'test'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// w.reject() // then都执行reject的监听处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 还可以用w.done w.fail的写法</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dtd 的 API 可分成两类，用意不同；</p>
<ul>
<li>第一类：<code>dtd.resolve</code>，<code>dtd.reject</code>；（触发）</li>
<li>第二类：<code>dtd.then</code>，<code>dtd.done</code>，<code>dtd.fail</code>；（监听）</li>
<li>这两类应该分开，否则后果很严重！（可以在上面代码最后执行 w.reject() 试一下后果，<code>w.reject()</code> 会导致 <code>w.then</code> 都打印 error）</li>
</ul>
<h3 id="使用-dtd-promise"><a href="#使用-dtd-promise" class="headerlink" title="使用 dtd.promise()"></a>使用 dtd.promise()</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.6.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred() <span class="comment">// 创建一个deferred对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> wait  = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123; <span class="comment">// 要求传入一个deferred对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>)</span></span><br><span class="line"><span class="javascript">      dtd.resolve() <span class="comment">// 表示异步任务已经完成</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// dtd.reject() // 表示异步任务失败或出错</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(task, 2000);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> dtd.promise() <span class="comment">// 返回promise</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 注意，这里一定要有返回值</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> wait(dtd); <span class="comment">// 返回的是promise</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> w = waitHandle(); <span class="comment">// promise对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">$.when(w).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'success1'</span>); <span class="comment">// resolve时执行</span></span></span><br><span class="line"><span class="javascript">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'error1'</span>); <span class="comment">// reject时执行</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// w.reject(); // 会报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>返回的 promise 只有监听类的方法（<code>.then</code>），故使用触发类的方法（<code>.reslove</code>，<code>.reject</code>）会报错。</p>
<p>jQuery 中 promise 和 Deferred 的区别：Deferred 对象既有被动监听的函数 then，done，fail，有主动触发的函数 resolve，reject，结果容易被外部篡改；而 promise 只能被动监听 then，不能主动修改 resolve，reject；）</p>
<p>jQuery Deferred 算是 ES6 中 Promise 的前身。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与内存</title>
    <url>/blog/2019/04/03/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h3 id="JavaScript-中的数据类型"><a href="#JavaScript-中的数据类型" class="headerlink" title="JavaScript 中的数据类型"></a>JavaScript 中的数据类型</h3><p>JavaScript 中有两种数据类型：基本数据类型值和引用类型值，利用 <code>typeof</code> 会得到如下 7 种值。</p>
<p>6种基本数据类型：<code>undefined</code> 、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code>；</p>
<p>1种引用数据类型：<code>object</code>；（包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date））</p>
<p><code>undefined</code> 与 <code>null</code> 的区别：</p>
<p><strong>null表示”没有对象”，即该处不应该有值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，<strong>二进制的前三位为 0 会被 typeof 判断为对象类型</strong>，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">000</span> - 对象，数据是对象的应用</span><br><span class="line">&gt; <span class="number">1</span> - 整型，数据是<span class="number">31</span>位带符号整数</span><br><span class="line">&gt; <span class="number">010</span> - 双精度类型，数据是双精度数字</span><br><span class="line">&gt; <span class="number">100</span> - 字符串，数据是字符串</span><br><span class="line">&gt; <span class="number">110</span> - 布尔类型，数据是布尔值</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>通过 Object 原型上的toString() 方法可以获取到JavaScript 中对象的真实数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>null 的典型用法是：</p>
<blockquote>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<p>（3） 当一个数据不再需要使用时，通过将其值设置为null来释放其引用，以便垃圾回收器回收。</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) <span class="comment">// null</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">this</span>.instance = echarts.init(echartDom);</span><br><span class="line">&gt; <span class="keyword">this</span>.instance = <span class="literal">null</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</strong>典型用法是：</p>
<blockquote>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<p>（5）使用 void 对表达式求值时，返回undefined。</p>
<p>​      ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。</p>
<p>因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> i;</span><br><span class="line">&gt; i <span class="comment">// undefined</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">&gt; f() <span class="comment">// undefined</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&gt; o.p <span class="comment">// undefined</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> x = f();</span><br><span class="line">&gt; x <span class="comment">// undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>用一句话总结两者的区别是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>基本类型在内存中分别占有固定大小的空间，它们的值保存在栈空间，我们通过按值来访问的。 数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循后进先出的原则。</p>
<p>引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的。如下图：栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 这样，当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019-04-03_131819.png" alt="img"></p>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>基本类型的复制：</p>
<p>在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值。<code>var b = a</code> 执行之后，a 与 b 虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了 b 的值以后，a 的值并不会发生变化。 </p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019-04-03_132020.png" alt="img"></p>
<p>引用类型的复制：</p>
<p>引用类型的复制同样也会为新的变量自动分配一个新的值保存在栈内存中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在堆内存中访问到的具体对象实际上是同一个。</p>
<p>如图，通过 <code>var n = m</code> 执行一次复制引用类型的操作，当改变 n 时，m 也发生了变化。这就是引用类型的特性。</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/2019-04-03_132125.png" alt="img"></p>
<p>像这种 n 复制了 m，当改变 n 时，m 也跟着变化，那么 n 复制 m 就叫做<strong>浅拷贝</strong>。换而言之， 若 n 复制了 m，当改变 n 时，m 保持原样，那么 n 复制 m 就叫做<strong>深拷贝</strong>。当然，深、浅拷贝是针对引用类型的数据来说的。</p>
<p>浅拷贝，是拷贝原对象的引用；深拷贝，是拷贝原对象的实例。</p>
<p>引用类型数据复制时，出现的浅拷贝现象，往往不是我们所期望的，那么如何实现深拷贝呢。</p>
<h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4><p>深拷贝的本质是，复制出的数据（这里我们称作拷贝件），与原数据相同，但是在改变拷贝件时，又不会影响源数据。按此思路，可以想到的方法是，新声明一个引用类型变量，作为拷贝件，将源数据内的所有层级属性（展开至基本数据类型为止），分别复制到拷贝件中。</p>
<p>1.递归调用，复制引用类型中所有层级的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现一个深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!source || <span class="keyword">typeof</span> source !== <span class="string">'object'</span>)&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error arguments'</span>, <span class="string">'shallowClone'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> targetObj = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> keys <span class="keyword">in</span> source) &#123;</span><br><span class="line">      <span class="keyword">if</span> (source.hasOwnProperty(keys)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (source[keys] &amp;&amp; <span class="keyword">typeof</span> source[keys] === <span class="string">'object'</span>) &#123;</span><br><span class="line">           targetObj[keys] = source[keys].constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">           targetObj[keys] = deepClone(source[keys]);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           targetObj[keys] = source[keys];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test example</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  obj: &#123;</span><br><span class="line">    key: <span class="string">'value'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = deepClone(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o3 === o1); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(o3.obj === o1.obj); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.func === o1.func); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>2.用 JSON 对象的 parse 和 stringify，实现深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">        objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">    <span class="keyword">return</span> objClone</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br><span class="line"><span class="comment">// a = [1,1,[2,3],4]</span></span><br><span class="line"><span class="comment">// b = [0,1,[1,3],4]</span></span><br></pre></td></tr></table></figure>
<h3 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h3><p>因为 JavaScript 具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是，了解内存机制有助于认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。</p>
<p>JavaScript的内存生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 分配你所需要的内存</span><br><span class="line">2. 使用分配到的内存（读、写）</span><br><span class="line">3. 不需要时将其释放、归还</span><br></pre></td></tr></table></figure>
<p>为了便于理解，使用一个简单的例子来解释这个周期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 20;  // 在堆内存中给数值变量分配空间</span><br><span class="line">alert(a + 100);  // 使用内存</span><br><span class="line">var a = null; // 使用完毕之后，释放内存空间</span><br></pre></td></tr></table></figure>
<p>第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。</p>
<p>JavaScript 有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。</p>
<p>在 JavaScript 中，最常用的是通过<strong>标记清除</strong>的算法来找到哪些对象是不再继续使用的，因此<code>a = null</code>其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。</p>
<blockquote>
<ul>
<li>在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。</li>
<li>要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节</li>
</ul>
</blockquote>
<p>总结：</p>
<table>
<thead>
<tr>
<th>栈内存</th>
<th>堆内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储基础数据类型</td>
<td>存储引用数据类型</td>
</tr>
<tr>
<td>按值访问</td>
<td>按引用访问</td>
</tr>
<tr>
<td>存储的值大小固定</td>
<td>存储的值大小不定，可动态调整</td>
</tr>
<tr>
<td>由系统自动分配内存空间</td>
<td>由开发人员通过代码进行分配</td>
</tr>
<tr>
<td>主要用来执行程序</td>
<td>主要用来存放对象</td>
</tr>
<tr>
<td>空间小，运行效率高</td>
<td>空间大，但是运行效率相对较低</td>
</tr>
<tr>
<td>先进后出，后进先出</td>
<td>无序存储，可根据引用直接获取</td>
</tr>
</tbody>
</table>
<hr>
<p>【参考】：</p>
<p>栈内存与堆内存 <a href="https://juejin.im/entry/589c29a9b123db16a3c18adf" target="_blank" rel="noopener">https://juejin.im/entry/589c29a9b123db16a3c18adf</a></p>
<p>深浅拷贝 <a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">https://www.cnblogs.com/echolun/p/7889848.html</a></p>
<p>深浅拷贝 <a href="https://segmentfault.com/a/1190000008637489" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008637489</a></p>
<p>undefined与null <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<p>undefined与null <a href="https://www.cnblogs.com/onepixel/p/7337248.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7337248.html</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/blog/2018/05/04/js-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>在前端工程化中，经常会听到，模块化和组件化这两个词，模块（module）和组件（component）是两个相似却不同的概念。</p>
<blockquote>
<p>A module tends to refer first and foremost to a design-time entity. … information hiding as the criterion for allocating responsibility to a module.</p>
<p>A component tends to refer to a runtime entity. … The emphasis is clearly on the finished product and not on the design considerations that went into it.</p>
<p>In short, a module suggests encapsulation properties, with less emphasis on the<br>delivery medium and what goes on at runtime. Not so with components. A delivered binary maintains its “separateness” throughout execution. A component suggests<br>independently deployed units of software with no visibility into the development process.</p>
<p>——《Document Software Architecture》</p>
</blockquote>
<blockquote>
<p>简单地讲，模块是一个白盒，侧重的是对属性的封装，重心在设计和开发阶段，不关注运行时的逻辑；组件是一个可以独立部署的软件单元，面向的是运行时，侧重于产品的功能性，组件是一个黑盒，内部的逻辑是不可见的。</p>
</blockquote>
<p>模块化，是将一个复杂的程序按照一定的规则（规范）封装成几个块（文件）, 并进行组合在一起，块的内部数据与实现是私有的， 只是向外部暴露一些接口（方法）与外部其它模块通信。</p>
<a id="more"></a>
<h2 id="为什么要使用模块化"><a href="#为什么要使用模块化" class="headerlink" title="为什么要使用模块化"></a>为什么要使用模块化</h2><p>一个新技术、新概念的出现，必定是为了解决当下的某些问题。</p>
<p>模块化开发有如下优点：</p>
<ul>
<li><p>避免了命名冲突；</p>
<p>在模块化出现之前，编写通用模块的普遍方案是，将其暴露给全局作用域，当项目越来越复杂时，容易污染全局变量。</p>
</li>
<li><p>便于依赖管理；</p>
<p>在模块化出现之前，若网页中引入了多个 JS 模块文件，并且这些 JS 文件之间，又相互存在依赖关系（被依赖方要在依赖需求方之前被加载）。处理这种依赖关系，是通过 HTML 中的 <code>&lt;script&gt;</code> 标签顺序来实现的。但是，当项目复杂度更高、引入的 JS 模块文件更多时，但从 <code>&lt;script&gt;</code> 标签的顺序，没法区别各模块的具体依赖关系。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">scr</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">scr</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">scr</span>=<span class="string">"a1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">scr</span>=<span class="string">"b1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--...--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>有利于性能优化；</p>
<p>模块化规范的依赖管理功能，让按需加载更加易于管理；使用模块化构建工具，可以将分散的模块进行合并打包，减少客户端 htttp 请求数量。</p>
</li>
<li><p>提高了可维护性；</p>
<p>模块化的命名空间和沙箱机制，以及细粒度的模块划分，让单个模块更加利于维护和迭代，从而提升整体项目的维护效率。</p>
</li>
<li><p>有利于代码复用；</p>
<p>一次编写，多次使用。</p>
</li>
</ul>
<h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><p>现在前端开发中比较流行的模块化规范有：AMD，CMD，CommonJS，ES6 Module。</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS (Common Module Definition)，最初的的名字是 ServeJS，是针对服务端或桌面应用开发等非浏览器环境下的 JavaScript 开发，最典型的应用是 Node.js 开发。</p>
<p>CommonJS 是一种只适用于 JavaScript 的静态模块化规范，适合 Node.js 开发，但是不适合浏览器环境，因为：</p>
<ul>
<li>浏览器的前端资源不仅仅有 JavaScript ，还包括 CSS、图片等，而 CommonJs 无法处理 JavaScript 以外的资源；</li>
<li>另外，CommonJS 所有模块均是同步阻塞式加载，无法实现异步按需加载，在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题，但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</li>
</ul>
<p>CommonJS 语法：</p>
<ul>
<li>暴露模块：<code>module.exports = value</code> 或 <code>exports.xxx = value</code>；</li>
<li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。</p>
<h3 id="AMD-CMD"><a href="#AMD-CMD" class="headerlink" title="AMD / CMD"></a>AMD / CMD</h3><p>AMD / CMD 规范主要针对浏览器环境的模块化开发，并且配置插件可以处理 JavaScript 以外的前端资源。</p>
<p>AMD / CMD 规范，在 CommonJS 的基础上，扩展了以下功能：</p>
<ul>
<li>可以处理 Javascript 以外的资源；</li>
<li>源码无需编译便可在浏览器环境下运行；</li>
<li>按需异步加载、并行加载；</li>
<li>插件系统；</li>
</ul>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>AMD 规范的全称是 <code>Async Module Definition</code>，它采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<code>require.js</code> 采用的规范就是 AMD，使用 <code>define</code> 方法来定义模块，通过 <code>require</code> 加载模块。（AMD 是 RequireJS 在推广过程中对模块定义的规范化产出）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网页中引入require.js和入口文件main.js--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>cmd<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">"main.js"</span> <span class="attr">src</span>=<span class="string">"lib/require.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">'echarts'</span>: <span class="string">'lib/echarts.min'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  shim: &#123;</span><br><span class="line">    <span class="string">'lib/china'</span>: &#123;</span><br><span class="line">      deps: [<span class="string">'echarts'</span>],</span><br><span class="line">      init: <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">echarts</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.Echarts = echarts;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([</span><br><span class="line">  <span class="string">'js/System.js'</span></span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">System</span>) </span>&#123;</span><br><span class="line">  System.page(work)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// System.js</span></span><br><span class="line">define([</span><br><span class="line">  <span class="string">'js/mixins/chartMixin.js'</span>,</span><br><span class="line">  <span class="string">'js/mixins/pageMixin.js'</span></span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  chartMixin,</span></span></span><br><span class="line"><span class="function"><span class="params">  pageMixin</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> System = &#123;&#125;</span><br><span class="line">  System.renderWork = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.echart = chartMixin</span><br><span class="line">  System.page = pageMixin</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD 规范整合了CommonJS 和 AMD 规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD 模块定义规范。</p>
<p>定义暴露模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">'./module2'</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">'./module3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>引入使用模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>CommonJS、AMD、CMD 三者共同的缺点：</p>
<ul>
<li>应用场景单一，模块无法很好地跨环境运行；（CommonJS针对服务端环境，AMD、CMD 适用于浏览器环境）；</li>
<li>构建工具不统一；</li>
</ul>
<h3 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 - module"></a>ES6 - module</h3><p>ES6 的模块化规范，是静态的模块体系，不支持异步加载，它的 <code>import()</code> 函数能实现动态加载，并且被 <code>webpack</code> 和 <code>babel</code> 支持。</p>
<p>例，现有 <code>util1.js</code> 和 <code>util2.js</code> 两个文件，为方便模块化开发，通过 <code>export</code> 将其内部属性或方法，暴露出去：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util1.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    a: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util2.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am fn1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am fn2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>index.js</code> 文件中引入这两个文件，调用它们的方法或属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> util1 <span class="keyword">from</span> <span class="string">'./util1.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fn1, fn2&#125; <span class="keyword">from</span> <span class="string">'./util2.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(util1);</span><br><span class="line">fn1();</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>export</code> 出去的是对象或者函数，在 <code>import</code> 引入时，要用<strong>对象</strong>来接收；</p>
<p><strong>ES6 模块输出的是值的引用</strong></p>
<p>ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import#%E5%8A%A8%E6%80%81import" target="_blank" rel="noopener">import()函数</a>实现动态引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--demo.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;&#125;,</span><br><span class="line">    method: &#123;</span><br><span class="line">      increment() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">import</span>(<span class="string">'/modules/my-module.js'</span>)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// Do something with the module.</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="AMD（Async-Module-Definition）"><a href="#AMD（Async-Module-Definition）" class="headerlink" title="AMD（Async Module Definition）"></a>AMD（Async Module Definition）</h3><p>AMD 规范的全称是 <code>Async Module Definition</code>，它是采用异步方式加载模块的，<code>require.js</code> 采用的规范是 AMD，使用 <code>define</code> 方法来定义模块，通过 <code>require</code> 加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// System.js</span></span><br><span class="line">define([</span><br><span class="line">  <span class="string">'js/mixins/chartMixin.js'</span>,</span><br><span class="line">  <span class="string">'js/mixins/pageMixin.js'</span></span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  chartMixin,</span></span></span><br><span class="line"><span class="function"><span class="params">  pageMixin</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    echart: chartMixin,</span><br><span class="line">    page: pageMixin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([</span><br><span class="line">  <span class="string">'js/System.js'</span></span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">System</span>) </span>&#123;</span><br><span class="line">  System.page(work)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>cmd<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">"main.js"</span> <span class="attr">src</span>=<span class="string">"lib/require.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="commonJS（Common-Module-Definition）"><a href="#commonJS（Common-Module-Definition）" class="headerlink" title="commonJS（Common Module Definition）"></a>commonJS（Common Module Definition）</h3><p><code>node.js</code> 的模块化系统，采用的就是 <code>commonJS</code> 规范。<code>commonJS</code> 模块化语法：<br>导出模块：<code>module.exports = value</code> 或 <code>exports.xxx = value</code><br>引入模块：<code>require(xxx)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>【参考】：</p>
<p>《前端工程化体系设计与实践》</p>
<p><a href="https://juejin.im/post/5c17ad756fb9a049ff4e0a62" target="_blank" rel="noopener">https://juejin.im/post/5c17ad756fb9a049ff4e0a62</a></p>
<p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">https://juejin.im/post/5aaa37c8f265da23945f365c</a></p>
<p><a href="http://huangxuan.me/js-module-7day/#/6" target="_blank" rel="noopener">http://huangxuan.me/js-module-7day/#/6</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>React(一)</title>
    <url>/blog/2019/07/28/react(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h2><p><strong>react 16 后的版本，称为 React Fiber</strong>。react 16 后的版本对底层的核心算法进行了改良，引入了优先级的概念、分片的概念等，让 react 运行的更加流畅（如：处理动画时）。</p>
<p>React 特点：</p>
<ul>
<li>Declarative（声明式编码）；</li>
<li>Component-Based（组件化编码）；</li>
<li>高效——高效的DOM Diff算法，最小化页面重绘；</li>
<li>单向数据流；</li>
</ul>
<p>React 和 Vue 都是单向数据流，都是从父级流向子级。但在表单中 Vue 的 <code>v-model</code> 实现了双向数据流，而 React 是单项数据流。</p>
<a id="more"></a>
<p>编程式实现</p>
<ul>
<li>需要以具体代码表达在哪里（where）做什么（what），如何实现（how）。</li>
</ul>
<p>声明式实现</p>
<ul>
<li>只需要声明在哪里（where）做什么（what），而无需关心如何实现（how）。</li>
</ul>
<h2 id="React-开发环境搭建"><a href="#React-开发环境搭建" class="headerlink" title="React 开发环境搭建"></a>React 开发环境搭建</h2><h3 id="使用-React-脚手架工具构建项目"><a href="#使用-React-脚手架工具构建项目" class="headerlink" title="使用 React 脚手架工具构建项目"></a>使用 React 脚手架工具构建项目</h3><p><a href="https://www.reactjscn.com/docs/create-a-new-react-app.html#create-react-app" target="_blank" rel="noopener">https://www.reactjscn.com/docs/create-a-new-react-app.html#create-react-app</a></p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>创建一个名为 <code>my-app</code> 的 React 项目，依次执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>若 npm 下载太慢，可以考虑用淘宝镜像，修改 npm 为淘宝镜像源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考 <a href="https://cj1406942109.github.io/2018/12/26/npx-create-react-app-my-app-no-response/" target="_blank" rel="noopener">https://cj1406942109.github.io/2018/12/26/npx-create-react-app-my-app-no-response/</a></p>
</blockquote>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>安装和使用 React 脚手架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-react-app</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> my-react-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g create-react-app</span><br><span class="line"></span><br><span class="line">create-react-app --version</span><br><span class="line">3.0.1</span><br><span class="line"></span><br><span class="line">create-react-app my-react-app</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> my-react-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>构建后项目目录如下：</p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1563973920096.png" alt="1563973920096"></p>
<p>入口文件为 <code>src/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">'./serviceWorker'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you want your app to work offline and load faster, you can change</span></span><br><span class="line"><span class="comment">// unregister() to register() below. Note this comes with some pitfalls.</span></span><br><span class="line"><span class="comment">// Learn more about service workers: https://bit.ly/CRA-PWA</span></span><br><span class="line">serviceWorker.unregister();</span><br></pre></td></tr></table></figure>
<p>安装插件，react4.0 以后建议路由和标签混合使用，推荐安装 <code>react-router-dom</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-router-dom axios less less-loader antd</span><br></pre></td></tr></table></figure>
<p>暴露出项目的 webpack 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn eject</span><br></pre></td></tr></table></figure>
<p>项目目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─.gitignore</span><br><span class="line">├─package.json</span><br><span class="line">├─README.md</span><br><span class="line">├─yarn.lock</span><br><span class="line">├─src</span><br><span class="line">|  ├─App.css</span><br><span class="line">|  ├─App.js</span><br><span class="line">|  ├─App.test.js</span><br><span class="line">|  ├─index.css</span><br><span class="line">|  ├─index.js</span><br><span class="line">|  ├─logo.svg</span><br><span class="line">|  └serviceWorker.js</span><br><span class="line">|</span><br><span class="line">├─scripts</span><br><span class="line">|    ├─build.js</span><br><span class="line">|    ├─start.js</span><br><span class="line">|    └test.js</span><br><span class="line">|</span><br><span class="line">├─public</span><br><span class="line">|   ├─favicon.ico</span><br><span class="line">|   ├─index.html</span><br><span class="line">|   └manifest.json</span><br><span class="line">|</span><br><span class="line">├─config</span><br><span class="line">|   ├─env.js</span><br><span class="line">|   ├─modules.js</span><br><span class="line">|   ├─paths.js</span><br><span class="line">|   ├─pnpTs.js</span><br><span class="line">|   ├─webpack.config.js</span><br><span class="line">|   ├─webpackDevServer.config.js</span><br><span class="line">|   ├─jest</span><br><span class="line">|   |  ├─cssTransform.js</span><br><span class="line">|   |  └fileTransform.js</span><br></pre></td></tr></table></figure>
<p>配置 <code>less-loader</code> ，处理 <code>.less</code> 样式文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// style files regexes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lessRegex = <span class="regexp">/\.less$/</span></span><br><span class="line"><span class="keyword">const</span> lessModuleRegex = <span class="regexp">/\.module\.less$/</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">webpackEnv</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> getStyleLoaders = <span class="function">(<span class="params">cssOptions, preProcessor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (preProcessor) &#123;</span><br><span class="line">      loaders.push(&#123;</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(preProcessor),</span><br><span class="line">        options: &#123;</span><br><span class="line">          sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">          javascriptEnabled: <span class="literal">true</span> <span class="comment">// 解决antd less报错 using less@3 https://github.com/ant-design/ant-design/issues/7927</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loaders;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          oneOf: [</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#123;</span><br><span class="line">              test: lessRegex,</span><br><span class="line">              exclude: lessModuleRegex,</span><br><span class="line">              use: getStyleLoaders(</span><br><span class="line">                &#123;</span><br><span class="line">                  importLoaders: <span class="number">2</span>,</span><br><span class="line">                  sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'less-loader'</span></span><br><span class="line">              ),</span><br><span class="line">              sideEffects: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              test: lessModuleRegex,</span><br><span class="line">              use: getStyleLoaders(</span><br><span class="line">                &#123;</span><br><span class="line">                  importLoaders: <span class="number">2</span>,</span><br><span class="line">                  sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">                  modules: <span class="literal">true</span>,</span><br><span class="line">                  getLocalIdent: getCSSModuleLocalIdent,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'less-loader'</span></span><br><span class="line">              ),</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置按需加载：</p>
<p><a href="https://www.npmjs.com/package/babel-plugin-import" target="_blank" rel="noopener"><code>babel-plugin-import</code></a>可以实现按需加载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add babel-plugin-import</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import 'antd/dist/antd.css';</span></span><br><span class="line"><span class="keyword">import</span> &#123;Button&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="comment">// 并通过babel实现按需加载button的样式文件</span></span><br></pre></td></tr></table></figure>
<p>若 antd less 报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bezierEasingMixin();</span><br><span class="line">^</span><br><span class="line">Inline JavaScript is not enabled. Is it set in your options?</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/ant-design/ant-design/issues/7927" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/issues/7927</a></p>
<p>可在 <code>less-loader</code> 的 options 配置中，增加 <code>javascriptEnabled: true</code></p>
<p>或者安装 2.x 版本的 less，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add less@2.7.3</span><br></pre></td></tr></table></figure>
<h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><p><a href="https://yarn.bootcss.com/docs/usage/" target="_blank" rel="noopener">Yarn</a> 是新一代包管理工具，它有以下特点：</p>
<ul>
<li>速度快</li>
<li>安装版本统一、更安全</li>
<li>更简洁的输出</li>
<li>更好的语义化</li>
</ul>
<h4 id="Yarn-命令"><a href="#Yarn-命令" class="headerlink" title="Yarn 命令"></a>Yarn 命令</h4><p><strong>添加依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add [package]</span><br><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br></pre></td></tr></table></figure>
<p><strong>将依赖项添加到不同依赖项类别中</strong></p>
<p>分别添加到 <code>devDependencies</code>、<code>peerDependencies</code> 和 <code>optionalDependencies</code> 类别中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add [package] --dev</span><br><span class="line">yarn add [package] --peer</span><br><span class="line">yarn add [package] --optional</span><br></pre></td></tr></table></figure>
<p><strong>升级依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn upgrade [package]</span><br><span class="line">yarn upgrade [package]@[version]</span><br><span class="line">yarn upgrade [package]@[tag]</span><br></pre></td></tr></table></figure>
<p><strong>移除依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn remove [package]</span><br></pre></td></tr></table></figure>
<p><strong>安装项目的全部依赖</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>React 组件采用 JSX 语法进行编写。</p>
<h3 id="React-组件中的-JSX-语法："><a href="#React-组件中的-JSX-语法：" class="headerlink" title="React 组件中的 JSX 语法："></a>React 组件中的 JSX 语法：</h3><ul>
<li><p>在 <code>{}</code> 中可以写 js 表达式；</p>
</li>
<li><p>React DOM 使用 <code>camelCase</code> 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。例如，html 标签中的 class 在 jsx 模板中为 className。</p>
</li>
<li><p>组件名称必须以大写字母开头。例如，<code>&lt;div /&gt;</code> 表示一个DOM标签，但 <code>&lt;Welcome /&gt;</code> 表示一个组件，并且在使用该组件时你必须定义或引入它。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render中组件标签首字母要大写，否则会报错。</span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;Menu.item&gt;&lt;<span class="regexp">/Menu.item&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;Menu.Item&gt;&lt;<span class="regexp">/Menu.Item&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>style 属性用双大括号，内层的 <code>{}</code> 表示一个对象。</p>
</li>
<li><p>通过 <code>import &#39;index.less&#39;</code> 引入的样式，会在全局生效。而通过 <code>import styles from &#39;./demo.less&#39;;</code> 以 css module 的形式引入，样式仅在当前组件中生效（最后渲染时，class 上会加上 hash）。</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'index.less'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./demo.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个React组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jsx语法</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      hello world，&#123;<span class="number">1</span>+<span class="number">6</span>&#125; pm now</span><br><span class="line">      &lt;div className=&#123;styles[<span class="string">'display-content'</span>]&#125;&gt;</span><br><span class="line">        &lt;input className=<span class="string">'red-border'</span> value=&#123;<span class="keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;/&gt;</span><br><span class="line">        &lt;button style=&#123;&#123;<span class="attr">textAlign</span>: <span class="string">'center'</span>, <span class="attr">fontSize</span>: <span class="string">'24'</span>,<span class="attr">background</span>: <span class="string">'green'</span>&#125;&#125; onClick=&#123;<span class="keyword">this</span>.handleBtnClick&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.less</span></span><br><span class="line"><span class="selector-class">.display-content</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.red-border</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>this 的指向，在模板上绑定方法时，注意要 <code>bind(this)</code> （否则 this 指向的是 DOM 节点）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Life</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化时bind(this)</span></span><br><span class="line">      <span class="keyword">this</span>.handleClick2 = <span class="keyword">this</span>.handleClick2.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在dom上绑定时，不需要加bind</span></span><br><span class="line">    handleAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在dom上绑定时，需要加bind(this)</span></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时已经bind(this)。在dom上绑定时，不再需要bind(this)</span></span><br><span class="line">    handleClick2() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleAdd&#125;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick2&#125;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>事件绑定，如下例子，在绑定 <code>this.clickBtn</code> 方法时，需要传入两个参数，若直接写成 <code>onClick={this.clickBtn(item, index)}</code> ，在页面渲染时 <code>this.clickBtn</code> 方法便会立即执行。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;li className=&#123;<span class="string">'keyboard-btn'</span>&#125; key=&#123;index&#125; onClick=&#123;<span class="keyword">this</span>.clickBtn(item, index)&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<p>正确的做法是，在 <code>this.clickBtn</code> 外面包一层函数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.less'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="keyword">this</span>.state = &#123;</span><br><span class="line">			btns: [</span><br><span class="line">				<span class="string">'C'</span>, <span class="string">'mc'</span>, <span class="string">'m+'</span>, <span class="string">'m-'</span>, <span class="string">'mr'</span></span><br><span class="line">			]</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.clickBtn.bind(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	clickBtn(item, index) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(item, index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div className=&#123;<span class="string">'keyboard-container'</span>&#125;&gt;</span><br><span class="line">				&lt;ul className=&#123;<span class="string">'keyboard'</span>&#125;&gt;</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">this</span>.state.btns.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> (</span><br><span class="line">								&lt;li className=&#123;<span class="string">'keyboard-btn'</span>&#125; key=&#123;index&#125; onClick=&#123;(event) =&gt; &#123;</span><br><span class="line">									<span class="keyword">this</span>.clickBtn(item, index);</span><br><span class="line">								&#125;&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                </span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ 报错，页面加载就立即执行clickBtn方法</span></span><br><span class="line"><span class="regexp">								/</span><span class="regexp">/ &lt;li className=&#123;'keyboard-btn'&#125; key=&#123;index&#125; onClick=&#123;this.clickBtn(item, index)&#125;&gt;&#123;item&#125;&lt;/</span>li&gt;</span><br><span class="line">							)</span><br><span class="line">						&#125;)</span><br><span class="line">					&#125;</span><br><span class="line">				&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Keyboard</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>跟 Vue 组件类似，所有的 React 组件都要有一个根元素。若不想再引入额外的元素，可以使用 react 中的 <code>&lt;Fragment&gt;</code> 作为根元素，<code>&lt;Fragment&gt;</code> 不会被渲染到页面上。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input className=<span class="string">'red-border'</span> value=&#123;<span class="keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;/&gt;</span><br><span class="line">          &lt;button style=&#123;&#123;<span class="attr">background</span>: <span class="string">'green'</span>&#125;&#125; onClick=&#123;<span class="keyword">this</span>.handleBtnClick&#125;&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123; <span class="keyword">this</span>.getTodoItems() &#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h3><p><img src="https://github.com/riversword/images/raw/master/blog/1564112530205.png" alt="1564112530205"></p>
<p><img src="https://github.com/riversword/images/raw/master/blog/1564275587732.png" alt="1564275587732"></p>
<ul>
<li>getDefaultProps</li>
<li>getInitialState，</li>
<li>componentWillMount，组件渲染前调用的生命钩子，通常在这个钩子里面调用接口；</li>
<li>render，必须有</li>
<li>componentDidMount</li>
<li>componentWillReceiveProps，子组件收到父组件传来的数据</li>
<li>shouldComponentUpdate，当执行 <code>this.setState()</code> 更新 state 时，会调用该方法</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>页面初次加载执行（父组件的state传给子组件的props了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件componentWillMount</span><br><span class="line">子组件componentWillMount</span><br><span class="line">子组件componentDidMount</span><br><span class="line">父组件componentDidMount</span><br></pre></td></tr></table></figure>
<p>父组件state改变时（父组件的state传给子组件的props了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件shouldComponentUpdate</span><br><span class="line">父组件componentWillUpdate</span><br><span class="line">子组件componentWillReceiveProps</span><br><span class="line">子组件shouldComponentUpdate</span><br><span class="line">子组件componentWillUpdate</span><br><span class="line">子组件componentDidUpdate</span><br><span class="line">父组件componentDidUpdate</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>render函数</title>
    <url>/blog/2019/05/01/vue-render%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="模板转换为render函数"><a href="#模板转换为render函数" class="headerlink" title="模板转换为render函数"></a>模板转换为render函数</h3><p>在Vue中我们经常使用到模板，模板内容形如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>模板的本质是字符串，与 html 的格式很像，因为包含有逻辑，如<code>v-if</code>、<code>v-for</code> 等，跟 html 又有很大的区别，但最终还是要转换为 html 来显示。</p>
<p>将模板渲染成页面上的 html，模板需要先转换成 JS 代码，因为：</p>
<ul>
<li>模板字符串中包含逻辑（<code>v-if</code>、<code>v-for</code> 等），必须用 JS 才能实现；（ JS 是图灵完备的语言）</li>
<li>模板字符串转换为 html 渲染页面，必须用 JS 才能实现；</li>
</ul>
<p>所以模板最终会转换成一个 JS 函数（render 函数）。</p>
<a id="more"></a>
<h3 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h3><h4 id="with用法"><a href="#with用法" class="headerlink" title="with用法"></a>with用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    getAddress: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'beijing'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(obj.name)</span><br><span class="line">  alert(obj.age)</span><br><span class="line">  obj.getAddress()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    alert(age)</span><br><span class="line">    alert(name)</span><br><span class="line">    getAddress()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽量不要在实际开发中使用with，会给代码调试带来问题。</span></span><br></pre></td></tr></table></figure>
<h4 id="render函数原理"><a href="#render函数原理" class="headerlink" title="render函数原理"></a>render函数原理</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;price&#125;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'app'</span>，</span></span><br><span class="line">        data: &#123;</span><br><span class="line">          price: 100</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="javascript">      <span class="comment">// render函数实现</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">with</span>(<span class="keyword">this</span>) &#123; <span class="comment">// this就是vm</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> _c(</span></span><br><span class="line"><span class="javascript">            <span class="string">'div'</span>,</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">              attrs: &#123;<span class="string">'id'</span>: <span class="string">'app'</span>&#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// _c创建标签，_v创建文本节点，_s相当于toString</span></span></span><br><span class="line">            [</span><br><span class="line"><span class="javascript">              _c(<span class="string">'p'</span>, [_v(_s(price))]) <span class="comment">// data中的属性已经被代理到了vm上</span></span></span><br><span class="line">            ]</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// 等价于以下render1（不用with）</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render1</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> vm._c(</span></span><br><span class="line"><span class="javascript">            <span class="string">'div'</span>,</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">              attrs: &#123;<span class="string">'id'</span>: <span class="string">'app'</span>&#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            [</span><br><span class="line"><span class="javascript">              vm._c(<span class="string">'p'</span>, [vm._v(vm._s(vm.price))])</span></span><br><span class="line">            ]</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      /* _c创建标签</span><br><span class="line">      _c(tap, attribute, children)</span><br><span class="line"></span><br><span class="line"><span class="javascript">      tap: <span class="built_in">String</span>，标签</span></span><br><span class="line"><span class="javascript">      attribute: <span class="built_in">Object</span>，标签上的属性;（包括v-<span class="keyword">if</span>,v-<span class="keyword">for</span>,v-bind等）</span></span><br><span class="line">      children: 子元素</span><br><span class="line">      */</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'vm._c='</span>, vm._c) <span class="comment">// ƒ (a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'vm._v='</span>, vm._v) <span class="comment">// ƒ createTextVNode (val) &#123;return new VNode(undefined, undefined, undefined, String(val))&#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'vm._s='</span>, vm._s) <span class="comment">// ƒ toString (val) &#123;return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val)&#125;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>模板中所有信息都包含在了 render 函数中</strong>；</li>
<li>this 即 vm；</li>
<li>with中的 price 即 <code>this.price</code> 即 <code>vm.price</code>；</li>
<li>with中的 <code>_c</code>即 <code>this._c</code> 即 <code>vm._c</code>；</li>
</ul>
<p>vue源码中的render函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue-2.5.13.js</span></span><br><span class="line"><span class="keyword">var</span> createCompiler = createCompilerCreator(<span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template,</span></span></span><br><span class="line"><span class="function"><span class="params">  options</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ast = parse(template.trim(), options);</span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> code = generate(ast, options);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'code.render='</span>, code.render)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast: ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现有如下vue实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>to-do-list by vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue-2.5.13.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// data 独立</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            title: <span class="string">''</span>,</span></span><br><span class="line">            list: []</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// 初始化 Vue 实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: data,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.title)</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.title = <span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其模板对应得render函数为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code.render=</span></span><br><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;  <span class="comment">// this即vm</span></span><br><span class="line">  <span class="keyword">return</span> _c(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      attrs:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [</span><br><span class="line">      _c(</span><br><span class="line">        <span class="string">'div'</span>,</span><br><span class="line">        [</span><br><span class="line">          _c(</span><br><span class="line">            <span class="string">'input'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              directives:[</span><br><span class="line">                &#123;</span><br><span class="line">                  name:<span class="string">"model"</span>,</span><br><span class="line">                  rawName:<span class="string">"v-model"</span>,</span><br><span class="line">                  value:(title),</span><br><span class="line">                  expression:<span class="string">"title"</span></span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              domProps:&#123;</span><br><span class="line">                <span class="string">"value"</span>:(title)</span><br><span class="line">              &#125;,</span><br><span class="line">              on:&#123;</span><br><span class="line">                <span class="string">"input"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>($event.target.composing)<span class="keyword">return</span>;</span><br><span class="line">                  title=$event.target.value</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ),</span><br><span class="line">          _v(<span class="string">" "</span>),</span><br><span class="line">          _c(</span><br><span class="line">            <span class="string">'button'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              on:&#123;</span><br><span class="line">                <span class="string">"click"</span>:add</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            [_v(<span class="string">"submit"</span>)]</span><br><span class="line">          )</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">      _v(<span class="string">" "</span>),</span><br><span class="line">      _c(</span><br><span class="line">        <span class="string">'div'</span>,</span><br><span class="line">        [</span><br><span class="line">          _c(</span><br><span class="line">            <span class="string">'ul'</span>,</span><br><span class="line">            <span class="comment">// 用一个数组来表示v-for</span></span><br><span class="line">            _l((list),<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="keyword">return</span> _c(<span class="string">'li'</span>,[_v(_s(item))])&#125;)</span><br><span class="line">          )</span><br><span class="line">        ]</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vue 中的模板在编译打包后，转变成了 render 函数。</p>
<p>render 函数返回的是 <code>vm._c</code> ，这里 <code>vm._c</code> 跟 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a> 的 h 函数一样，即返回 vnode。故 <strong>render 函数返回的是 vnode</strong>。</p>
<h4 id="render函和-vdom"><a href="#render函和-vdom" class="headerlink" title="render函和 vdom"></a>render函和 vdom</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm._update (vnode) &#123;</span><br><span class="line">  <span class="keyword">const</span> preVnode = vm._vnode;</span><br><span class="line">  vm._vnode = vnode;</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode); <span class="comment">// 初次</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode); <span class="comment">// 新旧对比</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// vm._render即上面的render函数，返回vnode</span></span><br><span class="line">  vm._update(vm._render())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updateComponent</code> 中实现了 vdom 的 patch，页面首次渲染执行 <code>updateComponent</code>，data 中每次修改属性，会执行 <code>updateComponent</code>。（在 <code>Object.defineProperty</code> 的 set 回调中执行 <code>updateComponent</code>）</p>
<h3 id="vue-整个实现流程"><a href="#vue-整个实现流程" class="headerlink" title="vue 整个实现流程"></a>vue 整个实现流程</h3><ul>
<li><p>第一步，模板解析成 render 函数；</p>
<blockquote>
<p>with的用法；</p>
<p>模板中的所有信息都被render函数包含；</p>
<p>模板中用到的data中的属性，都变成了JS变量；</p>
<p>模板中的v-model、v-for、v-on 都变成了JS逻辑；</p>
<p>render函数返回vnode；</p>
</blockquote>
</li>
<li><p>第二步，响应式开始监听；</p>
<blockquote>
<p>Object.defineProperty监听get和set；</p>
<p>将data的属性代理到vm上（通过Object.defineProperty）；与render函数有和关系？</p>
</blockquote>
</li>
<li><p>第三步，首次渲染，显示页面，且绑定依赖；</p>
<blockquote>
<p>初次渲染，执行updateComponent，执行vm.render()；</p>
<p>执行render函数，会访问到vm.list和vm.title；</p>
<p>会被响应式get方法监听到；</p>
<p>执行updateComponent，会走到vdom的patch方法；</p>
<p>patch将vnode渲染成DOM，初次渲染完成；</p>
</blockquote>
<p>为何要监听get，直接监听set不行吗？</p>
<p>data中有很多属性，有些被用到，有些可能不被用到；被用到的会走到get，不会被用到的不会走到get；未走到get中的属性，set的时候我们也无需关心（data中的属性，若没在模板中用到（没在render函数中用到），则不会被监听）；避免不必要的重复渲染。</p>
</li>
<li><p>第四步，data 属性变化，触发 rerender； </p>
<blockquote>
<p>修改属性，被响应式的set监听到；</p>
<p>set执行updateComponent；</p>
<p>updateComponent重新执行vm._render()；</p>
<p>生成的vnode和prevVnode，通过patch进行对比；</p>
<p>渲染到html中；</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/blog/2018/05/16/vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="Vue父子组件通信"><a href="#Vue父子组件通信" class="headerlink" title="Vue父子组件通信"></a>Vue父子组件通信</h2><h3 id="props-amp-this-emit"><a href="#props-amp-this-emit" class="headerlink" title="props &amp; this.$emit()"></a><code>props</code> &amp; <code>this.$emit()</code></h3><p>通过子组件的 props 属性，可以将父组件上的数据传入子组件，如下例中的 <code>deliverNum</code>。 另外，若 props 传递的数据是一个引用类型，在子组件中修改这个数据时，会影响到父组件的状态。<strong>因此通过子组件的 props 属性，可实现父子组件数据的双向传递。</strong></p>
<blockquote>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身<strong>将会</strong>影响到父组件的状态。 </p>
</blockquote>
<a id="more"></a>
<p>子组件 <code>Counter.vue</code>  内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="comment">&lt;!--注意组件必须要有一个根元素，如此处的div标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"increase"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"decrease"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>父传递到子组件的值&#123;&#123;deliverNum&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>子组件值&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">"deliverNum"</span>], <span class="comment">//注意此处的deliverNum即父组件传入的deliverNum，要写相同</span></span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                num: 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            increase: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">"incre"</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            decrease: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">"decre"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>.<br>父组件 <code>Hello.vue</code> 内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Counter</span> <span class="attr">v-bind:deliverNum</span>=<span class="string">"parentNum"</span> <span class="attr">v-on:incre</span>=<span class="string">"increment"</span> <span class="attr">v-on:decre</span>=<span class="string">"decrement"</span>&gt;</span><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span>  <span class="comment">&lt;!--动态传值，加上v-bind--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件的值&#123;&#123;parentNum&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">"./Counter.vue"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">"hello"</span>,</span></span><br><span class="line">        data () &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                parentNum: 10,</span><br><span class="line"><span class="javascript">                msg: <span class="string">"welcome to your vue.js app"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            Counter</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.parentNum++;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.parentNum--;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上例中，当点击 <code>+</code> 时，首先执行子组件内的方法 <code>increase</code> ，该方法会触发父组件的 <code>incre</code> 事件，进而执行父组件中的  <code>increment</code> 方法，令 parentNum++ ，同时 <code>deliverNum=&quot;parentNum&quot;</code> 又将 parentNum 传入子组件进行更新。<br>另外，<code>this.$emit()</code> 方法可以传参，子组件传值，父组件方法被触发时，会接收到传过来的值。因此，<strong>this.$emit() 既可实现子组件内触发父组件方法，又可实现子向父传值。</strong></p>
<h3 id="this-refs-获取子组件实例"><a href="#this-refs-获取子组件实例" class="headerlink" title="this.$refs 获取子组件实例"></a><code>this.$refs</code> 获取子组件实例</h3><p>父子组件内容如下，<code>ref</code> 为子组件指定了一个引用 ID ，通过 <code>this.$refs.child1</code> 获取到的是该子组件的 vue 实例。 <code>this.$refs.child1.showName()</code> 即可令子组件内的 <code>showName()</code> 方法执行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">children</span> <span class="attr">ref</span>=<span class="string">"child1"</span>&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> children <span class="keyword">from</span> <span class="string">'components/children/children.vue'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;      </span><br><span class="line"><span class="javascript">      <span class="string">'children'</span>: children</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child1) <span class="comment">// 返回一个vue对象，所以可以直接调用其方法</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$refs.child1.showName() <span class="comment">// 调用子组件内的showName()方法</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--!子组件--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      showName () &#123;</span><br><span class="line"><span class="javascript">        alert(<span class="string">'river jean'</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="this-parent-amp-this-children"><a href="#this-parent-amp-this-children" class="headerlink" title="this.$parent &amp; this.$children"></a><code>this.$parent</code> &amp; <code>this.$children</code></h3><p>子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p>
<blockquote>
<p>节制地使用 <code>$parent</code> 和 <code>$children</code> - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p>
</blockquote>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/api/#vm-parent" target="_blank" rel="noopener">vm.$parent</a></p>
<ul>
<li><p><strong>类型</strong>：<code>Vue instance</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>父实例，如果当前实例有的话。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/api/#vm-children" target="_blank" rel="noopener">vm.$children</a></p>
<ul>
<li><p><strong>类型</strong>：<code>Array&lt;Vue instance&gt;</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细</strong>：</p>
<p>当前实例的直接子组件。<strong>需要注意 $children 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>
</li>
</ul>
</blockquote>
<p><code>this.$parent</code> 和 <code>this.$children</code> 只可访问实例，不能对其内部数据直接赋值进行修改。</p>
<h2 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h2><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>EventBus（事件总线），在 Vue 中使用 <code>EventBus</code> 来作为组件之间的沟通桥梁，所有组件共用相同的事件中心，向该中心注册发送事件或接收事件，组件可以实现上下平行地通知其他组件。</p>
<p>在 main.js 中，初始化 app 之前，创建消息事件总线：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$eventBus = <span class="keyword">new</span> Vue() <span class="comment">// 创建全局的消息事件总线</span></span><br></pre></td></tr></table></figure>
<p>在组件1里面触发事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$eventBus.$emit(<span class="string">'switchCompany'</span>, <span class="string">'google'</span>)</span><br></pre></td></tr></table></figure>
<p>在组件2里面监听事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    this.$eventBus.$on(&apos;switchCompany&apos;, (name) =&gt; &#123;</span><br><span class="line">        console.log(&apos;监听到switchCompany事件触发，name=&apos;, name)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/api/#vm-once" target="_blank" rel="noopener">vm.$once( event, callback )</a></p>
<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>{string} event</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p>监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/api/#vm-off" target="_blank" rel="noopener">vm.$off( [event, callback] )</a></p>
<ul>
<li><p>参数**：</p>
<ul>
<li><code>{string | Array&lt;string&gt;} event</code> (只在 2.2.2+ 支持数组)</li>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p>移除自定义事件监听器。</p>
<ul>
<li>如果没有提供参数，则移除所有的事件监听器；</li>
<li>如果只提供了事件，则移除该事件所有的监听器；</li>
<li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h2><p>vue 中 page 也属于组件的范畴。每一个的路由对应一个页面，实现页面之间的通信，除了上面提到的事件消息总线，还可以使用路由传参：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Operate.vue</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 跳转到详情页</span></span><br><span class="line">  goToDetail (item, index) &#123;</span><br><span class="line">    <span class="comment">// 将item内容传过去</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">'operate/detail'</span>, <span class="attr">query</span>: &#123;<span class="attr">content</span>: item&#125;&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OperateDetail.vue</span></span><br><span class="line">created () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this.$route.query.content='</span>, <span class="keyword">this</span>.$route.query.content)</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="keyword">this</span>.$route.query.content.title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>上面几种通信方式，存在一定局限性和缺点，vuex 的出现正式为了解决这样的问题：</p>
<blockquote>
<p>当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
</blockquote>
<p>vuex的核心概念及使用：</p>
<blockquote>
<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
</blockquote>
<p>实例：现有如下场景，组件 2 是一个日期选择组件，当组件 2 中的日期发生变化时，组件 1 会根据新的日期字段去请求数据并更新视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">├── router</span><br><span class="line">│   └── index.js</span><br><span class="line">└── store</span><br><span class="line">    └── index.js # 我们组装模块并导出 store 的地方</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./store/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    currentDate: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    updateDate (state, date) &#123;</span><br><span class="line">      state.currentDate = date</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件1</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  currentDate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.currentDate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  currentDate (val, oldVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getData(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="comment">// 请求数据</span></span><br><span class="line">  getData (date) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件2</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  changeDate (date) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateDate'</span>, date)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>【参考链接】：</p>
<p><a href="https://cn.vuejs.org/v2/style-guide/#%E9%9A%90%E6%80%A7%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://cn.vuejs.org/v2/style-guide/#%E9%9A%90%E6%80%A7%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8</a></p>
<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/</a></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>http</title>
    <url>/blog/2019/05/03/web%E5%89%8D%E7%AB%AF-http/</url>
    <content><![CDATA[<h3 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h3><p>http 协议的主要特点：简单快速、灵活、<strong>无连接</strong>、<strong>无状态</strong>。</p>
<ul>
<li><p>简单快速：资源固定，统一资源标识符 URI，统一资源定位符URL 。</p>
<blockquote>
<p>统一资源标志符 URI 就是在某一规则下能把一个资源独一无二地标识出来。如身份证号就是 URI，通过身份证号能让我们能且仅能确定一个人。 </p>
<p>统一资源定位符 URL，URL是以描述资源的位置来唯一确定一个资源的，例如：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人 ，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集 。</p>
</blockquote>
</li>
<li><p>灵活：在 http 协议头部有一个数据类型，通过一个 http 协议就可以实现不同数据类型的传输。</p>
</li>
<li><p>无连接：连接一次之后就会断掉，不会保持连接。</p>
</li>
<li><p>无状态：可理解为客户端和服务端是两种身份，客户端向服务端请求一个图片时，http 建立连接，中间传输，任务完成后，连接就会断开；下一次客户端再向服务端请求时，服务端没法区分上一次连接和这一次连接，是不是同一个人/同一个身份，因为服务端是不会记住状态的，单从 http 协议上是没法区分两次连接者的身份的。（目前网站中的记住身份，是通过服务端的其他方式做到的，不是通过 http 协议。）</p>
</li>
</ul>
<a id="more"></a>
<h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p> HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP/1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<ul>
<li><p>GET：获取资源；</p>
</li>
<li><p>POST：传输资源；</p>
</li>
<li><p>HEAD：获得报文头部；</p>
</li>
<li><p>PUT：更新资源；</p>
</li>
<li><p>DELETE：删除资源；</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">PUT</td>
<td style="text-align:left">从客户端向服务器传送的数据取代指定的文档的内容。（更新资源）</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">PATCH</td>
<td style="text-align:left">实体中包含一个表，表中说明与该URI所表示的原内容的区别。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">MOVE</td>
<td style="text-align:left">请求服务器将指定的页面移至另一个网络地址。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">COPY</td>
<td style="text-align:left">请求服务器将指定的页面拷贝至另一个网络地址。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">LINK</td>
<td style="text-align:left">请求服务器建立链接关系。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">UNLINK</td>
<td style="text-align:left">断开链接关系。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">WRAPPED</td>
<td style="text-align:left">允许客户端发送经过封装的请求。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">Extension-mothed</td>
<td style="text-align:left">在不改动协议的前提下，可增加另外的方法。</td>
</tr>
</tbody>
</table>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>HTTP 状态返回码用来表示指定的 HTTP 请求是否成功完成。响应被分为 5 种类型: 消息型响应，成功响应，重定向，客户端错误和服务器错误。</p>
<ul>
<li><p>1xx：指示信息，表示请求已接收，继续处理；</p>
</li>
<li><p>2xx：成功，表示请求已被成功接收；</p>
</li>
<li><p>3xx：重定向，要完成请求必须进行更进一步的操作；</p>
</li>
<li><p>4xx：客户端错误，请求有语法错误或请求无法实现；</p>
</li>
<li><p>5xx：服务器错误，服务器未能实现合法的请求；</p>
</li>
</ul>
<blockquote>
<p>例：</p>
<p>200 OK ：客户端请求成功；</p>
<p>206 Partial Content：客户发送了一个带有Range（范围）头的GET请求，服务器完成了它；服务器会截取Range指定的一部分内容返回给客户端。如，video标签请求一个视频或音频地址。</p>
<p>301 Moved Permanently：所请求的页面已经转移至新的url；</p>
<p>302 Found：所请求的页面已经临时转移至新的url；</p>
<p>304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户端，原来缓冲的文档还可以继续使用；</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解；</p>
<p>401 Unauthorized：请求未经授权，这个状态码必须和 WWW-Authenticate 报头域一起使用；</p>
<p>403 Forbidden：对被请求页面的访问被禁止；</p>
<p>404 Not Found：请求资源不存在；</p>
<p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用；</p>
<p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常；</p>
</blockquote>
<h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>http 报文的组成部分：</p>
<ul>
<li><p>请求报文：</p>
<ul>
<li>请求行，请求行又包括http方法、页面地址、http协议及版本；</li>
<li>请求头，请求头是key、value值的格式，来告诉服务端我要什么内容、什么类型；</li>
<li>空行，用来让服务端识别，空行以上为请求头，空行以下为请求体；</li>
<li>请求体；</li>
</ul>
</li>
<li><p>响应报文：状态行，响应头，空行，响应体；</p>
</li>
</ul>
<h3 id="post-和-get-的区别"><a href="#post-和-get-的区别" class="headerlink" title="post 和 get 的区别"></a>post 和 get 的区别</h3><p><strong>GET 在浏览器回退时是无害的，而 POST 会再次提交请求；</strong></p>
<p>GET 产生的 URL 地址可以被收藏，而 POST 不会；</p>
<p><strong>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置；</strong></p>
<p>GET 请求只能进行 url 编码，而 POST 支持多种编码方法；</p>
<p><strong>GET 请求参数会被完整保留在浏览器历史记录里面，而 POST 中的参数不会被保留；</strong>（为了防止 csrf 攻击，许多公司将 GET 请求统一改为 POST 请求。）</p>
<p><strong>GET 请求在 URL 中传送的参数是有长度限制的</strong>（一般为2kb，各浏览器有所不同。需要注意的是，使用 get 请求时，拼接的url不要太长，否则会被浏览器截断，因为http对url的长度有限制），<strong>而 POST 没有限制；</strong></p>
<p>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制；</p>
<p>GET 比 POST 更不安全，因为参数直接暴露在 URL上，所有不能用来传递敏感信息。</p>
<p><strong>GET 参数通过 URL传递，POST放在 Request body 中。</strong></p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>什么是持久连接：</p>
<p>HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）</p>
<p>当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。（http 1.1版本才支持持久连接）</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>什么是管线化：</p>
<p>在使用持久连接的情况下，某个连接上的消息的传递类似于： 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</p>
<p>管线化是指在某个持久连接上的消息变成了类似这样： 请求1 -&gt;请求2 -&gt;  请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>
<h4 id="管线化的特点"><a href="#管线化的特点" class="headerlink" title="管线化的特点"></a>管线化的特点</h4><ul>
<li>管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术；</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制；</li>
<li>初次创建连接时不应启动管线化机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议；</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应的顺序并未改变；</li>
<li>HTTP/1.1 要求服务器端支持管线化，但不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可；</li>
<li>由于上面提到的服务器问题，开启管线化很可能并不会带来大幅的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 chrome 和 firefox 默认并未开启管线化支持；</li>
</ul>
<hr>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a></p>
<p><a href="http://tools.jb51.net/table/http_request_method/" target="_blank" rel="noopener">http://tools.jb51.net/table/http_request_method/</a></p>
<p><a href="https://juejin.im/post/5d0de954e51d4556be5b3a6f" target="_blank" rel="noopener">https://juejin.im/post/5d0de954e51d4556be5b3a6f</a></p>
]]></content>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
</search>
